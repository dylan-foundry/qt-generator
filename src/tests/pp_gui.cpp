/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ $TROLLTECH$. All rights reserved.
**
** This file is part of $PRODUCT$.
**
** $CPP_LICENSE$
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#pragma once











extern "C" {













































 extern int errno;









typedef __w64 int            intptr_t;








typedef __w64 unsigned int   uintptr_t;








typedef __w64 int            ptrdiff_t;









typedef __w64 unsigned int   size_t;






typedef unsigned short wchar_t;




















}








#pragma once




#pragma once




#pragma once





#pragma once










































#pragma once

























#pragma comment(lib,"libcp")































































namespace std {
typedef bool _Bool;
}















typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;




















namespace std {

class  _Lockit
	{
public:












	explicit _Lockit()
		{
		}

	explicit _Lockit(int)
		{
		}

	~_Lockit()
		{
		}

	};

class  _Mutex
	{
public:











    void _Lock()
		{
		}

	void _Unlock()
		{
		}

	};

class _Init_locks
	{
public:




	_Init_locks()
		{
		}

	~_Init_locks()
		{
		}

	};
}





extern "C" {
 void __cdecl _Atexit(void (__cdecl *)(void));
}

typedef int _Mbstatet;















#pragma once











namespace std {
using ::ptrdiff_t; using ::size_t;
}









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {























































enum _Uninitialized
	{
	_Noinit};


 void __cdecl _Nomemory();
}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)















#pragma once













#pragma pack(push,8)
















typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);


 __declspec(noreturn) void __cdecl terminate(void);
 __declspec(noreturn) void __cdecl unexpected(void);





 terminate_function __cdecl set_terminate(terminate_function);
 unexpected_function __cdecl set_unexpected(unexpected_function);
 _se_translator_function __cdecl _set_se_translator(_se_translator_function);
 bool __uncaught_exception();


#pragma pack(pop)

















typedef const char *__exString;

class  exception
	{
public:
	exception();
	exception(const char *const&);
	exception(const exception&);
	exception& operator=(const exception&);
	virtual ~exception();
	virtual const char *what() const;

private:
	const char *_m_what;
	int _m_doFree;
	};

 namespace std {



using ::exception;
typedef void (*_Prhand)(const exception&);
extern  _Prhand _Raise_handler;
 bool __cdecl uncaught_exception();

using ::unexpected_handler; using ::set_unexpected; using ::unexpected;
using ::terminate_handler; using ::set_terminate; using ::terminate;




























































































class bad_exception : public exception
	{
public:
	bad_exception(const char *_Message = "bad exception")
		throw ()
		: exception(_Message)
		{
		}

	virtual ~bad_exception() throw ()
		{
		}








	};
}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)


namespace std {

class bad_alloc
	: public exception
	{
public:
	bad_alloc(const char *_Message = "bad allocation") throw ()
		: exception(_Message)
		{
		}

	virtual ~bad_alloc() throw ()
		{
		}








	};



typedef void (__cdecl *new_handler)();



struct nothrow_t
	{
	};

extern const nothrow_t nothrow;



 new_handler __cdecl set_new_handler(new_handler)
	throw ();
}


void __cdecl operator delete(void *) throw ();
void *__cdecl operator new(size_t) throw (...);



inline void *__cdecl operator new(size_t, void *_Where) throw ()
	{
	return (_Where);
	}

inline void __cdecl operator delete(void *, void *) throw ()
	{
	}




inline void *__cdecl operator new[](size_t, void *_Where) throw ()
	{
	return (_Where);
	}

inline void __cdecl operator delete[](void *, void *) throw ()
	{
	}


void __cdecl operator delete[](void *) throw ();

void *__cdecl operator new[](size_t)
	throw (...);



void *__cdecl operator new(size_t, const std::nothrow_t&)
	throw ();

void *__cdecl operator new[](size_t, const std::nothrow_t&)
	throw ();

void __cdecl operator delete(void *, const std::nothrow_t&)
	throw ();

void __cdecl operator delete[](void *, const std::nothrow_t&)
	throw ();



using std::new_handler;


#pragma warning(pop)
#pragma pack(pop)







































































































































































































































































































































































































































































































































































typedef signed char qint8;
typedef unsigned char quint8;
typedef short qint16;
typedef unsigned short quint16;
typedef int qint32;
typedef unsigned int quint32;



typedef __int64 qint64;
typedef unsigned __int64 quint64;







typedef qint64 qlonglong;
typedef quint64 qulonglong;




















typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



























































































































typedef int QNoImplicitBoolCast;





template <typename T>
inline T qAbs(const T &t) { return t >= 0 ? t : -t; }

inline int qRound(double d)
{ return d >= 0.0 ? int(d + 0.5) : int(d - int(d-1) + 0.5) + int(d-1); }

inline qint64 qRound64(double d)
{ return d >= 0.0 ? qint64(d + 0.5) : qint64(d - qint64(d-1) + 0.5) + qint64(d-1); }

template <typename T>
inline const T &qMin(const T &a, const T &b) { if (a < b) return a; return b; }
template <typename T>
inline const T &qMax(const T &a, const T &b) { if (a < b) return b; return a; }
template <typename T>
inline const T &qBound(const T &min, const T &val, const T &max)
{ return qMax(min, qMin(max, val)); }






























class QDataStream;




















































































































































































































































































































































































































































































































































































































































































class QString;
class QSysInfo {
public:
    enum {
        WordSize = (sizeof(void *)<<3)
    };

    enum Endian {
        BigEndian,
        LittleEndian







        , ByteOrder = LittleEndian




    };









    enum WinVersion {
        WV_32s      = 0x0001,
        WV_95       = 0x0002,
        WV_98       = 0x0003,
        WV_Me       = 0x0004,
        WV_DOS_based= 0x000f,

        WV_NT       = 0x0010,
        WV_2000     = 0x0020,
        WV_XP       = 0x0030,
        WV_2003     = 0x0040,
        WV_NT_based = 0x00f0,

        WV_CE       = 0x0100,
        WV_CENET    = 0x0200,
        WV_CE_based = 0x0f00
    };
    static const WinVersion WindowsVersion;






















};

__declspec(dllimport) const char *qVersion();
__declspec(dllimport) bool qSharedBuild();


































































__declspec(dllimport) void qDebug(const char *, ...)



;

__declspec(dllimport) void qWarning(const char *, ...)



;

class QString;
__declspec(dllimport) QString qt_error_string(int errorCode = -1);
__declspec(dllimport) void qCritical(const char *, ...)



;
__declspec(dllimport) void qFatal(const char *, ...)



;




__declspec(dllimport) void qErrnoWarning(int code, const char *msg, ...);
__declspec(dllimport) void qErrnoWarning(const char *msg, ...);

class QDebug;
class QNoDebug;











inline void qt_noop() {}

__declspec(dllimport) void qt_assert(const char *assertion, const char *file, int line);









__declspec(dllimport) void qt_assert_x(const char *where, const char *what, const char *file, int line);









__declspec(dllimport) void qt_check_pointer(const char *, int);







enum QtMsgType { QtDebugMsg, QtWarningMsg, QtCriticalMsg, QtFatalMsg, QtSystemMsg = QtCriticalMsg };

__declspec(dllimport) void qt_message_output(QtMsgType, const char *buf);

typedef void (*QtMsgHandler)(QtMsgType, const char *);
__declspec(dllimport) QtMsgHandler qInstallMsgHandler(QtMsgHandler);



































template <typename T>
class QGlobalStatic
{
public:
    T *pointer;
    bool destroyed;

    inline QGlobalStatic()
        : pointer(0), destroyed(false)
    { }

    inline ~QGlobalStatic()
    {
        delete pointer;
        pointer = 0;
        destroyed = true;
    }
};



























class QBool
{
    bool b;

public:
    inline explicit QBool(bool B) : b(B) {}
    inline operator const void *() const
    { return b ? static_cast<const void *>(this) : static_cast<const void *>(0); }
};

inline bool operator==(QBool b1, bool b2) { return !b1 == !b2; }
inline bool operator==(bool b1, QBool b2) { return !b1 == !b2; }
inline bool operator==(QBool b1, QBool b2) { return !b1 == !b2; }
inline bool operator!=(QBool b1, bool b2) { return !b1 != !b2; }
inline bool operator!=(bool b1, QBool b2) { return !b1 != !b2; }
inline bool operator!=(QBool b1, QBool b2) { return !b1 != !b2; }

static inline bool qFuzzyCompare(double p1, double p2)
{
    return qAbs(p1 - p2) < 0.00000000001;
}

static inline bool qFuzzyCompare(float p1, float p2)
{
    return qAbs(p1 - p2) < 0.000001;
}




























































template <typename T> char QTypeInfoHelper(T*(*)());
void* QTypeInfoHelper(...);

template <typename T> inline bool qIsDetached(T &) { return true; }

template <typename T>
class QTypeInfo
{
public:
    enum {
        isPointer = (1 == sizeof(QTypeInfoHelper((T(*)())0))),
        isComplex = !isPointer,
        isStatic = !isPointer,
        isLarge = (sizeof(T)>sizeof(void*)),
        isDummy = false
    };
};












enum {
    Q_COMPLEX_TYPE = 0,
    Q_PRIMITIVE_TYPE = 0x1,
    Q_STATIC_TYPE = 0,
    Q_MOVABLE_TYPE = 0x2,
    Q_DUMMY_TYPE = 0x4
};































template <> class QTypeInfo<bool> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(bool)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "bool"; } };
template <> class QTypeInfo<char> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(char)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "char"; } };
template <> class QTypeInfo<signed char> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(signed char)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "signed char"; } };
template <> class QTypeInfo<uchar> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uchar)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "uchar"; } };
template <> class QTypeInfo<short> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(short)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "short"; } };
template <> class QTypeInfo<ushort> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ushort)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "ushort"; } };
template <> class QTypeInfo<int> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(int)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "int"; } };
template <> class QTypeInfo<uint> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uint)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "uint"; } };
template <> class QTypeInfo<long> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "long"; } };
template <> class QTypeInfo<ulong> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ulong)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "ulong"; } };
template <> class QTypeInfo<qint64> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(qint64)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "qint64"; } };
template <> class QTypeInfo<quint64> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(quint64)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "quint64"; } };
template <> class QTypeInfo<float> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(float)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "float"; } };
template <> class QTypeInfo<double> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(double)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "double"; } };

template <> class QTypeInfo<long double> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long double)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "long double"; } };






__declspec(dllimport) void *qMalloc(size_t size);
__declspec(dllimport) void qFree(void *ptr);
__declspec(dllimport) void *qRealloc(void *ptr, size_t size);
__declspec(dllimport) void *qMemCopy(void *dest, const void *src, size_t n);
__declspec(dllimport) void *qMemSet(void *dest, int c, size_t n);













#pragma warning(disable: 4251)
#pragma warning(disable: 4244)
#pragma warning(disable: 4275)
#pragma warning(disable: 4514)
#pragma warning(disable: 4800)
#pragma warning(disable: 4097)
#pragma warning(disable: 4706)
#pragma warning(disable: 4786)
#pragma warning(disable: 4660)
#pragma warning(disable: 4355)
#pragma warning(disable: 4231)
#pragma warning(disable: 4710)
#pragma warning(disable: 4530)











class __declspec(dllimport) QFlag
{
    int i;
public:
    inline QFlag(int i);
    inline operator int() const { return i; }
};

inline QFlag::QFlag(int ai) : i(ai) {}






template<typename Enum>
class QFlags
{
    typedef void **Zero;
    int i;
public:
    typedef Enum enum_type;
    inline QFlags(const QFlags &f) : i(f.i) {}
    inline QFlags(Enum f) : i(f) {}
    inline QFlags(Zero = 0) : i(0) {}
    inline QFlags(QFlag f) : i(f) {}

    inline QFlags &operator=(const QFlags &f) { i = f.i; return *this; }
    inline QFlags &operator&=(int mask) {  i &= mask; return *this; }
    inline QFlags &operator&=(uint mask) {  i &= mask; return *this; }
    inline QFlags &operator|=(QFlags f) {  i |= f.i; return *this; }
    inline QFlags &operator|=(Enum f) {  i |= f; return *this; }
    inline QFlags &operator^=(QFlags f) {  i ^= f.i; return *this; }
    inline QFlags &operator^=(Enum f) {  i ^= f; return *this; }


    inline operator int() const { return i;}

    inline QFlags operator|(QFlags f) const { QFlags g; g.i = i | f.i; return g; }
    inline QFlags operator|(Enum f) const { QFlags g; g.i = i | f; return g; }
    inline QFlags operator^(QFlags f) const { QFlags g; g.i = i ^ f.i; return g; }
    inline QFlags operator^(Enum f) const { QFlags g; g.i = i ^ f; return g; }
    inline QFlags operator&(int mask) const { QFlags g; g.i = i & mask; return g; }
    inline QFlags operator&(uint mask) const { QFlags g; g.i = i & mask; return g; }
    inline QFlags operator&(Enum f) const { QFlags g; g.i = i & f; return g; }
    inline QFlags operator~() const { QFlags g; g.i = ~i; return g; }

    inline bool operator!() const { return !i; }
};




































struct QForeachContainerBase {};

template <typename T>
class QForeachContainer : public QForeachContainerBase {
public:
    inline QForeachContainer(const T& t): c(t), brk(0), i(c.begin()), e(c.end()){};
    const T c;
    mutable int brk;
    mutable typename T::const_iterator i, e;
    inline bool condition() const { return (!brk++ && i != e); }
};

template <typename T> inline T *qForeachPointer(const T &) { return 0; }

template <typename T> inline QForeachContainer<T> qForeachContainerNew(const T& t)
{ return QForeachContainer<T>(t); }

template <typename T>
inline const QForeachContainer<T> *qForeachContainer(const QForeachContainerBase *base, const T *)
{ return static_cast<const QForeachContainer<T> *>(base); }




























































class QByteArray;
__declspec(dllimport) QByteArray qgetenv(const char *varName);

inline int qIntCast(double f) { return int(f); }
inline int qIntCast(float f) { return int(f); }
typedef double qreal;








































































enum QtValidLicenseForCoreModule { LicensedCore = true };


enum QtValidLicenseForGuiModule { LicensedGui = true };


enum QtValidLicenseForNetworkModule { LicensedNetwork = true };


enum QtValidLicenseForOpenGLModule { LicensedOpenGL = true };


enum QtValidLicenseForSqlModule { LicensedSql = true };


enum QtValidLicenseForXmlModule { LicensedXml = true };


enum QtValidLicenseForQt3SupportLightModule { LicensedQt3SupportLight = true };


enum QtValidLicenseForQt3SupportModule { LicensedQt3Support = true };











typedef QtValidLicenseForCoreModule QtCoreModule;

class QString;

struct QLatin1Char
{
public:
    inline explicit QLatin1Char(char c) : ch(c) {}
    inline const char toLatin1() const { return ch; }
    inline const ushort unicode() const { return ushort(uchar(ch)); }

private:
    const char ch;
};


class __declspec(dllimport) QChar {
public:
    QChar();

    QChar(char c);
    QChar(uchar c);

    QChar(QLatin1Char ch);
    QChar(uchar c, uchar r);
    inline QChar(ushort rc) : ucs(rc){}
    QChar(short rc);
    QChar(uint rc);
    QChar(int rc);
    enum SpecialCharacter {
        Null = 0x0000,
        Nbsp = 0x00a0,
        ReplacementCharacter = 0xfffd,
        ObjectReplacementCharacter = 0xfffc,
        ByteOrderMark = 0xfeff,
        ByteOrderSwapped = 0xfffe,







        ParagraphSeparator = 0x2029,
        LineSeparator = 0x2028
    };
    QChar(SpecialCharacter sc);



    enum Category
    {
        NoCategory,

        Mark_NonSpacing,
        Mark_SpacingCombining,
        Mark_Enclosing,

        Number_DecimalDigit,
        Number_Letter,
        Number_Other,

        Separator_Space,
        Separator_Line,
        Separator_Paragraph,

        Other_Control,
        Other_Format,
        Other_Surrogate,
        Other_PrivateUse,
        Other_NotAssigned,

        Letter_Uppercase,
        Letter_Lowercase,
        Letter_Titlecase,
        Letter_Modifier,
        Letter_Other,

        Punctuation_Connector,
        Punctuation_Dash,
        Punctuation_Open,
        Punctuation_Close,
        Punctuation_InitialQuote,
        Punctuation_FinalQuote,
        Punctuation_Other,

        Symbol_Math,
        Symbol_Currency,
        Symbol_Modifier,
        Symbol_Other,

        Punctuation_Dask = Punctuation_Dash
    };

    enum Direction
    {
        DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
        DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        NoDecomposition,
        Canonical,
        Font,
        NoBreak,
        Initial,
        Medial,
        Final,
        Isolated,
        Circle,
        Super,
        Sub,
        Vertical,
        Wide,
        Narrow,
        Small,
        Square,
        Compat,
        Fraction




    };

    enum Joining
    {
        OtherJoining, Dual, Right, Center
    };

    enum CombiningClass
    {
        Combining_BelowLeftAttached       = 200,
        Combining_BelowAttached           = 202,
        Combining_BelowRightAttached      = 204,
        Combining_LeftAttached            = 208,
        Combining_RightAttached           = 210,
        Combining_AboveLeftAttached       = 212,
        Combining_AboveAttached           = 214,
        Combining_AboveRightAttached      = 216,

        Combining_BelowLeft               = 218,
        Combining_Below                   = 220,
        Combining_BelowRight              = 222,
        Combining_Left                    = 224,
        Combining_Right                   = 226,
        Combining_AboveLeft               = 228,
        Combining_Above                   = 230,
        Combining_AboveRight              = 232,

        Combining_DoubleBelow             = 233,
        Combining_DoubleAbove             = 234,
        Combining_IotaSubscript           = 240
    };

    enum UnicodeVersion {
        Unicode_Unassigned,
        Unicode_1_1,
        Unicode_2_0,
        Unicode_2_1_2,
        Unicode_3_0,
        Unicode_3_1,
        Unicode_3_2,
        Unicode_4_0
    };


    int digitValue() const;
    QChar toLower() const;
    QChar toUpper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool hasMirrored() const;
    inline bool isLower() const { return category() == Letter_Lowercase; }
    inline bool isUpper() const { return category() == Letter_Uppercase; }




    QChar mirroredChar() const;
    QString decomposition() const;
    Decomposition decompositionTag() const;
    unsigned char combiningClass() const;

    UnicodeVersion unicodeVersion() const;

    const char toAscii() const;
    inline const char toLatin1() const;
    inline const ushort unicode() const { return ucs; }



    inline ushort &unicode() { return ucs; }


    static QChar fromAscii(char c);
    static QChar fromLatin1(char c);

    inline bool isNull() const { return ucs == 0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;
    bool isSymbol() const;

    inline uchar cell() const { return uchar(ucs & 0xff); }
    inline uchar row() const { return uchar((ucs>>8)&0xff); }
    inline void setCell(uchar cell);
    inline void setRow(uchar row);











private:




    ushort ucs;
} ;

template <> class QTypeInfo<QChar> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QChar)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QChar"; } };

inline QChar::QChar() : ucs(0) {}

inline const char QChar::toLatin1() const { return ucs > 0xff ? '\0' : char(ucs); }
inline QChar QChar::fromLatin1(char c) { return QChar(ushort(c)); }

inline QChar::QChar(uchar c, uchar r) : ucs((r << 8) | c){}
inline QChar::QChar(short rc) : ucs(ushort(rc)){}
inline QChar::QChar(uint rc) : ucs(ushort(rc & 0xffff)){}
inline QChar::QChar(int rc) : ucs(ushort(rc & 0xffff)){}
inline QChar::QChar(SpecialCharacter s) : ucs(ushort(s)) {}
inline QChar::QChar(QLatin1Char ch) : ucs(ch.unicode()) {}

inline void QChar::setCell(uchar acell)
{ ucs = (ucs & 0xff00) + acell; }
inline void QChar::setRow(uchar arow)
{ ucs = (ushort(arow)<<8) + (ucs&0xff); }

inline bool operator==(QChar c1, QChar c2) { return c1.unicode() == c2.unicode(); }
inline bool operator!=(QChar c1, QChar c2) { return c1.unicode() != c2.unicode(); }
inline bool operator<=(QChar c1, QChar c2) { return c1.unicode() <= c2.unicode(); }
inline bool operator>=(QChar c1, QChar c2) { return c1.unicode() >= c2.unicode(); }
inline bool operator<(QChar c1, QChar c2) { return c1.unicode() < c2.unicode(); }
inline bool operator>(QChar c1, QChar c2) { return c1.unicode() > c2.unicode(); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QChar &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QChar &);



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































extern "C" {
    long _InterlockedIncrement(volatile long *);
    long _InterlockedDecrement(volatile long *);
    long _InterlockedExchange(volatile long *, long);
    long _InterlockedCompareExchange(volatile long *, long, long);
}
#pragma intrinsic (_InterlockedIncrement)
#pragma intrinsic (_InterlockedDecrement)
#pragma intrinsic (_InterlockedExchange)
#pragma intrinsic (_InterlockedCompareExchange)















inline int q_atomic_test_and_set_int(volatile int *ptr, int expected, int newval)
{ return _InterlockedCompareExchange(reinterpret_cast<volatile long *>(ptr), newval, expected) == expected; }

inline int q_atomic_test_and_set_ptr(volatile void *ptr, void *expected, void *newval)
{ return reinterpret_cast<void *>(_InterlockedCompareExchange(reinterpret_cast<volatile long *>(reinterpret_cast<void * volatile *>(ptr)), reinterpret_cast<long>(newval), reinterpret_cast<long>(expected))) == expected; }

inline int q_atomic_increment(volatile int *ptr)
{ return _InterlockedIncrement(reinterpret_cast<volatile long *>(ptr)); }

inline int q_atomic_decrement(volatile int *ptr)
{ return _InterlockedDecrement(reinterpret_cast<volatile long *>(ptr)); }

inline int q_atomic_set_int(volatile int *ptr, int newval)
{ return _InterlockedExchange(reinterpret_cast<volatile long *>(ptr), newval); }

inline void *q_atomic_set_ptr(volatile void *ptr, void *newval)
{ return reinterpret_cast<void *>(_InterlockedExchange(reinterpret_cast<volatile long *>(reinterpret_cast<void * volatile *>(ptr)), reinterpret_cast<long>(newval))); }





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;
























struct QBasicAtomic {
    volatile int atomic;

    void init(int x = 0)
    { atomic = x; }

    inline bool ref()
    { return q_atomic_increment(&atomic) != 0; }

    inline bool deref()
    { return q_atomic_decrement(&atomic) != 0; }

    inline bool operator==(int x) const
    { return atomic == x; }

    inline bool operator!=(int x) const
    { return atomic != x; }

    inline bool operator!() const
    { return atomic == 0; }

    inline operator int() const
    { return atomic; }

    inline QBasicAtomic &operator=(int x)
    {
        (void) q_atomic_set_int(&atomic, x);
        return *this;
    }

    inline bool testAndSet(int expected, int newval)
    { return q_atomic_test_and_set_int(&atomic, expected, newval) != 0; }

    inline int exchange(int newval)
    { return q_atomic_set_int(&atomic, newval); }
};

template <typename T>
struct QBasicAtomicPointer
{
    volatile T *pointer;

    void init(T *t = 0)
    { pointer = t; }

    inline bool operator==(T *t) const
    { return pointer == t; }

    inline bool operator!=(T *t) const
    { return !operator==(t); }

    inline bool operator!() const
    { return operator==(0); }

    inline operator T *() const
    { return const_cast<T *>(pointer); }

    inline T *operator->() const
    { return const_cast<T *>(pointer); }

    inline QBasicAtomicPointer<T> &operator=(T *t)
    {
        (void) q_atomic_set_ptr(&pointer, t);
        return *this;
    }

    inline bool testAndSet(T *expected, T *newval)
    { return q_atomic_test_and_set_ptr(&pointer, expected, newval); }

    inline T *exchange(T * newval)
    { return static_cast<T *>(q_atomic_set_ptr(&pointer, newval)); }
};





template <typename T>
inline T qAtomicSetPtr(volatile T *ptr, T newval)
{ return static_cast<T>(q_atomic_set_ptr(ptr, newval)); }


class QAtomic : public QBasicAtomic
{
public:
    inline QAtomic(int x = 0)
    { init(x); }
    inline QAtomic(const QAtomic &copy)
    { init(copy); }

    inline QAtomic &operator=(int x)
    {
        (void) QBasicAtomic::operator=(x);
        return *this;
    }

    inline QAtomic &operator=(const QAtomic &copy)
    {
        (void) QBasicAtomic::operator=(copy);
        return *this;
    }
};


template <typename T>
class QAtomicPointer : public QBasicAtomicPointer<T>
{
public:
    inline QAtomicPointer(T *t = 0)
    { init(t); }
    inline QAtomicPointer(const QAtomicPointer<T> &copy)
    { init(copy); }

    inline QAtomicPointer<T> &operator=(T *t)
    {
        (void) QBasicAtomicPointer<T>::operator=(t);
        return *this;
    }

    inline QAtomicPointer<T> &operator=(const QAtomicPointer<T> &copy)
    {
        (void) QBasicAtomicPointer<T>::operator=(copy);
        return *this;
    }
};










template <typename T>
inline void qAtomicAssign(T *&d, T *x)
{
    x->ref.ref();
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        delete x;
}




template <typename T>
inline void qAtomicAssign(QBasicAtomicPointer<T> &d, T *x)
{
    x->ref.ref();
    x = d.exchange(x);
    if (!x->ref.deref())
        delete x;
}




template <typename T>
inline void qAtomicAssign(QBasicAtomicPointer<T> &d, const QBasicAtomicPointer<T> &x)
{ qAtomicAssign<T>(d, x); }











template <typename T>
inline void qAtomicDetach(T *&d)
{
    if (d->ref == 1)
        return;
    T *x = new T(*d);
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        delete x;
}




template <typename T>
inline void qAtomicDetach(QBasicAtomicPointer<T> &d)
{
    if (d->ref == 1)
        return;
    T *x = new T(*d);
    x = d.exchange(x);
    if (!x->ref.deref())
        delete x;
}





















#pragma once











extern "C" {







































































        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);

 void *  __cdecl _memccpy(void *, const void *, int, size_t);
 void *  __cdecl memchr(const void *, int, size_t);
 int     __cdecl _memicmp(const void *, const void *, size_t);




 void *  __cdecl memmove(void *, const void *, size_t);



 char *  __cdecl strchr(const char *, int);
 int     __cdecl _strcmpi(const char *, const char *);
 int     __cdecl _stricmp(const char *, const char *);
 int     __cdecl strcoll(const char *, const char *);
 int     __cdecl _stricoll(const char *, const char *);
 int     __cdecl _strncoll(const char *, const char *, size_t);
 int     __cdecl _strnicoll(const char *, const char *, size_t);
 size_t  __cdecl strcspn(const char *, const char *);
 char *  __cdecl _strdup(const char *);
 char *  __cdecl _strerror(const char *);
 char *  __cdecl strerror(int);
 char *  __cdecl _strlwr(char *);
 char *  __cdecl strncat(char *, const char *, size_t);
 int     __cdecl strncmp(const char *, const char *, size_t);
 int     __cdecl _strnicmp(const char *, const char *, size_t);
 char *  __cdecl strncpy(char *, const char *, size_t);
 char *  __cdecl _strnset(char *, int, size_t);
 char *  __cdecl strpbrk(const char *, const char *);
 char *  __cdecl strrchr(const char *, int);
 char *  __cdecl _strrev(char *);
 size_t  __cdecl strspn(const char *, const char *);
 char *  __cdecl strstr(const char *, const char *);
 char *  __cdecl strtok(char *, const char *);
 char *  __cdecl _strupr(char *);
 size_t  __cdecl strxfrm (char *, const char *, size_t);





 void * __cdecl memccpy(void *, const void *, int, size_t);
 int __cdecl memicmp(const void *, const void *, size_t);
 int __cdecl strcmpi(const char *, const char *);
 int __cdecl stricmp(const char *, const char *);
 char * __cdecl strdup(const char *);
 char * __cdecl strlwr(char *);
 int __cdecl strnicmp(const char *, const char *, size_t);
 char * __cdecl strnset(char *, int, size_t);
 char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
 char * __cdecl strupr(char *);








 wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
 wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
 int __cdecl wcscmp(const wchar_t *, const wchar_t *);
 wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
 size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
 size_t __cdecl wcslen(const wchar_t *);
 wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
 int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
 wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
 wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
 wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
 size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
 wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
 wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
 wchar_t * __cdecl _wcserror(int);
 wchar_t * __cdecl __wcserror(const wchar_t *);

 wchar_t * __cdecl _wcsdup(const wchar_t *);
 int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
 int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
 wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
 wchar_t * __cdecl _wcsrev(wchar_t *);
 wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

 wchar_t * __cdecl _wcslwr(wchar_t *);
 wchar_t * __cdecl _wcsupr(wchar_t *);
 size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
 int __cdecl wcscoll(const wchar_t *, const wchar_t *);
 int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
 int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
 int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);







 wchar_t * __cdecl wcsdup(const wchar_t *);
 int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
 int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
 wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
 wchar_t * __cdecl wcsrev(wchar_t *);
 wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
 wchar_t * __cdecl wcslwr(wchar_t *);
 wchar_t * __cdecl wcsupr(wchar_t *);
 int __cdecl wcsicoll(const wchar_t *, const wchar_t *);








}




















#pragma once















#pragma pack(push,8)



extern "C" {



























typedef char *  va_list;










































































































































}



#pragma pack(pop)










typedef QtValidLicenseForCoreModule QtCoreModule;





__declspec(dllimport) char *qstrdup(const char *);

inline uint qstrlen(const char *str)
{ return str ? uint(strlen(str)) : 0; }

__declspec(dllimport) char *qstrcpy(char *dst, const char *src);
__declspec(dllimport) char *qstrncpy(char *dst, const char *src, uint len);

__declspec(dllimport) int qstrcmp(const char *str1, const char *str2);

inline int qstrncmp(const char *str1, const char *str2, uint len)
{
    return (str1 && str2) ? strncmp(str1, str2, len)
        : (str1 ? 1 : (str2 ? -1 : 0));
}
__declspec(dllimport) int qstricmp(const char *, const char *);
__declspec(dllimport) int qstrnicmp(const char *, const char *, uint len);


__declspec(dllimport) int qvsnprintf(char *str, size_t n, const char *fmt, va_list ap);
__declspec(dllimport) int qsnprintf(char *str, size_t n, const char *fmt, ...);
















__declspec(dllimport) quint16 qChecksum(const char *s, uint len);

class QByteRef;
class QString;
class QDataStream;
template <typename T> class QList;

class __declspec(dllimport) QByteArray
{
public:
    inline QByteArray();
    QByteArray(const char *);
    QByteArray(const char *, int size);
    QByteArray(int size, char c);
    inline QByteArray(const QByteArray &);
    inline ~QByteArray();

    QByteArray &operator=(const QByteArray &);
    QByteArray &operator=(const char *str);

    inline int size() const;
    bool isEmpty() const;
    void resize(int size);

    QByteArray &fill(char c, int size = -1);

    int capacity() const;
    void reserve(int size);
    void squeeze();

    operator const char *() const;
    operator const void *() const;
    char *data();
    const char *data() const;
    inline const char *constData() const;
    inline void detach();
    bool isDetached() const;
    void clear();

    const char at(int i) const;
    const char operator[](int i) const;
    QByteRef operator[](int i);
    const char operator[](uint i) const;
    QByteRef operator[](uint i);

    int indexOf(char c, int from = 0) const;
    inline int indexOf(const char *c, int from = 0) const;
    int indexOf(const QByteArray &a, int from = 0) const;
    int lastIndexOf(char c, int from = -1) const;
    inline int lastIndexOf(const char *c, int from = -1) const;
    int lastIndexOf(const QByteArray &a, int from = -1) const;

    QBool contains(char c) const;
    QBool contains(const char *a) const;
    QBool contains(const QByteArray &a) const;
    int count(char c) const;
    int count(const char *a) const;
    int count(const QByteArray &a) const;

    QByteArray left(int len) const;
    QByteArray right(int len) const;
    QByteArray mid(int index, int len = -1) const;

    bool startsWith(const QByteArray &a) const;
    bool startsWith(char c) const;
    bool startsWith(const char *c) const;

    bool endsWith(const QByteArray &a) const;
    bool endsWith(char c) const;
    bool endsWith(const char *c) const;

    void truncate(int pos);
    void chop(int n);

    QByteArray toLower() const;
    QByteArray toUpper() const;

    QByteArray trimmed() const;
    QByteArray simplified() const;
    QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;
    QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;








    QByteArray &prepend(char c);
    QByteArray &prepend(const char *s);
    QByteArray &prepend(const QByteArray &a);
    QByteArray &append(char c);
    QByteArray &append(const char *s);
    QByteArray &append(const QByteArray &a);
    QByteArray &insert(int i, char c);
    QByteArray &insert(int i, const char *s);
    QByteArray &insert(int i, const QByteArray &a);
    QByteArray &remove(int index, int len);
    QByteArray &replace(int index, int len, const char *s);
    QByteArray &replace(int index, int len, const QByteArray &s);
    QByteArray &replace(char before, const char *after);
    QByteArray &replace(char before, const QByteArray &after);
    QByteArray &replace(const char *before, const char *after);
    QByteArray &replace(const QByteArray &before, const QByteArray &after);
    QByteArray &replace(const QByteArray &before, const char *after);
    QByteArray &replace(const char *before, const QByteArray &after);
    QByteArray &replace(char before, char after);
    QByteArray &operator+=(char c);
    QByteArray &operator+=(const char *s);
    QByteArray &operator+=(const QByteArray &a);

    QList<QByteArray> split(char sep) const;


    QByteArray &append(const QString &s);
    QByteArray &insert(int i, const QString &s);
    QByteArray &replace(const QString &before, const char *after);
    QByteArray &replace(char c, const QString &after);
    QByteArray &replace(const QString &before, const QByteArray &after);

    QByteArray &operator+=(const QString &s);
    int indexOf(const QString &s, int from = 0) const;
    int lastIndexOf(const QString &s, int from = -1) const;


    inline bool operator==(const QString &s2) const;
    inline bool operator!=(const QString &s2) const;
    inline bool operator<(const QString &s2) const;
    inline bool operator>(const QString &s2) const;
    inline bool operator<=(const QString &s2) const;
    inline bool operator>=(const QString &s2) const;


    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
    QByteArray toBase64() const;

    QByteArray &setNum(short, int base = 10);
    QByteArray &setNum(ushort, int base = 10);
    QByteArray &setNum(int, int base = 10);
    QByteArray &setNum(uint, int base = 10);
    QByteArray &setNum(qlonglong, int base = 10);
    QByteArray &setNum(qulonglong, int base = 10);
    QByteArray &setNum(float, char f = 'g', int prec = 6);
    QByteArray &setNum(double, char f = 'g', int prec = 6);

    static QByteArray number(int, int base = 10);
    static QByteArray number(uint, int base = 10);
    static QByteArray number(qlonglong, int base = 10);
    static QByteArray number(qulonglong, int base = 10);
    static QByteArray number(double, char f = 'g', int prec = 6);
    static QByteArray fromRawData(const char *, int size);
    static QByteArray fromBase64(const QByteArray &base64);

    typedef char *iterator;
    typedef const char *const_iterator;
    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    iterator begin();
    const_iterator begin() const;
    const_iterator constBegin() const;
    iterator end();
    const_iterator end() const;
    const_iterator constEnd() const;


    void push_back(char c);
    void push_back(const char *c);
    void push_back(const QByteArray &a);
    void push_front(char c);
    void push_front(const char *c);
    void push_front(const QByteArray &a);

    inline int count() const { return d->size; }
    int length() const { return d->size; }
    bool isNull() const;


























private:
    operator QNoImplicitBoolCast() const;
    struct Data {
        QBasicAtomic ref;
        int alloc, size;
        char *data;
        char array[1];
    };
    static Data shared_null;
    static Data shared_empty;
    Data *d;
    QByteArray(Data *dd, int , int ) : d(dd) {}
    void realloc(int alloc);
    void expand(int i);

    friend class QByteRef;
    friend class QString;
};

inline QByteArray::QByteArray(): d(&shared_null) { d->ref.ref(); }
inline QByteArray::~QByteArray() { if (!d->ref.deref()) qFree(d); }
inline int QByteArray::size() const
{ return d->size; }
inline const char QByteArray::at(int i) const
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbytearray.h",304);} while (0); return d->data[i]; }
inline const char QByteArray::operator[](int i) const
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbytearray.h",306);} while (0); return d->data[i]; }
inline const char QByteArray::operator[](uint i) const
{ do {if(!(i < uint(size())))qt_assert("i < uint(size())","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbytearray.h",308);} while (0); return d->data[i]; }
inline bool QByteArray::isEmpty() const
{ return d->size == 0; }
inline QByteArray::operator const char *() const
{ return d->data; }
inline QByteArray::operator const void *() const
{ return d->data; }
inline char *QByteArray::data()
{ detach(); return d->data; }
inline const char *QByteArray::data() const
{ return d->data; }
inline const char *QByteArray::constData() const
{ return d->data; }
inline void QByteArray::detach()
{ if (d->ref != 1 || d->data != d->array) realloc(d->size); }
inline bool QByteArray::isDetached() const
{ return d->ref == 1; }
inline QByteArray::QByteArray(const QByteArray &a) : d(a.d)
{ d->ref.ref(); }





inline int QByteArray::capacity() const
{ return d->alloc; }

inline void QByteArray::reserve(int asize)
{ if (d->ref != 1 || asize > d->alloc) realloc(asize); }

inline void QByteArray::squeeze()
{ if (d->size < d->alloc) realloc(d->size); }

class __declspec(dllimport) QByteRef {
    QByteArray &a;
    int i;
    inline QByteRef(QByteArray &array, int idx)
        : a(array),i(idx) {}
    friend class QByteArray;
public:
    inline operator const char() const
        { return i < a.d->size ? a.d->data[i] : 0; }
    inline QByteRef &operator=(char c)
        { if (a.d->ref != 1 || i >= a.d->size) a.expand(i);
          a.d->data[i] = c;  return *this; }
    inline QByteRef &operator=(const QByteRef &c)
        { if (a.d->ref != 1 || i >= a.d->size) a.expand(i);
          a.d->data[i] = c.a.d->data[c.i];  return *this; }
    inline bool operator==(char c) const
    { return a.d->data[i] == c; }
    inline bool operator!=(char c) const
    { return a.d->data[i] != c; }
    inline bool operator>(char c) const
    { return a.d->data[i] > c; }
    inline bool operator>=(char c) const
    { return a.d->data[i] >= c; }
    inline bool operator<(char c) const
    { return a.d->data[i] < c; }
    inline bool operator<=(char c) const
    { return a.d->data[i] <= c; }
};

inline QByteRef QByteArray::operator[](int i)
{ do {if(!(i >= 0))qt_assert("i >= 0","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbytearray.h",371);} while (0); return QByteRef(*this, i); }
inline QByteRef QByteArray::operator[](uint i)
{ return QByteRef(*this, i); }
inline QByteArray::iterator QByteArray::begin()
{ detach(); return d->data; }
inline QByteArray::const_iterator QByteArray::begin() const
{ return d->data; }
inline QByteArray::const_iterator QByteArray::constBegin() const
{ return d->data; }
inline QByteArray::iterator QByteArray::end()
{ detach(); return d->data + d->size; }
inline QByteArray::const_iterator QByteArray::end() const
{ return d->data + d->size; }
inline QByteArray::const_iterator QByteArray::constEnd() const
{ return d->data + d->size; }
inline QByteArray &QByteArray::operator+=(char c)
{ return append(c); }
inline QByteArray &QByteArray::operator+=(const char *s)
{ return append(s); }
inline QByteArray &QByteArray::operator+=(const QByteArray &a)
{ return append(a); }
inline void QByteArray::push_back(char c)
{ append(c); }
inline void QByteArray::push_back(const char *c)
{ append(c); }
inline void QByteArray::push_back(const QByteArray &a)
{ append(a); }
inline void QByteArray::push_front(char c)
{ prepend(c); }
inline void QByteArray::push_front(const char *c)
{ prepend(c); }
inline void QByteArray::push_front(const QByteArray &a)
{ prepend(a); }
inline QBool QByteArray::contains(const QByteArray &a) const
{ return QBool(indexOf(a) != -1); }
inline QBool QByteArray::contains(char c) const
{ return QBool(indexOf(c) != -1); }
inline bool operator==(const QByteArray &a1, const QByteArray &a2)
{ return (a1.size() == a2.size()) && (memcmp(a1, a2, a1.size())==0); }
inline bool operator==(const QByteArray &a1, const char *a2)
{ return a2 ? strcmp(a1,a2) == 0 : a1.isEmpty(); }
inline bool operator==(const char *a1, const QByteArray &a2)
{ return a1 ? strcmp(a1,a2) == 0 : a2.isEmpty(); }
inline bool operator!=(const QByteArray &a1, const QByteArray &a2)
{ return !(a1==a2); }
inline bool operator!=(const QByteArray &a1, const char *a2)
{ return a2 ? strcmp(a1,a2) != 0 : !a1.isEmpty(); }
inline bool operator!=(const char *a1, const QByteArray &a2)
{ return a1 ? strcmp(a1,a2) != 0 : !a2.isEmpty(); }
inline bool operator<(const QByteArray &a1, const QByteArray &a2)
{ return strcmp(a1, a2) < 0; }
 inline bool operator<(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<=(const QByteArray &a1, const QByteArray &a2)
{ return strcmp(a1, a2) <= 0; }
inline bool operator<=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator<=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator>(const QByteArray &a1, const QByteArray &a2)
{ return strcmp(a1, a2) > 0; }
inline bool operator>(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>=(const QByteArray &a1, const QByteArray &a2)
{ return strcmp(a1, a2) >= 0; }
inline bool operator>=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) >= 0; }
inline bool operator>=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) >= 0; }
inline const QByteArray operator+(const QByteArray &a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, const char *a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, char a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const char *a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(char a1, const QByteArray &a2)
{ return QByteArray(&a1, 1) += a2; }
inline int QByteArray::indexOf(const char *c, int i) const
{ return indexOf(fromRawData(c, qstrlen(c)), i); }
inline int QByteArray::lastIndexOf(const char *c, int i) const
{ return lastIndexOf(fromRawData(c, qstrlen(c)), i); }
inline QBool QByteArray::contains(const char *c) const
{ return contains(fromRawData(c, qstrlen(c))); }
inline QByteArray &QByteArray::replace(int index, int len, const char *c)
{ return replace(index, len, fromRawData(c, qstrlen(c))); }
inline QByteArray &QByteArray::replace(char before, const char *c)
{ return replace(before, fromRawData(c, qstrlen(c))); }
inline QByteArray &QByteArray::replace(const QByteArray &before, const char *c)
{ return replace(before, fromRawData(c, qstrlen(c))); }
inline QByteArray &QByteArray::replace(const char *c, const QByteArray &after)
{ return replace(fromRawData(c, qstrlen(c)), after); }
inline QByteArray &QByteArray::replace(const char *before, const char *after)
{ return replace(fromRawData(before, qstrlen(before)), fromRawData(after, qstrlen(after))); }

inline QByteArray &QByteArray::setNum(short n, int base)
{ return setNum(qlonglong(n), base); }
inline QByteArray &QByteArray::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(int n, int base)
{ return setNum(qlonglong(n), base); }
inline QByteArray &QByteArray::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QByteArray &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QByteArray &);



__declspec(dllimport) QByteArray qCompress(const uchar* data, int nbytes, int compressionLevel = -1);
__declspec(dllimport) QByteArray qUncompress(const uchar* data, int nbytes);
inline QByteArray qCompress(const QByteArray& data, int compressionLevel = -1)
{ return qCompress(reinterpret_cast<const uchar *>(data.constData()), data.size(), compressionLevel); }
inline QByteArray qUncompress(const QByteArray& data)
{ return qUncompress(reinterpret_cast<const uchar*>(data.constData()), data.size()); }


template <> class QTypeInfo<QByteArray> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QByteArray)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QByteArray"; } };
template <> inline bool qIsDetached<QByteArray>(QByteArray &t) { return t.isDetached(); }



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;


namespace



Qt {










    enum GlobalColor {
        color0,
        color1,
        black,
        white,
        darkGray,
        gray,
        lightGray,
        red,
        green,
        blue,
        cyan,
        magenta,
        yellow,
        darkRed,
        darkGreen,
        darkBlue,
        darkCyan,
        darkMagenta,
        darkYellow,
        transparent
    };

    enum KeyboardModifier {
        NoModifier           = 0x00000000,
        ShiftModifier        = 0x02000000,
        ControlModifier      = 0x04000000,
        AltModifier          = 0x08000000,
        MetaModifier         = 0x10000000,
        KeypadModifier       = 0x20000000,

        KeyboardModifierMask = 0xfe000000
    };
    typedef QFlags<KeyboardModifier> KeyboardModifiers;


    enum Modifier {
        META          = Qt::MetaModifier,
        SHIFT         = Qt::ShiftModifier,
        CTRL          = Qt::ControlModifier,
        ALT           = Qt::AltModifier,
        MODIFIER_MASK = KeyboardModifierMask,
        UNICODE_ACCEL = 0x00000000
    };

    enum MouseButton {
        NoButton         = 0x00000000,
        LeftButton       = 0x00000001,
        RightButton      = 0x00000002,
        MidButton        = 0x00000004,
        XButton1         = 0x00000008,
        XButton2         = 0x00000010,
        MouseButtonMask  = 0x000000ff
    };
    typedef QFlags<MouseButton> MouseButtons;













    enum Orientation {
        Horizontal = 0x1,
        Vertical = 0x2
    };

    typedef QFlags<Orientation> Orientations;

    enum FocusPolicy {
        NoFocus = 0,
        TabFocus = 0x1,
        ClickFocus = 0x2,
        StrongFocus = TabFocus | ClickFocus | 0x8,
        WheelFocus = StrongFocus | 0x4
    };

    enum SortOrder {
        AscendingOrder,
        DescendingOrder




    };





    enum AlignmentFlag {
        AlignLeft = 0x0001,
        AlignLeading = AlignLeft,
        AlignRight = 0x0002,
        AlignTrailing = AlignRight,
        AlignHCenter = 0x0004,
        AlignJustify = 0x0008,
        AlignAbsolute = 0x0010,
        AlignHorizontal_Mask = AlignLeft | AlignRight | AlignHCenter | AlignJustify | AlignAbsolute,

        AlignTop = 0x0020,
        AlignBottom = 0x0040,
        AlignVCenter = 0x0080,
        AlignVertical_Mask = AlignTop | AlignBottom | AlignVCenter,

        AlignCenter = AlignVCenter | AlignHCenter



    };

    typedef QFlags<AlignmentFlag> Alignment;

    enum TextFlag {
        TextSingleLine = 0x0100,
        TextDontClip = 0x0200,
        TextExpandTabs = 0x0400,
        TextShowMnemonic = 0x0800,
        TextWordWrap = 0x1000,
        TextWrapAnywhere = 0x2000,
        TextDontPrint = 0x4000,
        TextIncludeTrailingSpaces = 0x08000000,
        TextHideMnemonic = 0x8000












    };




    enum TextElideMode {
        ElideLeft,
        ElideRight,
        ElideMiddle
    };

    enum WindowType {
        Widget = 0x00000000,
        Window = 0x00000001,
        Dialog = 0x00000002 | Window,
        Sheet = 0x00000004 | Window,
        Drawer = 0x00000006 | Window,
        Popup = 0x00000008 | Window,
        Tool = 0x0000000a | Window,
        ToolTip = 0x0000000c | Window,
        SplashScreen = 0x0000000e | Window,
        Desktop = 0x00000010 | Window,
        SubWindow =  0x00000012,

        WindowType_Mask = 0x000000ff,
        MSWindowsFixedSizeDialogHint = 0x00000100,
	MSWindowsOwnDC = 0x00000200,
        X11BypassWindowManagerHint = 0x00000400,
        FramelessWindowHint = 0x00000800,
        WindowTitleHint = 0x00001000,
        WindowSystemMenuHint = 0x00002000,
        WindowMinimizeButtonHint = 0x00004000,
        WindowMaximizeButtonHint = 0x00008000,
        WindowMinMaxButtonsHint = WindowMinimizeButtonHint | WindowMaximizeButtonHint,
        WindowContextHelpButtonHint = 0x00010000,
        WindowShadeButtonHint = 0x00020000,
        WindowStaysOnTopHint = 0x00040000


















































    };

    typedef QFlags<WindowType> WindowFlags;

    enum WindowState {
        WindowNoState    = 0x00000000,
        WindowMinimized  = 0x00000001,
        WindowMaximized  = 0x00000002,
        WindowFullScreen = 0x00000004,
        WindowActive     = 0x00000008
    };

    typedef QFlags<WindowState> WindowStates;

    enum WidgetAttribute {
        WA_Disabled = 0,
        WA_UnderMouse = 1,
        WA_MouseTracking = 2,
        WA_ContentsPropagated = 3,
        WA_NoBackground = 4,
        WA_StaticContents = 5,
        WA_LaidOut = 7,
        WA_PaintOnScreen = 8,
        WA_NoSystemBackground = 9,
        WA_UpdatesDisabled = 10,
        WA_Mapped = 11,
        WA_MacNoClickThrough = 12,
        WA_PaintOutsidePaintEvent = 13,
        WA_InputMethodEnabled = 14,
        WA_WState_Visible = 15,
        WA_WState_Hidden = 16,

        WA_ForceDisabled = 32,
        WA_KeyCompression = 33,
        WA_PendingMoveEvent = 34,
        WA_PendingResizeEvent = 35,
        WA_SetPalette = 36,
        WA_SetFont = 37,
        WA_SetCursor = 38,
        WA_NoChildEventsFromChildren = 39,
        WA_WindowModified = 41,
        WA_Resized = 42,
        WA_Moved = 43,
        WA_PendingUpdate = 44,
        WA_InvalidSize = 45,
        WA_MacMetalStyle = 46,
        WA_CustomWhatsThis = 47,
        WA_LayoutOnEntireRect = 48,
        WA_OutsideWSRange = 49,
        WA_GrabbedShortcut = 50,
        WA_TransparentForMouseEvents = 51,
        WA_PaintUnclipped = 52,
        WA_SetWindowIcon = 53,
        WA_NoMouseReplay = 54,
        WA_DeleteOnClose = 55,
        WA_RightToLeft = 56,
        WA_SetLayoutDirection = 57,
        WA_NoChildEventsForParent = 58,
        WA_ForceUpdatesDisabled = 59,

        WA_WState_Created = 60,
        WA_WState_CompressKeys = 61,
        WA_WState_InPaintEvent = 62,
        WA_WState_Reparented = 63,
        WA_WState_ConfigPending = 64,
        WA_WState_Polished = 66,
        WA_WState_DND = 67,
        WA_WState_OwnSizePolicy = 68,
        WA_WState_ExplicitShowHide = 69,

        WA_ShowModal = 70,
        WA_MouseNoMask = 71,
        WA_GroupLeader = 72,
        WA_NoMousePropagation = 73,
        WA_Hover = 74,
        WA_InputMethodTransparent = 75,
        WA_QuitOnClose = 76,

        WA_KeyboardFocusChange = 77,

        WA_AcceptDrops = 78,
        WA_ForceAcceptDrops = 79,


        WA_AttributeCount
    };




    enum ImageConversionFlag {
        ColorMode_Mask          = 0x00000003,
        AutoColor               = 0x00000000,
        ColorOnly               = 0x00000003,
        MonoOnly                = 0x00000002,


        AlphaDither_Mask        = 0x0000000c,
        ThresholdAlphaDither    = 0x00000000,
        OrderedAlphaDither      = 0x00000004,
        DiffuseAlphaDither      = 0x00000008,
        NoAlpha                 = 0x0000000c,

        Dither_Mask             = 0x00000030,
        DiffuseDither           = 0x00000000,
        OrderedDither           = 0x00000010,
        ThresholdDither         = 0x00000020,


        DitherMode_Mask         = 0x000000c0,
        AutoDither              = 0x00000000,
        PreferDither            = 0x00000040,
        AvoidDither             = 0x00000080
    };
    typedef QFlags<ImageConversionFlag> ImageConversionFlags;

    enum BGMode {
        TransparentMode,
        OpaqueMode
    };




















    enum Key {
        Key_Escape = 0x01000000,
        Key_Tab = 0x01000001,
        Key_Backtab = 0x01000002,



        Key_Backspace = 0x01000003,



        Key_Return = 0x01000004,
        Key_Enter = 0x01000005,
        Key_Insert = 0x01000006,
        Key_Delete = 0x01000007,
        Key_Pause = 0x01000008,
        Key_Print = 0x01000009,
        Key_SysReq = 0x0100000a,
        Key_Clear = 0x0100000b,
        Key_Home = 0x01000010,
        Key_End = 0x01000011,
        Key_Left = 0x01000012,
        Key_Up = 0x01000013,
        Key_Right = 0x01000014,
        Key_Down = 0x01000015,
        Key_PageUp = 0x01000016,



        Key_PageDown = 0x01000017,



        Key_Shift = 0x01000020,
        Key_Control = 0x01000021,
        Key_Meta = 0x01000022,
        Key_Alt = 0x01000023,
        Key_CapsLock = 0x01000024,
        Key_NumLock = 0x01000025,
        Key_ScrollLock = 0x01000026,
        Key_F1 = 0x01000030,
        Key_F2 = 0x01000031,
        Key_F3 = 0x01000032,
        Key_F4 = 0x01000033,
        Key_F5 = 0x01000034,
        Key_F6 = 0x01000035,
        Key_F7 = 0x01000036,
        Key_F8 = 0x01000037,
        Key_F9 = 0x01000038,
        Key_F10 = 0x01000039,
        Key_F11 = 0x0100003a,
        Key_F12 = 0x0100003b,
        Key_F13 = 0x0100003c,
        Key_F14 = 0x0100003d,
        Key_F15 = 0x0100003e,
        Key_F16 = 0x0100003f,
        Key_F17 = 0x01000040,
        Key_F18 = 0x01000041,
        Key_F19 = 0x01000042,
        Key_F20 = 0x01000043,
        Key_F21 = 0x01000044,
        Key_F22 = 0x01000045,
        Key_F23 = 0x01000046,
        Key_F24 = 0x01000047,
        Key_F25 = 0x01000048,
        Key_F26 = 0x01000049,
        Key_F27 = 0x0100004a,
        Key_F28 = 0x0100004b,
        Key_F29 = 0x0100004c,
        Key_F30 = 0x0100004d,
        Key_F31 = 0x0100004e,
        Key_F32 = 0x0100004f,
        Key_F33 = 0x01000050,
        Key_F34 = 0x01000051,
        Key_F35 = 0x01000052,
        Key_Super_L = 0x01000053,
        Key_Super_R = 0x01000054,
        Key_Menu = 0x01000055,
        Key_Hyper_L = 0x01000056,
        Key_Hyper_R = 0x01000057,
        Key_Help = 0x01000058,
        Key_Direction_L = 0x01000059,
        Key_Direction_R = 0x01000060,
        Key_Space = 0x20,
        Key_Any = Key_Space,
        Key_Exclam = 0x21,
        Key_QuoteDbl = 0x22,
        Key_NumberSign = 0x23,
        Key_Dollar = 0x24,
        Key_Percent = 0x25,
        Key_Ampersand = 0x26,
        Key_Apostrophe = 0x27,
        Key_ParenLeft = 0x28,
        Key_ParenRight = 0x29,
        Key_Asterisk = 0x2a,
        Key_Plus = 0x2b,
        Key_Comma = 0x2c,
        Key_Minus = 0x2d,
        Key_Period = 0x2e,
        Key_Slash = 0x2f,
        Key_0 = 0x30,
        Key_1 = 0x31,
        Key_2 = 0x32,
        Key_3 = 0x33,
        Key_4 = 0x34,
        Key_5 = 0x35,
        Key_6 = 0x36,
        Key_7 = 0x37,
        Key_8 = 0x38,
        Key_9 = 0x39,
        Key_Colon = 0x3a,
        Key_Semicolon = 0x3b,
        Key_Less = 0x3c,
        Key_Equal = 0x3d,
        Key_Greater = 0x3e,
        Key_Question = 0x3f,
        Key_At = 0x40,
        Key_A = 0x41,
        Key_B = 0x42,
        Key_C = 0x43,
        Key_D = 0x44,
        Key_E = 0x45,
        Key_F = 0x46,
        Key_G = 0x47,
        Key_H = 0x48,
        Key_I = 0x49,
        Key_J = 0x4a,
        Key_K = 0x4b,
        Key_L = 0x4c,
        Key_M = 0x4d,
        Key_N = 0x4e,
        Key_O = 0x4f,
        Key_P = 0x50,
        Key_Q = 0x51,
        Key_R = 0x52,
        Key_S = 0x53,
        Key_T = 0x54,
        Key_U = 0x55,
        Key_V = 0x56,
        Key_W = 0x57,
        Key_X = 0x58,
        Key_Y = 0x59,
        Key_Z = 0x5a,
        Key_BracketLeft = 0x5b,
        Key_Backslash = 0x5c,
        Key_BracketRight = 0x5d,
        Key_AsciiCircum = 0x5e,
        Key_Underscore = 0x5f,
        Key_QuoteLeft = 0x60,
        Key_BraceLeft = 0x7b,
        Key_Bar = 0x7c,
        Key_BraceRight = 0x7d,
        Key_AsciiTilde = 0x7e,

        Key_nobreakspace = 0x0a0,
        Key_exclamdown = 0x0a1,
        Key_cent = 0x0a2,
        Key_sterling = 0x0a3,
        Key_currency = 0x0a4,
        Key_yen = 0x0a5,
        Key_brokenbar = 0x0a6,
        Key_section = 0x0a7,
        Key_diaeresis = 0x0a8,
        Key_copyright = 0x0a9,
        Key_ordfeminine = 0x0aa,
        Key_guillemotleft = 0x0ab,
        Key_notsign = 0x0ac,
        Key_hyphen = 0x0ad,
        Key_registered = 0x0ae,
        Key_macron = 0x0af,
        Key_degree = 0x0b0,
        Key_plusminus = 0x0b1,
        Key_twosuperior = 0x0b2,
        Key_threesuperior = 0x0b3,
        Key_acute = 0x0b4,
        Key_mu = 0x0b5,
        Key_paragraph = 0x0b6,
        Key_periodcentered = 0x0b7,
        Key_cedilla = 0x0b8,
        Key_onesuperior = 0x0b9,
        Key_masculine = 0x0ba,
        Key_guillemotright = 0x0bb,
        Key_onequarter = 0x0bc,
        Key_onehalf = 0x0bd,
        Key_threequarters = 0x0be,
        Key_questiondown = 0x0bf,
        Key_Agrave = 0x0c0,
        Key_Aacute = 0x0c1,
        Key_Acircumflex = 0x0c2,
        Key_Atilde = 0x0c3,
        Key_Adiaeresis = 0x0c4,
        Key_Aring = 0x0c5,
        Key_AE = 0x0c6,
        Key_Ccedilla = 0x0c7,
        Key_Egrave = 0x0c8,
        Key_Eacute = 0x0c9,
        Key_Ecircumflex = 0x0ca,
        Key_Ediaeresis = 0x0cb,
        Key_Igrave = 0x0cc,
        Key_Iacute = 0x0cd,
        Key_Icircumflex = 0x0ce,
        Key_Idiaeresis = 0x0cf,
        Key_ETH = 0x0d0,
        Key_Ntilde = 0x0d1,
        Key_Ograve = 0x0d2,
        Key_Oacute = 0x0d3,
        Key_Ocircumflex = 0x0d4,
        Key_Otilde = 0x0d5,
        Key_Odiaeresis = 0x0d6,
        Key_multiply = 0x0d7,
        Key_Ooblique = 0x0d8,
        Key_Ugrave = 0x0d9,
        Key_Uacute = 0x0da,
        Key_Ucircumflex = 0x0db,
        Key_Udiaeresis = 0x0dc,
        Key_Yacute = 0x0dd,
        Key_THORN = 0x0de,
        Key_ssharp = 0x0df,

























        Key_division = 0x0f7,









        Key_ydiaeresis = 0x0ff,






	Key_Multi_key           = 0x01001120,
	Key_Codeinput           = 0x01001137,
	Key_SingleCandidate     = 0x0100113c,
	Key_MultipleCandidate   = 0x0100113d,
	Key_PreviousCandidate   = 0x0100113e,


	Key_Mode_switch         = 0x0100117e,



	Key_Kanji               = 0x01001121,
	Key_Muhenkan            = 0x01001122,

	Key_Henkan              = 0x01001123,
	Key_Romaji              = 0x01001124,
	Key_Hiragana            = 0x01001125,
	Key_Katakana            = 0x01001126,
	Key_Hiragana_Katakana   = 0x01001127,
	Key_Zenkaku             = 0x01001128,
	Key_Hankaku             = 0x01001129,
	Key_Zenkaku_Hankaku     = 0x0100112a,
	Key_Touroku             = 0x0100112b,
	Key_Massyo              = 0x0100112c,
	Key_Kana_Lock           = 0x0100112d,
	Key_Kana_Shift          = 0x0100112e,
	Key_Eisu_Shift          = 0x0100112f,
	Key_Eisu_toggle         = 0x01001130,









	Key_Hangul              = 0x01001131,
	Key_Hangul_Start        = 0x01001132,
	Key_Hangul_End          = 0x01001133,
	Key_Hangul_Hanja        = 0x01001134,
	Key_Hangul_Jamo         = 0x01001135,
	Key_Hangul_Romaja       = 0x01001136,

	Key_Hangul_Jeonja       = 0x01001138,
	Key_Hangul_Banja        = 0x01001139,
	Key_Hangul_PreHanja     = 0x0100113a,
	Key_Hangul_PostHanja    = 0x0100113b,



	Key_Hangul_Special      = 0x0100113f,



        Key_Dead_Grave          = 0x01001250,
        Key_Dead_Acute          = 0x01001251,
        Key_Dead_Circumflex     = 0x01001252,
        Key_Dead_Tilde          = 0x01001253,
        Key_Dead_Macron         = 0x01001254,
        Key_Dead_Breve          = 0x01001255,
        Key_Dead_Abovedot       = 0x01001256,
        Key_Dead_Diaeresis      = 0x01001257,
        Key_Dead_Abovering      = 0x01001258,
        Key_Dead_Doubleacute    = 0x01001259,
        Key_Dead_Caron          = 0x0100125a,
        Key_Dead_Cedilla        = 0x0100125b,
        Key_Dead_Ogonek         = 0x0100125c,
        Key_Dead_Iota           = 0x0100125d,
        Key_Dead_Voiced_Sound   = 0x0100125e,
        Key_Dead_Semivoiced_Sound = 0x0100125f,
        Key_Dead_Belowdot       = 0x01001260,
        Key_Dead_Hook           = 0x01001261,
        Key_Dead_Horn           = 0x01001262,



        Key_Back  = 0x01000061,
        Key_Forward  = 0x01000062,
        Key_Stop  = 0x01000063,
        Key_Refresh  = 0x01000064,

        Key_VolumeDown = 0x01000070,
        Key_VolumeMute  = 0x01000071,
        Key_VolumeUp = 0x01000072,
        Key_BassBoost = 0x01000073,
        Key_BassUp = 0x01000074,
        Key_BassDown = 0x01000075,
        Key_TrebleUp = 0x01000076,
        Key_TrebleDown = 0x01000077,

        Key_MediaPlay  = 0x01000080,
        Key_MediaStop  = 0x01000081,
        Key_MediaPrevious  = 0x01000082,



        Key_MediaNext  = 0x01000083,
        Key_MediaRecord = 0x01000084,

        Key_HomePage  = 0x01000090,
        Key_Favorites  = 0x01000091,
        Key_Search  = 0x01000092,
        Key_Standby = 0x01000093,
        Key_OpenUrl = 0x01000094,

        Key_LaunchMail  = 0x010000a0,
        Key_LaunchMedia = 0x010000a1,
        Key_Launch0  = 0x010000a2,
        Key_Launch1  = 0x010000a3,
        Key_Launch2  = 0x010000a4,
        Key_Launch3  = 0x010000a5,
        Key_Launch4  = 0x010000a6,
        Key_Launch5  = 0x010000a7,
        Key_Launch6  = 0x010000a8,
        Key_Launch7  = 0x010000a9,
        Key_Launch8  = 0x010000aa,
        Key_Launch9  = 0x010000ab,
        Key_LaunchA  = 0x010000ac,
        Key_LaunchB  = 0x010000ad,
        Key_LaunchC  = 0x010000ae,
        Key_LaunchD  = 0x010000af,
        Key_LaunchE  = 0x010000b0,
        Key_LaunchF  = 0x010000b1,

        Key_MediaLast = 0x0100ffff,


        Key_Select = 0x01010000,
        Key_Yes = 0x01010001,
        Key_No = 0x01010002,


        Key_Context1 = 0x01100000,
        Key_Context2 = 0x01100001,
        Key_Context3 = 0x01100002,
        Key_Context4 = 0x01100003,
        Key_Call = 0x01100004,
        Key_Hangup = 0x01100005,
        Key_Flip = 0x01100006,

        Key_unknown = 0x01ffffff
    };

    enum ArrowType {
        NoArrow,
        UpArrow,
        DownArrow,
        LeftArrow,
        RightArrow
    };

    enum PenStyle {
        NoPen,
        SolidLine,
        DashLine,
        DotLine,
        DashDotLine,
        DashDotDotLine,
        MPenStyle = 0x0f
    };

    enum PenCapStyle {
        FlatCap = 0x00,
        SquareCap = 0x10,
        RoundCap = 0x20,
        MPenCapStyle = 0x30
    };

    enum PenJoinStyle {
        MiterJoin = 0x00,
        BevelJoin = 0x40,
        RoundJoin = 0x80,
        MPenJoinStyle = 0xc0
    };

    enum BrushStyle {
        NoBrush,
        SolidPattern,
        Dense1Pattern,
        Dense2Pattern,
        Dense3Pattern,
        Dense4Pattern,
        Dense5Pattern,
        Dense6Pattern,
        Dense7Pattern,
        HorPattern,
        VerPattern,
        CrossPattern,
        BDiagPattern,
        FDiagPattern,
        DiagCrossPattern,
        LinearGradientPattern,
        RadialGradientPattern,
        ConicalGradientPattern,
        TexturePattern = 24



    };



























































    enum UIEffect {
        UI_General,
        UI_AnimateMenu,
        UI_FadeMenu,
        UI_AnimateCombo,
        UI_AnimateTooltip,
        UI_FadeTooltip,
        UI_AnimateToolBox
    };

    enum CursorShape {
        ArrowCursor,
        UpArrowCursor,
        CrossCursor,
        WaitCursor,
        IBeamCursor,
        SizeVerCursor,
        SizeHorCursor,
        SizeBDiagCursor,
        SizeFDiagCursor,
        SizeAllCursor,
        BlankCursor,
        SplitVCursor,
        SplitHCursor,
        PointingHandCursor,
        ForbiddenCursor,
        WhatsThisCursor,
        BusyCursor,
        LastCursor = BusyCursor,
        BitmapCursor = 24




















    };

    enum TextFormat {
        PlainText,
        RichText,
        AutoText,
        LogText
    };

    enum AspectRatioMode {
        IgnoreAspectRatio,
        KeepAspectRatio,
        KeepAspectRatioByExpanding





    };




    enum AnchorAttribute {
        AnchorName,
        AnchorHref
    };

    enum DockWidgetArea {
        LeftDockWidgetArea = 0x1,
        RightDockWidgetArea = 0x2,
        TopDockWidgetArea = 0x4,
        BottomDockWidgetArea = 0x8,

        DockWidgetArea_Mask = 0xf,
        AllDockWidgetAreas = DockWidgetArea_Mask
    };
    enum {
        NDockWidgetAreas = 4
    };

    typedef QFlags<DockWidgetArea> DockWidgetAreas;

    enum ToolBarArea {
        LeftToolBarArea = 0x1,
        RightToolBarArea = 0x2,
        TopToolBarArea = 0x4,
        BottomToolBarArea = 0x8,

        ToolBarArea_Mask = 0xf,
        AllToolBarAreas = ToolBarArea_Mask
    };

    enum {
        NToolBarAreas = 4
    };

    typedef QFlags<ToolBarArea> ToolBarAreas;























    enum DateFormat {
        TextDate,
        ISODate,
        LocalDate
    };

    enum TimeSpec {
        LocalTime,
        UTC
    };

    enum DayOfWeek {
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
        Sunday = 7
    };

    enum ScrollBarPolicy {
        ScrollBarAsNeeded,
        ScrollBarAlwaysOff,
        ScrollBarAlwaysOn
    };


























    enum CaseSensitivity {
        CaseInsensitive,
        CaseSensitive
    };

    enum Corner {
        TopLeftCorner = 0x00000,
        TopRightCorner = 0x00001,
        BottomLeftCorner = 0x00002,
        BottomRightCorner = 0x00003






    };

    enum ConnectionType {
        AutoConnection,
        DirectConnection,
        QueuedConnection,
        AutoCompatConnection
    };

    enum ShortcutContext {
        WidgetShortcut,
        WindowShortcut,
        ApplicationShortcut
    };

    enum FillRule {
        OddEvenFill,
        WindingFill
    };

    enum ClipOperation {
        NoClip,
        ReplaceClip,
        IntersectClip,
        UniteClip
    };

    enum TransformationMode {
        FastTransformation,
        SmoothTransformation
    };

    enum FocusReason {
        MouseFocusReason,
        TabFocusReason,
        BacktabFocusReason,
        ActiveWindowFocusReason,
        PopupFocusReason,
        ShortcutFocusReason,
        MenuBarFocusReason,
        OtherFocusReason
    };

    enum ContextMenuPolicy {
        NoContextMenu,
        DefaultContextMenu,
        ActionsContextMenu,
        CustomContextMenu
    };

    enum InputMethodQuery {
        ImMicroFocus,
        ImFont,
        ImCursorPosition,
        ImSurroundingText,
        ImCurrentSelection
    };

    enum ToolButtonStyle {
        ToolButtonIconOnly,
        ToolButtonTextOnly,
        ToolButtonTextBesideIcon,
        ToolButtonTextUnderIcon
    };

    enum LayoutDirection {
        LeftToRight,
        RightToLeft
    };

    enum DropAction {
        CopyAction = 0x1,
        MoveAction = 0x2,
        LinkAction = 0x4,
        ActionMask = 0xff,
        TargetMoveAction = 0x8002,
        IgnoreAction = 0x0
    };
    typedef QFlags<DropAction> DropActions;

    enum CheckState {
        Unchecked,
        PartiallyChecked,
        Checked
    };

    enum ItemDataRole {
        DisplayRole = 0,
        DecorationRole = 1,
        EditRole = 2,
        ToolTipRole = 3,
        StatusTipRole = 4,
        WhatsThisRole = 5,

        FontRole = 6,
        TextAlignmentRole = 7,
        BackgroundColorRole = 8,
        TextColorRole = 9,
        CheckStateRole = 10,

        AccessibleTextRole = 11,
        AccessibleDescriptionRole = 12,

        SizeHintRole = 13,

        UserRole = 32
    };

    enum ItemFlag {
        ItemIsSelectable = 1,
        ItemIsEditable = 2,
        ItemIsDragEnabled = 4,
        ItemIsDropEnabled = 8,
        ItemIsUserCheckable = 16,
        ItemIsEnabled = 32,
        ItemIsTristate = 64
    };
    typedef QFlags<ItemFlag> ItemFlags;

    enum MatchFlag {
        MatchExactly = 0,
        MatchContains = 1,
        MatchStartsWith = 2,
        MatchEndsWith = 3,
        MatchRegExp = 4,
        MatchWildcard = 5,
        MatchCaseSensitive = 16,
        MatchWrap = 32,
        MatchRecursive = 64
    };
    typedef QFlags<MatchFlag> MatchFlags;




    typedef void *HANDLE;





    typedef WindowFlags WFlags;
}





inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, Qt::MouseButtons::enum_type f2) { return QFlags<Qt::MouseButtons::enum_type>(f1) | f2; } inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, QFlags<Qt::MouseButtons::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, Qt::Orientations::enum_type f2) { return QFlags<Qt::Orientations::enum_type>(f1) | f2; } inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, QFlags<Qt::Orientations::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, Qt::KeyboardModifiers::enum_type f2) { return QFlags<Qt::KeyboardModifiers::enum_type>(f1) | f2; } inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, QFlags<Qt::KeyboardModifiers::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, Qt::WindowFlags::enum_type f2) { return QFlags<Qt::WindowFlags::enum_type>(f1) | f2; } inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, QFlags<Qt::WindowFlags::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, Qt::Alignment::enum_type f2) { return QFlags<Qt::Alignment::enum_type>(f1) | f2; } inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, QFlags<Qt::Alignment::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, Qt::ImageConversionFlags::enum_type f2) { return QFlags<Qt::ImageConversionFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, QFlags<Qt::ImageConversionFlags::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, Qt::DockWidgetAreas::enum_type f2) { return QFlags<Qt::DockWidgetAreas::enum_type>(f1) | f2; } inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, QFlags<Qt::DockWidgetAreas::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, Qt::ToolBarAreas::enum_type f2) { return QFlags<Qt::ToolBarAreas::enum_type>(f1) | f2; } inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, QFlags<Qt::ToolBarAreas::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, Qt::WindowStates::enum_type f2) { return QFlags<Qt::WindowStates::enum_type>(f1) | f2; } inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, QFlags<Qt::WindowStates::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, Qt::DropActions::enum_type f2) { return QFlags<Qt::DropActions::enum_type>(f1) | f2; } inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, QFlags<Qt::DropActions::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, Qt::ItemFlags::enum_type f2) { return QFlags<Qt::ItemFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, QFlags<Qt::ItemFlags::enum_type> f2) { return f2 | f1; }
inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, Qt::MatchFlags::enum_type f2) { return QFlags<Qt::MatchFlags::enum_type>(f1) | f2; } inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, QFlags<Qt::MatchFlags::enum_type> f2) { return f2 | f1; }

class __declspec(dllimport) QInternal {
public:
    enum PaintDeviceFlags {
        UnknownDevice = 0x00,
        Widget = 0x01,
        Pixmap = 0x02,
        Image = 0x03,
        Printer = 0x04,
        Picture = 0x05,
        Pbuffer = 0x06
    };
    enum RelayoutType {
        RelayoutNormal,
        RelayoutDragging,
        RelayoutDropped
    };
};


















#pragma warning (push)
#pragma warning (disable : 4189)


#pragma once




#pragma once




#pragma once




#pragma once




#pragma once




#pragma once


























#pragma once











extern "C" {



























 extern int errno;

















































}





namespace std {

using ::errno;

}









#pragma once




 #pragma warning(disable: 4514)

















#pragma once
















































































































#pragma once

























#pragma once















#pragma pack(push,8)



extern "C" {














































typedef unsigned short wint_t;
typedef unsigned short wctype_t;








































struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;























































 extern FILE _iob[];














typedef __int64 fpos_t;








































 int __cdecl _filbuf(FILE *);
 int __cdecl _flsbuf(int, FILE *);




 FILE * __cdecl _fsopen(const char *, const char *, int);


 void __cdecl clearerr(FILE *);
 int __cdecl fclose(FILE *);
 int __cdecl _fcloseall(void);




 FILE * __cdecl _fdopen(int, const char *);


 int __cdecl feof(FILE *);
 int __cdecl ferror(FILE *);
 int __cdecl fflush(FILE *);
 int __cdecl fgetc(FILE *);
 int __cdecl _fgetchar(void);
 int __cdecl fgetpos(FILE *, fpos_t *);
 char * __cdecl fgets(char *, int, FILE *);




 int __cdecl _fileno(FILE *);


 int __cdecl _flushall(void);
 FILE * __cdecl fopen(const char *, const char *);
 int __cdecl fprintf(FILE *, const char *, ...);
 int __cdecl fputc(int, FILE *);
 int __cdecl _fputchar(int);
 int __cdecl fputs(const char *, FILE *);
 size_t __cdecl fread(void *, size_t, size_t, FILE *);
 FILE * __cdecl freopen(const char *, const char *, FILE *);
 int __cdecl fscanf(FILE *, const char *, ...);
 int __cdecl fsetpos(FILE *, const fpos_t *);
 int __cdecl fseek(FILE *, long, int);
 long __cdecl ftell(FILE *);
 size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
 int __cdecl getc(FILE *);
 int __cdecl getchar(void);
 int __cdecl _getmaxstdio(void);
 char * __cdecl gets(char *);
 int __cdecl _getw(FILE *);
 void __cdecl perror(const char *);
 int __cdecl _pclose(FILE *);
 FILE * __cdecl _popen(const char *, const char *);
 int __cdecl printf(const char *, ...);
 int __cdecl putc(int, FILE *);
 int __cdecl putchar(int);
 int __cdecl puts(const char *);
 int __cdecl _putw(int, FILE *);
 int __cdecl remove(const char *);
 int __cdecl rename(const char *, const char *);
 void __cdecl rewind(FILE *);
 int __cdecl _rmtmp(void);
 int __cdecl scanf(const char *, ...);
 void __cdecl setbuf(FILE *, char *);
 int __cdecl _setmaxstdio(int);
 int __cdecl setvbuf(FILE *, char *, int, size_t);
 int __cdecl _snprintf(char *, size_t, const char *, ...);
 int __cdecl sprintf(char *, const char *, ...);
 int __cdecl _scprintf(const char *, ...);
 int __cdecl sscanf(const char *, const char *, ...);
 int __cdecl _snscanf(const char *, size_t, const char *, ...);
 char * __cdecl _tempnam(const char *, const char *);
 FILE * __cdecl tmpfile(void);
 char * __cdecl tmpnam(char *);
 int __cdecl ungetc(int, FILE *);
 int __cdecl _unlink(const char *);
 int __cdecl vfprintf(FILE *, const char *, va_list);
 int __cdecl vprintf(const char *, va_list);
 int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
 int __cdecl vsprintf(char *, const char *, va_list);
 int __cdecl _vscprintf(const char *, va_list);












 FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);


 wint_t __cdecl fgetwc(FILE *);
 wint_t __cdecl _fgetwchar(void);
 wint_t __cdecl fputwc(wchar_t, FILE *);
 wint_t __cdecl _fputwchar(wchar_t);
 wint_t __cdecl getwc(FILE *);
 wint_t __cdecl getwchar(void);
 wint_t __cdecl putwc(wchar_t, FILE *);
 wint_t __cdecl putwchar(wchar_t);
 wint_t __cdecl ungetwc(wint_t, FILE *);

 wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
 int __cdecl fputws(const wchar_t *, FILE *);
 wchar_t * __cdecl _getws(wchar_t *);
 int __cdecl _putws(const wchar_t *);

 int __cdecl fwprintf(FILE *, const wchar_t *, ...);
 int __cdecl wprintf(const wchar_t *, ...);
 int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
 int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
 int __cdecl _scwprintf(const wchar_t *, ...);
 int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
 int __cdecl vwprintf(const wchar_t *, va_list);
 int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
 int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
 int __cdecl _vscwprintf(const wchar_t *, va_list);
 int __cdecl fwscanf(FILE *, const wchar_t *, ...);
 int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
 int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
 int __cdecl wscanf(const wchar_t *, ...);






 FILE * __cdecl _wfdopen(int, const wchar_t *);
 FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
 FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
 void __cdecl _wperror(const wchar_t *);
 FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
 int __cdecl _wremove(const wchar_t *);
 wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
 wchar_t * __cdecl _wtmpnam(wchar_t *);







































 int __cdecl fcloseall(void);
 FILE * __cdecl fdopen(int, const char *);
 int __cdecl fgetchar(void);
 int __cdecl fileno(FILE *);
 int __cdecl flushall(void);
 int __cdecl fputchar(int);
 int __cdecl getw(FILE *);
 int __cdecl putw(int, FILE *);
 int __cdecl rmtmp(void);
 char * __cdecl tempnam(const char *, const char *);
 int __cdecl unlink(const char *);




}



#pragma pack(pop)





namespace std {
using ::size_t; using ::fpos_t; using ::FILE;
using ::clearerr; using ::fclose; using ::feof;
using ::ferror; using ::fflush; using ::fgetc;
using ::fgetpos; using ::fgets; using ::fopen;
using ::fprintf; using ::fputc; using ::fputs;
using ::fread; using ::freopen; using ::fscanf;
using ::fseek; using ::fsetpos; using ::ftell;
using ::fwrite; using ::getc; using ::getchar;
using ::gets; using ::perror;
using ::putc; using ::putchar;
using ::printf; using ::puts; using ::remove;
using ::rename; using ::rewind; using ::scanf;
using ::setbuf; using ::setvbuf; using ::sprintf;
using ::sscanf; using ::tmpfile; using ::tmpnam;
using ::ungetc; using ::vfprintf; using ::vprintf;
using ::vsprintf;
}










#pragma once


























#pragma once















#pragma pack(push,8)



extern "C" {































































typedef int (__cdecl * _onexit_t)(void);












typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;















 extern int __mb_cur_max;

 int __cdecl ___mb_cur_max_func(void);































typedef void (__cdecl * _secerr_handler_func)(int, void *);










 extern int errno;
 extern unsigned long _doserrno;



 extern char * _sys_errlist[];
 extern int _sys_nerr;



























 extern int __argc;
 extern char ** __argv;
 extern wchar_t ** __wargv;




 extern char ** _environ;
 extern wchar_t ** _wenviron;


 extern char * _pgmptr;
 extern wchar_t * _wpgmptr;




 extern int _fmode;
 extern int _fileinfo;




 extern unsigned int _osplatform;
 extern unsigned int _osver;
 extern unsigned int _winver;
 extern unsigned int _winmajor;
 extern unsigned int _winminor;





 __declspec(noreturn) void   __cdecl abort(void);
 __declspec(noreturn) void   __cdecl exit(int);








        int    __cdecl abs(int);

        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
 double __cdecl atof(const char *);
 int    __cdecl atoi(const char *);
 long   __cdecl atol(const char *);
 void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
 void * __cdecl calloc(size_t, size_t);
 div_t  __cdecl div(int, int);
 void   __cdecl free(void *);
 char * __cdecl getenv(const char *);
 char * __cdecl _itoa(int, char *, int);

 char * __cdecl _i64toa(__int64, char *, int);
 char * __cdecl _ui64toa(unsigned __int64, char *, int);
 __int64 __cdecl _atoi64(const char *);
 __int64 __cdecl _strtoi64(const char *, char **, int);
 unsigned __int64 __cdecl _strtoui64(const char *, char **, int);




        long __cdecl labs(long);

 ldiv_t __cdecl ldiv(long, long);
 char * __cdecl _ltoa(long, char *, int);
 void * __cdecl malloc(size_t);
 int    __cdecl mblen(const char *, size_t);
 size_t __cdecl _mbstrlen(const char *s);
 int    __cdecl mbtowc(wchar_t *, const char *, size_t);
 size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
 void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
 int    __cdecl rand(void);
 void * __cdecl realloc(void *, size_t);
 int    __cdecl _set_error_mode(int);

 _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);

 void   __cdecl srand(unsigned int);
 double __cdecl strtod(const char *, char **);
 long   __cdecl strtol(const char *, char **, int);
 unsigned long __cdecl strtoul(const char *, char **, int);
 int    __cdecl system(const char *);
 char * __cdecl _ultoa(unsigned long, char *, int);
 int    __cdecl wctomb(char *, wchar_t);
 size_t __cdecl wcstombs(char *, const wchar_t *, size_t);






 wchar_t * __cdecl _itow (int, wchar_t *, int);
 wchar_t * __cdecl _ltow (long, wchar_t *, int);
 wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
 double __cdecl wcstod(const wchar_t *, wchar_t **);
 long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
 unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
 wchar_t * __cdecl _wgetenv(const wchar_t *);
 int    __cdecl _wsystem(const wchar_t *);
 double __cdecl _wtof(const wchar_t *);
 int __cdecl _wtoi(const wchar_t *);
 long __cdecl _wtol(const wchar_t *);

 wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
 wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
 __int64   __cdecl _wtoi64(const wchar_t *);
 __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
 unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);








 char * __cdecl _ecvt(double, int, int *, int *);

 __declspec(noreturn) void   __cdecl _exit(int);



 char * __cdecl _fcvt(double, int, int *, int *);
 char * __cdecl _fullpath(char *, const char *, size_t);
 char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
 void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
 void   __cdecl perror(const char *);
 int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
 void   __cdecl _searchenv(const char *, const char *, char *);
 void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
 void   __cdecl _swab(char *, char *, int);





 wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
 void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
 void   __cdecl _wperror(const wchar_t *);
 int    __cdecl _wputenv(const wchar_t *);
 void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
 void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);






 void __cdecl _seterrormode(int);
 void __cdecl _beep(unsigned, unsigned);
 void __cdecl _sleep(unsigned long);










 int __cdecl tolower(int);


 int __cdecl toupper(int);




















 char * __cdecl ecvt(double, int, int *, int *);
 char * __cdecl fcvt(double, int, int *, int *);
 char * __cdecl gcvt(double, int, char *);
 char * __cdecl itoa(int, char *, int);
 char * __cdecl ltoa(long, char *, int);
        _onexit_t __cdecl onexit(_onexit_t);
 int    __cdecl putenv(const char *);
 void   __cdecl swab(char *, char *, int);
 char * __cdecl ultoa(unsigned long, char *, int);






}




#pragma pack(pop)





namespace std {
using ::size_t; using ::div_t; using ::ldiv_t;

using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;
}










#pragma once




#pragma once




#pragma once





#pragma once











namespace std {
using ::size_t; using ::memchr; using ::memcmp;
using ::memcpy; using ::memmove; using ::memset;
using ::strcat; using ::strchr; using ::strcmp;
using ::strcoll; using ::strcpy; using ::strcspn;
using ::strerror; using ::strlen; using ::strncat;
using ::strncmp; using ::strncpy; using ::strpbrk;
using ::strrchr; using ::strspn; using ::strstr;
using ::strtok; using ::strxfrm;
}










#pragma once





#pragma once




#pragma once






#pragma once





#pragma once




#pragma once






#pragma once




























#pragma once














#pragma pack(push,8)



extern "C" {


















































typedef __w64 long time_t;






typedef __int64 __time64_t;


































































typedef unsigned long _fsize_t;





struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;
        time_t   time_access;
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};



struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;
        time_t   time_access;
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;
        __time64_t  time_access;
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};


















 extern const unsigned short _ctype[];
 extern const unsigned short _wctype[];
 extern const unsigned short *_pctype;
 extern const wctype_t *_pwctype;


























 int __cdecl iswalpha(wint_t);
 int __cdecl iswupper(wint_t);
 int __cdecl iswlower(wint_t);
 int __cdecl iswdigit(wint_t);
 int __cdecl iswxdigit(wint_t);
 int __cdecl iswspace(wint_t);
 int __cdecl iswpunct(wint_t);
 int __cdecl iswalnum(wint_t);
 int __cdecl iswprint(wint_t);
 int __cdecl iswgraph(wint_t);
 int __cdecl iswcntrl(wint_t);
 int __cdecl iswascii(wint_t);
 int __cdecl isleadbyte(int);

 wchar_t __cdecl towupper(wchar_t);
 wchar_t __cdecl towlower(wchar_t);

 int __cdecl iswctype(wint_t, wctype_t);


 int __cdecl is_wctype(wint_t, wctype_t);









 int __cdecl _wchdir(const wchar_t *);
 wchar_t * __cdecl _wgetcwd(wchar_t *, int);
 wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
 int __cdecl _wmkdir(const wchar_t *);
 int __cdecl _wrmdir(const wchar_t *);








 int __cdecl _waccess(const wchar_t *, int);
 int __cdecl _wchmod(const wchar_t *, int);
 int __cdecl _wcreat(const wchar_t *, int);
 intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
 int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
 int __cdecl _wunlink(const wchar_t *);
 int __cdecl _wrename(const wchar_t *, const wchar_t *);
 int __cdecl _wopen(const wchar_t *, int, ...);
 int __cdecl _wsopen(const wchar_t *, int, int, ...);
 wchar_t * __cdecl _wmktemp(wchar_t *);


 intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
 intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
 int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
 int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);









 wchar_t * __cdecl _wsetlocale(int, const wchar_t *);








 intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
 intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
 intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
 intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
 intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
 intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
 intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
 intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
 intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
 int __cdecl _wsystem(const wchar_t *);
























inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,(0x0100|0x1|0x2))); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,0x1)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,0x2)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,0x4)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,0x80)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,0x8)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,0x10)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,0x40|0x10|(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,0x10|(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,0x20)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }


inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & 0x8000); }











typedef unsigned short _ino_t;


typedef unsigned short ino_t;





typedef unsigned int _dev_t;


typedef unsigned int dev_t;





typedef long _off_t;


typedef long off_t;






struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };



struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };




struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };











 int __cdecl _wstat(const wchar_t *, struct _stat *);


 int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
 int __cdecl _wstat64(const wchar_t *, struct __stat64 *);










 wchar_t * __cdecl _cgetws(wchar_t *);
 wint_t __cdecl _getwch(void);
 wint_t __cdecl _getwche(void);
 wint_t __cdecl _putwch(wchar_t);
 wint_t __cdecl _ungetwch(wint_t);
 int __cdecl _cputws(const wchar_t *);
 int __cdecl _cwprintf(const wchar_t *, ...);
 int __cdecl _cwscanf(const wchar_t *, ...);




































































































































































































struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        };







 wchar_t * __cdecl _wasctime(const struct tm *);
 wchar_t * __cdecl _wctime(const time_t *);
 size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
 wchar_t * __cdecl _wstrdate(wchar_t *);
 wchar_t * __cdecl _wstrtime(wchar_t *);


 wchar_t * __cdecl _wctime64(const __time64_t *);







typedef int mbstate_t;
typedef wchar_t _Wint_t;

 wint_t __cdecl btowc(int);
 size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
 size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
 size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

 size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
 size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
 int __cdecl wctob(wint_t);







 void *  __cdecl memmove(void *, const void *, size_t);

void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == 0 || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}




#pragma pack(pop)





namespace std {
using ::mbstate_t; using ::size_t; using ::tm; using ::wint_t;

using ::btowc; using ::fgetwc; using ::fgetws; using ::fputwc;
using ::fputws; using ::fwide; using ::fwprintf;
using ::fwscanf; using ::getwc; using ::getwchar;
using ::mbrlen; using ::mbrtowc; using ::mbsrtowcs;
using ::mbsinit; using ::putwc; using ::putwchar;
using ::swprintf; using ::swscanf; using ::ungetwc;
using ::vfwprintf; using ::vswprintf; using ::vwprintf;
using ::wcrtomb; using ::wprintf; using ::wscanf;
using ::wcsrtombs; using ::wcstol; using ::wcscat;
using ::wcschr; using ::wcscmp; using ::wcscoll;
using ::wcscpy; using ::wcscspn; using ::wcslen;
using ::wcsncat; using ::wcsncmp; using ::wcsncpy;
using ::wcspbrk; using ::wcsrchr; using ::wcsspn;
using ::wcstod; using ::wcstoul; using ::wcsstr;
using ::wcstok; using ::wcsxfrm; using ::wctob;
using ::wmemchr; using ::wmemcmp; using ::wmemcpy;
using ::wmemmove; using ::wmemset; using ::wcsftime;
}










#pragma pack(push,8)
#pragma warning(push,3)
namespace std {






typedef long streamoff;
typedef int streamsize;


extern  fpos_t _Fpz;
extern  const streamoff _BADOFF;


template<class _Statetype>
	class fpos
	{
	typedef fpos<_Statetype> _Myt;

public:
	fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(_Fpz), _Mystate(_Stz)
		{
		}

	fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{
		}

	_Statetype state() const
		{
		return (_Mystate);
		}

	void state(_Statetype _State)
		{
		_Mystate = _State;
		}

	fpos_t seekpos() const
		{
		return (_Fpos);
		}

	operator streamoff() const
		{
		return (_Myoff + ((long)(_Fpos)));
		}

	streamoff operator-(const _Myt& _Right) const
		{
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt& operator+=(streamoff _Off)
		{
		_Myoff += _Off;
		return (*this);
		}

	_Myt& operator-=(streamoff _Off)
		{
		_Myoff -= _Off;
		return (*this);
		}

	_Myt operator+(streamoff _Off) const
		{
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt operator-(streamoff _Off) const
		{
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool operator==(const _Myt& _Right) const
		{
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool operator!=(const _Myt& _Right) const
		{
		return (!(*this == _Right));
		}

private:
	static _Statetype _Stz;
	streamoff _Myoff;
	fpos_t _Fpos;
	_Statetype _Mystate;
	};


template<class _Statetype>
	_Statetype fpos<_Statetype>::_Stz;

typedef fpos<mbstate_t> streampos;
typedef streampos wstreampos;


template<class _Elem>
	struct char_traits
	{
	typedef _Elem char_type;
	typedef _Elem int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef mbstate_t state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(const _Elem *_First)
		{
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{
		return (_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{
		return ((int_type)(-1));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{
		return (_Meta != eof() ? _Meta : !eof());
		}
	};


template<> struct  char_traits<wchar_t>
	{
	typedef wchar_t _Elem;
	typedef _Elem char_type;
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef mbstate_t state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return (::wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{
		return (::wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return (::wmemcpy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{
		return ((const _Elem *)::wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return (::wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{
		return (::wmemset(_First, _Ch, _Count));
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{
		return (_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{
		return ((wint_t)(0xFFFF));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{
		return (_Meta != eof() ? _Meta : !eof());
		}
	};


template<> struct  char_traits<char>
	{
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef mbstate_t state_type;

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
		{
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
		{
		return (_Left < _Right);
		}

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return (::memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{
		return (::strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return ((_Elem *)::memcpy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{
		return ((const _Elem *)::memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{
		return ((_Elem *)::memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{
		return ((_Elem *)::memset(_First, _Ch, _Count));
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta)
		{
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch)
		{
		return ((unsigned char)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{
		return (_Left == _Right);
		}

	static int_type __cdecl eof()
		{
		return ((-1));
		}

	static int_type __cdecl not_eof(const int_type& _Meta)
		{
		return (_Meta != eof() ? _Meta : !eof());
		}
	};


template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;













typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;














}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)

namespace std {

template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
	{
	_Ty _Tmp = _Left;
	_Left = _Right, _Right = _Tmp;
	}


template<class _Ty1,
	class _Ty2> struct pair
	{
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(_Ty1()), second(_Ty2())
		{
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{
		}

	template<class _Other1,
		class _Other2>
		pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{
		}

	void swap(_Myt& _Right)
		{
		std::swap(first, _Right.first);
		std::swap(second, _Right.second);
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

	_Ty1 first;
	_Ty2 second;
	};


template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (_Left.first < _Right.first ||
		!(_Right.first < _Left.first) && _Left.second < _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	bool __cdecl operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	pair<_Ty1, _Ty2> __cdecl make_pair(_Ty1 _Val1, _Ty2 _Val2)
	{
	return (pair<_Ty1, _Ty2>(_Val1, _Val2));
	}


	namespace rel_ops
		{
template<class _Ty> inline
	bool __cdecl operator!=(const _Ty& _Left, const _Ty& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool __cdecl operator>(const _Ty& _Left, const _Ty& _Right)
	{
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool __cdecl operator<=(const _Ty& _Left, const _Ty& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool __cdecl operator>=(const _Ty& _Left, const _Ty& _Right)
	{
	return (!(_Left < _Right));
	}
		}
}
#pragma warning(pop)
#pragma pack(pop)


























#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable:4786)
namespace std {




struct input_iterator_tag
	{
	};

struct output_iterator_tag
	{
	};

struct forward_iterator_tag
	: public input_iterator_tag
	{
	};

struct bidirectional_iterator_tag
	: public forward_iterator_tag
	{
	};

struct random_access_iterator_tag
	: public bidirectional_iterator_tag
	{
	};

struct _Int_iterator_tag
	{
	};


struct _Nonscalar_ptr_iterator_tag
	{
	};
struct _Scalar_ptr_iterator_tag
	{
	};


template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
		struct iterator
	{
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Bidit
		: public iterator<bidirectional_iterator_tag, _Ty, _Diff,
			_Pointer, _Reference>
	{
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Ranit
		: public iterator<random_access_iterator_tag, _Ty, _Diff,
			_Pointer, _Reference>
	{
	};

struct _Outit
	: public iterator<output_iterator_tag, void, void,
		void, void>
	{
	};


template<class _Iter>
	struct iterator_traits
	{
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};


template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference> inline
		_Category _Iter_cat(const iterator<_Category, _Ty, _Diff,
			_Pointer, _Reference>&)
	{
	_Category _Cat;
	return (_Cat);
	}

template<class _Ty> inline
	random_access_iterator_tag _Iter_cat(const _Ty *)
	{
	random_access_iterator_tag _Cat;
	return (_Cat);
	}


inline _Int_iterator_tag _Iter_cat(_Bool)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(char)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(signed char)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(unsigned char)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(short)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(unsigned short)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(int)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(unsigned int)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(long)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(unsigned long)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}


inline _Int_iterator_tag _Iter_cat(__int64)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}

inline _Int_iterator_tag _Iter_cat(unsigned __int64)
	{
	_Int_iterator_tag _Cat;
	return (_Cat);
	}



template<class _T1,
	class _T2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(const _T1&, _T2&)
	{
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}



inline _Scalar_ptr_iterator_tag _Ptr_cat(const _Bool *, _Bool *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const char *, char *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const signed char *, signed char *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned char *,
	unsigned char *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const short *, short *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned short *,
	unsigned short *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const int *, int *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned int *, unsigned int *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long *, long *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long *,
	unsigned long *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const float *, float *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const double *, double *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long double *, long double *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}


inline _Scalar_ptr_iterator_tag _Ptr_cat(const __int64 *, __int64 *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned __int64 *, unsigned __int64 *)
	{
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}



template<class _InIt> inline
	ptrdiff_t distance(_InIt _First, _InIt _Last)
	{
	ptrdiff_t _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{
	_Off += _Last - _First;
	}


template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2>
	class _Ptrit
		: public _Ranit<_Ty, _Diff, _Pointer, _Reference>
	{
public:
	typedef _Ptrit<_Ty, _Diff, _Pointer, _Reference,
		_Pointer2, _Reference2> _Myt;
	_Ptrit()
		{
		}

	_Ptrit(_Pointer _Ptr)
		: current(_Ptr)
		{
		}

	_Ptrit(const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
		_Pointer2, _Reference2>& _Iter)
		: current(_Iter.base())
		{
		}

	_Pointer base() const
		{
		return (current);
		}

	_Reference operator*() const
		{
		return (*current);
		}

	_Pointer operator->() const
		{
		return (&**this);
		}

	_Myt& operator++()
		{
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	bool operator==(int _Right) const
		{
		return (current == (_Pointer)_Right);
		}

	bool operator==(const _Myt& _Right) const
		{
		return (current == _Right.current);
		}

	bool operator!=(const _Myt& _Right) const
		{
		return (!(*this == _Right));
		}

	_Myt& operator+=(_Diff _Off)
		{
		current += _Off;
		return (*this);
		}

	_Myt operator+(_Diff _Off) const
		{
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(_Diff _Off)
		{
		current -= _Off;
		return (*this);
		}

	_Myt operator-(_Diff _Off) const
		{
		return (_Myt(current - _Off));
		}

	_Reference operator[](_Diff _Off) const
		{
		return (*(*this + _Off));
		}

	bool operator<(const _Myt& _Right) const
		{
		return (current < _Right.current);
		}

	bool operator>(const _Myt& _Right) const
		{
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{
		return (!(*this < _Right));
		}

	_Diff operator-(const _Myt& _Right) const
		{
		return (current - _Right.current);
		}

protected:
	_Pointer current;
	};


template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
		_Ptrit<_Ty, _Diff, _Pointer, _Reference, _Pointer2, _Reference2>
			__cdecl operator+(_Diff _Off,
				const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
					_Pointer2, _Reference2>& _Right)
	{
	return (_Right + _Off);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator==(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right == _Left);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator!=(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right != _Left);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator<(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right > _Left);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator>(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator<=(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right >= _Left);
	}

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Pointer2,
	class _Reference2> inline
	bool __cdecl operator>=(
		const _Ptrit<_Ty, _Diff, _Pointer2, _Reference2,
			_Pointer2, _Reference2>& _Left,
		const _Ptrit<_Ty, _Diff, _Pointer, _Reference,
			_Pointer2, _Reference2>& _Right)
	{
	return (_Right <= _Left);
	}


template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{
public:
	typedef reverse_iterator<_RanIt> _Myt;
 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		{
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{
		}

	_RanIt base() const
		{
		return (current);
		}

	reference operator*() const
		{
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{
		return (&**this);
		}

	_Myt& operator++()
		{
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{
		return (current == _Right.current);
		}



	_Myt& operator+=(difference_type _Off)
		{
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{
		return (*(*this + _Off));
		}

	bool _Less(const _Myt& _Right) const
		{
		return (_Right.current < current);
		}

	difference_type _Minus(const _Myt& _Right) const
		{
		return (_Right.current - current);
		}

protected:
	_RanIt current;
	};


template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> __cdecl operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (_Right + _Off);
	}

template<class _RanIt> inline
	ptrdiff_t __cdecl operator-(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (_Left._Minus(_Right));
	}

template<class _RanIt> inline
	bool __cdecl operator==(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (_Left._Equal(_Right));
	}

template<class _RanIt> inline
	bool __cdecl operator!=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _RanIt> inline
	bool __cdecl operator<(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (_Left._Less(_Right));
	}

template<class _RanIt> inline
	bool __cdecl operator>(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (_Right < _Left);
	}

template<class _RanIt> inline
	bool __cdecl operator<=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _RanIt> inline
	bool __cdecl operator>=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{
	return (!(_Left < _Right));
	}


template<class _BidIt,
	class _Ty,
	class _Reference = _Ty&,
	class _Pointer = _Ty *,
	class _Diff = ptrdiff_t>
	class reverse_bidirectional_iterator
		: public _Bidit<_Ty, _Diff, _Pointer, _Reference>
	{
public:
	typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,
		_Pointer, _Diff> _Myt;
	typedef _BidIt iterator_type;

	reverse_bidirectional_iterator()
		{
		}

	explicit reverse_bidirectional_iterator(_BidIt _Right)
		: current(_Right)
		{
		}

	_BidIt base() const
		{
		return (current);
		}

	_Reference operator*() const
		{
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer operator->() const
		{
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt& operator++()
		{
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool operator==(const _Myt& _Right) const
		{
		return (current == _Right.current);
		}

	bool operator!=(const _Myt& _Right) const
		{
		return (!(*this == _Right));
		}

protected:
	_BidIt current;
	};


template<class _BidIt,
	class _BidIt2 = _BidIt>
	class _Revbidit
		: public iterator<
			typename iterator_traits<_BidIt>::iterator_category,
			typename iterator_traits<_BidIt>::value_type,
			typename iterator_traits<_BidIt>::difference_type,
			typename iterator_traits<_BidIt>::pointer,
			typename iterator_traits<_BidIt>::reference>
	{
public:
	typedef _Revbidit<_BidIt, _BidIt2> _Myt;
	typedef typename iterator_traits<_BidIt>::difference_type _Diff;
	typedef typename iterator_traits<_BidIt>::pointer _Pointer;
	typedef typename iterator_traits<_BidIt>::reference _Reference;
	typedef _BidIt iterator_type;

	_Revbidit()
		{
		}

	explicit _Revbidit(_BidIt _Right)
		: current(_Right)
		{
		}

	_Revbidit(const _Revbidit<_BidIt2>& _Other)
		: current (_Other.base())
		{
		}

	_BidIt base() const
		{
		return (current);
		}

	_Reference operator*() const
		{
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer operator->() const
		{
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt& operator++()
		{
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool operator==(const _Myt& _Right) const
		{
		return (current == _Right.current);
		}

	bool operator!=(const _Myt& _Right) const
		{
		return (!(*this == _Right));
		}

protected:
	_BidIt current;
	};


template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, _Elem *, _Elem&>
	{
public:
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;
	typedef typename traits_type::int_type int_type;

	istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
		: _Strbuf(_Sb), _Got(_Sb == 0)
		{
		}

	istreambuf_iterator(istream_type& _Istr) throw ()
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{
		}

	_Elem operator*() const
		{
		if (!_Got)
			((_Myt *)this)->_Peek();
		return (_Val);
		}

	_Myt& operator++()
		{
		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		_Inc();
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{
		if (!_Got)
			((_Myt *)this)->_Peek();
		if (!_Right._Got)
			((_Myt *)&_Right)->_Peek();
		return (_Strbuf == 0 && _Right._Strbuf == 0
			|| _Strbuf != 0 && _Right._Strbuf != 0);
		}

private:
	void _Inc()
		{
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek()
		{
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	streambuf_type *_Strbuf;
	bool _Got;
	_Elem _Val;
	};


template<class _Elem,
	class _Traits> inline
	bool __cdecl operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool __cdecl operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{
	return (!(_Left == _Right));
	}


template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) throw ()
		: _Failed(false), _Strbuf(_Sb)
		{
		}

	ostreambuf_iterator(ostream_type& _Ostr) throw ()
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{
		}

	_Myt& operator=(_Elem _Right)
		{
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{
		return (*this);
		}

	_Myt& operator++()
		{
		return (*this);
		}

	_Myt& operator++(int)
		{
		return (*this);
		}

	bool failed() const throw ()
		{
		return (_Failed);
		}

private:
	bool _Failed;
	streambuf_type *_Strbuf;
	};




template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Nonscalar_ptr_iterator_tag)
	{
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Scalar_ptr_iterator_tag)
	{
	ptrdiff_t _Off = _Last - _First;
	return ((_OutIt)::memmove(&*_Dest, &*_First,
		_Off * sizeof (*_First)) + _Off);
	}


template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
	return (_Copy_backward_opt(_First, _Last, _Dest,
		_Ptr_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		_Nonscalar_ptr_iterator_tag)
	{
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Scalar_ptr_iterator_tag)
	{
	ptrdiff_t _Off = _Last - _First;
	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
		_Off * sizeof (*_First)));
	}


template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
	for (; _First1 != _Last1 && *_First1 == *_First2; )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}


template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}


template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
	return (mismatch(_First1, _Last1, _First2).first == _Last1);
	}

inline bool equal(const char *_First1,
	const char *_Last1, const char *_First2)
	{
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool equal(const signed char *_First1,
	const signed char *_Last1, const signed char *_First2)
	{
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool equal(const unsigned char *_First1,
	const unsigned char *_Last1, const unsigned char *_First2)
	{
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}


template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
	return (mismatch(_First1, _Last1, _First2, _Pred).first == _Last1);
	}


template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void fill(char *_First, char *_Last, int _Val)
	{
	::memset(_First, _Val, _Last - _First);
	}

inline void fill(signed char *_First, signed char *_Last, int _Val)
	{
	::memset(_First, _Val, _Last - _First);
	}

inline void fill(unsigned char *_First, unsigned char *_Last, int _Val)
	{
	::memset(_First, _Val, _Last - _First);
	}


template<class _OutIt,
	class _Diff,
	class _Ty> inline
	void fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{
	for (; 0 < _Count; --_Count, ++_First)
		*_First = _Val;
	}

inline void fill_n(char *_First, size_t _Count, int _Val)
	{
	::memset(_First, _Val, _Count);
	}

inline void fill_n(signed char *_First, size_t _Count, int _Val)
	{
	::memset(_First, _Val, _Count);
	}

inline void fill_n(unsigned char *_First, size_t _Count, int _Val)
	{
	::memset(_First, _Val, _Count);
	}


template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = ::memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
	}














template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Pred(*_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}







template<class _Ty> inline
	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
	{
	return (_Left < _Right ? _Right : _Left);
	}


template<class _Ty,
	class _Pr> inline
	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{
	return (_Pred(_Left, _Right) ? _Right : _Left);
	}


template<class _Ty> inline
	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
	{
	return (_Right < _Left ? _Right : _Left);
	}


template<class _Ty,
	class _Pr> inline
	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{
	return (_Pred(_Right, _Left) ? _Right : _Left);
	}






  #pragma warning(default:4786)
}
#pragma warning(pop)
#pragma pack(pop)


























#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4100)
















namespace std {

template<class _Ty> inline
	_Ty  *_Allocate(size_t _Count, _Ty  *)
	{
	return ((_Ty  *)operator new(_Count * sizeof (_Ty)));
	}


template<class _T1,
	class _T2> inline
	void _Construct(_T1  *_Ptr, const _T2& _Val)
	{
	new ((void  *)_Ptr) _T1(_Val);
	}


template<class _Ty> inline
	void _Destroy(_Ty  *_Ptr)
	{
	(_Ptr)->~_Ty();
	}

template<> inline
	void _Destroy(char  *)
	{
	}

template<> inline
	void _Destroy(wchar_t  *)
	{
	}


template<class _Ty>
	class allocator
	{
public:
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty & reference;
	typedef const _Ty & const_reference;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const
		{
		return (&_Val);
		}

	const_pointer address(const_reference _Val) const
		{
		return (&_Val);
		}

	allocator()
		{
		}

	allocator(const allocator<_Ty>&)
		{
		}

	template<class _Other>
		allocator(const allocator<_Other>&)
		{
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{
		return (*this);
		}

	pointer allocate(size_type _Count, const void *)
		{
		return (_Allocate(_Count, (pointer)0));
		}

	pointer allocate(size_type _Count)
		{
		return (_Allocate(_Count, (pointer)0));
		}

	void deallocate(pointer _Ptr, size_type)
		{
		operator delete(_Ptr);
		}

	void construct(pointer _Ptr, const _Ty& _Val)
		{
		_Construct(_Ptr, _Val);
		}

	void destroy(pointer _Ptr)
		{
		_Destroy(_Ptr);
		}

	size_t max_size() const
		{
		size_t _Count = (size_t)(-1) / sizeof (_Ty);
		return (0 < _Count ? _Count : 1);
		}
	};


template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&, const allocator<_Other>&)
	{
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_Other>&)
	{
	return (false);
	}


template<> class  allocator<void>
	{
public:
	typedef void _Ty;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{
		typedef allocator<_Other> other;
		};

	allocator()
		{
		}

	allocator(const allocator<_Ty>&)
		{
		}

	template<class _Other>
		allocator(const allocator<_Other>&)
		{
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{
		return (*this);
		}
	};


template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al)
	{
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{
	}
}

  #pragma warning(default: 4100)
#pragma warning(pop)
#pragma pack(pop)


























#pragma pack(push,8)
#pragma warning(push,3)
 #pragma warning(disable: 4251)
namespace std {


class  _String_base
	{
public:
	void _Xlen() const;

	void _Xran() const;
	};


template<class _Ty,
	class _Alloc>
	class _String_val
		: public _String_base
	{
protected:
	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	_String_val(_Alty _Al = _Alty())
		: _Alval(_Al)
		{
		}

	_Alty _Alval;
	};


template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string
		: public _String_val<_Elem, _Ax>
	{
public:
	typedef basic_string<_Elem, _Traits, _Ax> _Myt;
	typedef _String_val<_Elem, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;
	typedef _Ptrit<value_type, difference_type, _Tptr,
		reference, _Tptr, reference> iterator;
	typedef _Ptrit<value_type, difference_type, _Ctptr,
		const_reference, _Tptr, reference> const_iterator;
	typedef std::reverse_iterator<iterator>
		reverse_iterator;
	typedef std::reverse_iterator<const_iterator>
		const_reverse_iterator;

	basic_string()
		: _Mybase()
		{
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		}

	basic_string(const _Myt& _Right)
		: _Mybase(_Right._Alval)
		{
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase()
		{
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _It>
		basic_string(_It _First, _It _Last)
		: _Mybase()
		{
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		basic_string(_It _First, _It _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		void _Construct(_It _Count, _It _Ch, _Int_iterator_tag)
		{
		assign((size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void _Construct(_It _First, _It _Last, input_iterator_tag)
		{
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _It>
		void _Construct(_It _First, _It _Last, forward_iterator_tag)
		{
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);

		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	basic_string(const_pointer _First, const_pointer _Last)
		: _Mybase()
		{
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(const_iterator _First, const_iterator _Last)
		: _Mybase()
		{
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	~basic_string()
		{
		_Tidy(true);
		}

	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	static const size_type npos;

	_Myt& operator=(const _Myt& _Right)
		{
		return (assign(_Right));
		}

	_Myt& operator=(const _Elem *_Ptr)
		{
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right, size_type _Roff, size_type _Count)
		{
		if (_Right.size() < _Roff)
			_String_base::_Xran();
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::copy(_Myptr() + _Mysize,
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{
		if (_Inside(_Ptr))
			return (append(*this, _Ptr - _Myptr(), _Count));
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _It>
		_Myt& append(_It _First, _It _Last)
		{
		return (_Append(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt& _Append(_It _Count, _It _Ch, _Int_iterator_tag)
		{
		return (append((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Append(_It _First, _It _Last, input_iterator_tag)
		{
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right, size_type _Roff, size_type _Count)
		{
		if (_Right.size() < _Roff)
			_String_base::_Xran();
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);
		else if (_Grow(_Num, true))
			{
			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Num)
		{
		if (_Inside(_Ptr))
			return (assign(*this, _Ptr - _Myptr(), _Num));

		if (_Grow(_Num, true))
			{
			_Traits::copy(_Myptr(), _Ptr, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{
		if (_Count == npos)
			_String_base::_Xlen();

		if (_Grow(_Count, true))
			{
			_Traits::assign(_Myptr(), _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _It>
		_Myt& assign(_It _First, _It _Last)
		{
		return (_Assign(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt& _Assign(_It _Count, _It _Ch, _Int_iterator_tag)
		{
		return (assign((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Assign(_It _First, _It _Last, input_iterator_tag)
		{
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right, size_type _Roff,
		size_type _Count)
		{
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);
			if (this == &_Right)
				_Traits::move(_Myptr() + _Off,
					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);
			else
				_Traits::copy(_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr, size_type _Count)
		{
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - _Myptr(), _Count));
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);
			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off, size_type _Count, _Elem _Ch)
		{
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);
			_Traits::assign(_Myptr() + _Off, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(iterator _Where)
		{
		return (insert(_Where, _Elem()));
		}

	iterator insert(iterator _Where, _Elem _Ch)
		{
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, _Elem _Ch)
		{
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, _Count, _Ch);
		}

	template<class _It>
		void insert(iterator _Where, _It _First, _It _Last)
		{
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		void _Insert(iterator _Where, _It _Count, _It _Ch,
			_Int_iterator_tag)
		{
		insert(_Where, (size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last,
			input_iterator_tag)
		{
		replace(_Where, _Where, _First, _Last);
		}

	void insert(iterator _Where, const_pointer _First, const_pointer _Last)
		{
		replace(_Where, _Where, _First, _Last);
		}

	void insert(iterator _Where, const_iterator _First, const_iterator _Last)
		{
		replace(_Where, _Where, _First, _Last);
		}

	_Myt& erase(size_type _Off = 0, size_type _Count = npos)
		{
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;
		if (0 < _Count)
			{
			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
				_Mysize - _Off - _Count);
			size_type _Newsize = _Mysize - _Count;
			if (_Grow(_Newsize))
				_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(iterator _Where)
		{
		size_type _Count = _Pdif(_Where, begin());
		erase(_Count, 1);
		return (iterator(_Myptr() + _Count));
		}

	iterator erase(iterator _First, iterator _Last)
		{
		size_type _Count = _Pdif(_First, begin());
		erase(_Count, _Pdif(_Last, _First));
		return (iterator(_Myptr() + _Count));
		}

	void clear()
		{
		erase(begin(), end());
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();

		size_type _Nm = _Mysize - _N0 - _Off;
		size_type _Newsize = _Mysize + _Count - _N0;
		if (_Mysize < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
			_Traits::copy(_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);
			}
		else if (_Count <= _N0)
			{
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _Count);
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
			}
		else if (_Roff <= _Off)
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _Count);
			}
		else if (_Off + _N0 <= _Roff)
			{
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
			_Traits::move(_Myptr() + _Off,
				_Myptr() + (_Roff + _Count - _N0), _Count);
			}
		else
			{
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _N0);
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
			_Traits::move(_Myptr() + _Off + _N0, _Myptr() + _Roff + _Count,
				_Count - _N0);
			}

		if (_Mysize < _Newsize || _Grow(_Newsize))
			_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr,
		size_type _Count)
		{
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - _Myptr(), _Count));
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{
			if (_N0 < _Count)
				_Traits::move(_Myptr() + _Off + _Count,
					_Myptr() + _Off + _N0, _Nm);
			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off, size_type _N0,
		size_type _Count, _Elem _Ch)
		{
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{
			if (_N0 < _Count)
				_Traits::move(_Myptr() + _Off + _Count,
					_Myptr() + _Off + _N0, _Nm);
			_Traits::assign(_Myptr() + _Off, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(iterator _First, iterator _Last, const _Myt& _Right)
		{
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}

	_Myt& replace(iterator _First, iterator _Last, const _Elem *_Ptr,
		size_type _Count)
		{
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}

	_Myt& replace(iterator _First, iterator _Last, const _Elem *_Ptr)
		{
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}

	_Myt& replace(iterator _First, iterator _Last,
		size_type _Count, _Elem _Ch)
		{
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}

	template<class _It>
		_Myt& replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2)
		{
		return (_Replace(_First, _Last,
			_First2, _Last2, _Iter_cat(_First2)));
		}

	template<class _It>
		_Myt& _Replace(iterator _First, iterator _Last,
			_It _Count, _It _Ch, _Int_iterator_tag)
		{
		return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2, input_iterator_tag)
		{
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(iterator _First, iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(iterator _First, iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin()
		{
		return (iterator(_Myptr()));
		}

	const_iterator begin() const
		{
		return (const_iterator(_Myptr()));
		}

	iterator end()
		{
		return (iterator(_Myptr() + _Mysize));
		}

	const_iterator end() const
		{
		return (const_iterator(_Myptr() + _Mysize));
		}

	reverse_iterator rbegin()
		{
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{
		return (const_reverse_iterator(begin()));
		}

	reference at(size_type _Off)
		{
		if (_Mysize <= _Off)
			_String_base::_Xran();
		return (_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{
		if (_Mysize <= _Off)
			_String_base::_Xran();
		return (_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{
		return (_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{
		return (_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{
		insert(end(), _Ch);
		}

	const _Elem *c_str() const
		{
		return (_Myptr());
		}

	const _Elem *data() const
		{
		return (c_str());
		}

	size_type length() const
		{
		return (_Mysize);
		}

	size_type size() const
		{
		return (_Mysize);
		}

	size_type max_size() const
		{
		size_type _Num = _Mybase::_Alval.max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{
		if (_Newsize <= _Mysize)
			erase(_Newsize);
		else
			append(_Newsize - _Mysize, _Ch);
		}

	size_type capacity() const
		{
		return (_Myres);
		}

	void reserve(size_type _Newcap = 0)
		{
		if (_Myres < _Newcap)
			_Grow(_Newcap);
		}

	bool empty() const
		{
		return (_Mysize == 0);
		}

	size_type copy(_Elem *_Ptr, size_type _Count, size_type _Off = 0) const
		{
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;
		_Traits::copy(_Ptr, _Myptr() + _Off, _Count);
		return (_Count);
		}

	void swap(_Myt& _Right)
		{
		if (_Mybase::_Alval == _Right._Alval)
			{
			_Bxty _Tbx = _Bx;
			_Bx = _Right._Bx, _Right._Bx = _Tbx;

			size_type _Tlen = _Mysize;
			_Mysize = _Right._Mysize, _Right._Mysize = _Tlen;

			size_type _Tres = _Myres;
			_Myres = _Right._Myres, _Right._Myres = _Tres;
			}
		else
			{
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const
		{
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (_Count == 0 && _Off <= _Mysize)
			return (_Off);

		size_type _Nm;
		if (_Off < _Mysize && _Count <= (_Nm = _Mysize - _Off))
			{
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());
			}

		return (npos);
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const
		{
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (_Count == 0)
			return (_Off < _Mysize ? _Off : _Mysize);
		if (_Count <= _Mysize)
			{
			const _Elem *_Uptr = _Myptr() +
				(_Off < _Mysize - _Count ? _Off : _Mysize - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());
				else if (_Uptr == _Myptr())
					break;
			}

		return (npos);
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const
		{
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (0 < _Count && _Off < _Mysize)
			{
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());
			}

		return (npos);
		}

	size_type find_first_of(const _Elem *_Ptr, size_type _Off = 0) const
		{
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch, size_type _Off = 0) const
		{
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const
		{
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (0 < _Count && 0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());
				else if (_Uptr == _Myptr())
					break;

		return (npos);
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch, size_type _Off = npos) const
		{
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const
		{
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (_Off < _Mysize)
			{
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch, size_type _Off = 0) const
		{
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const
		{
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr, size_type _Off,
		size_type _Count) const
		{
		if (0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
				else if (_Uptr == _Myptr())
					break;
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch, size_type _Off = npos) const
		{
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{
		return (_Myt(*this, _Off, _Count));
		}

	int compare(const _Myt& _Right) const
		{
		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off, size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count) const
		{
		if (_Right.size() < _Roff)
			_String_base::_Xran();
		if (_Right._Mysize - _Roff < _Count)
			_Count = _Right._Mysize - _Roff;
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{
		return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr,
		size_type _Count) const
		{
		if (_Mysize < _Off)
			_String_base::_Xran();
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;

		size_type _Ans = _N0 == 0 ? 0
			: _Traits::compare(_Myptr() + _Off, _Ptr,
				_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const
		{
		return (_Mybase::_Alval);
		}

	enum
		{
		_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1
			: 16 / sizeof(_Elem)};
private:
	enum
		{
		_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15
			: sizeof (_Elem) <= 2 ? 7
			: sizeof (_Elem) <= 4 ? 3
			: sizeof (_Elem) <= 8 ? 1 : 0};

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{
		size_type _Newres = _Newsize | _ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;
		_Elem *_Ptr;

		try {
			_Ptr = _Mybase::_Alval.allocate(_Newres + 1, (void *)0);
		} catch (...) {
			_Newres = _Newsize;
			try {
				_Ptr = _Mybase::_Alval.allocate(_Newres + 1, (void *)0);
			} catch (...) {
			_Tidy(true);
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, _Myptr(), _Oldlen);
		_Tidy(true);
		_Bx._Ptr = _Ptr;
		_Myres = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{
		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize, bool _Trim = false)
		{
		if (max_size() < _Newsize)
			_String_base::_Xlen();
		if (_Myres < _Newsize)
			_Copy(_Newsize, _Trim ? 0 : _Mysize);
		else if (_Trim && _Newsize < _BUF_SIZE)
			_Tidy(true);
		else if (_Newsize == 0)
			_Eos(0);
		return (0 < _Newsize);
		}

	bool _Inside(const _Elem *_Ptr)
		{
		return (_Myptr() <= _Ptr && _Ptr < _Myptr() + _Mysize);
		}

	static size_type __cdecl _Pdif(const_iterator _P2,
		const_iterator _P1)
		{
		return (_P2.base() == 0 ? 0 : _P2 - _P1);
		}

	_Elem *_Myptr()
		{
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	const _Elem *_Myptr() const
		{
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	void _Tidy(bool _Built = false)
		{
		if (!_Built)
			;
		else if (_BUF_SIZE <= _Myres)
			_Mybase::_Alval.deallocate(_Myptr(), _Myres + 1);
		_Myres = _BUF_SIZE - 1;
		_Eos(0);
		}

	union _Bxty
		{
		_Elem _Buf[_BUF_SIZE];
		_Elem *_Ptr;
		} _Bx;

	size_type _Mysize;
	size_type _Myres;
	};


template<class _Elem,
	class _Traits,
	class _Alloc>
	const  basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstring;







}
 #pragma warning(default: 4251)
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


class logic_error
	: public exception
	{
public:
	explicit logic_error(const string& _Message)
		: _Str(_Message)
		{
		}

	virtual ~logic_error()
		{
		}

	virtual const char *what() const throw ()
		{
		return (_Str.c_str());
		}









private:
	string _Str;
	};


class domain_error
	: public logic_error
	{
public:
	explicit domain_error(const string& _Message)
		: logic_error(_Message)
		{
		}

	virtual ~domain_error()
		{
		}








	};


class invalid_argument
	: public logic_error
	{
public:
	explicit invalid_argument(const string& _Message)
		: logic_error(_Message)
		{
		}

	virtual ~invalid_argument()
		{
		}








	};


class length_error
	: public logic_error
	{
public:
	explicit length_error(const string& _Message)
		: logic_error(_Message)
		{
		}

	virtual ~length_error()
		{
		}








	};


class out_of_range
	: public logic_error
	{
public:
	explicit out_of_range(const string& _Message)
		: logic_error(_Message)
		{
		}

	virtual ~out_of_range()
		{
		}








	};


class runtime_error
	: public exception
	{
public:
	explicit runtime_error(const string& _Message)
		: _Str(_Message)
		{
		}

	virtual ~runtime_error()
		{
		}

	virtual const char *what() const throw ()
		{
		return (_Str.c_str());
		}








private:
	string _Str;
	};


class overflow_error
	: public runtime_error
	{
public:
	explicit overflow_error(const string& _Message)
		: runtime_error(_Message)
		{
		}

	virtual ~overflow_error()
		{
		}








	};


class underflow_error
	: public runtime_error
	{
public:
	explicit underflow_error(const string& _Message)
		: runtime_error(_Message)
		{
		}

	virtual ~underflow_error()
		{
		}








	};


class range_error
	: public runtime_error
	{
public:
	explicit range_error(const string& _Message)
		: runtime_error(_Message)
		{
		}

	virtual ~range_error()
		{
		}








	};
}
#pragma warning(pop)
#pragma pack(pop)
























#pragma once





























#pragma once
























class type_info {
public:
     virtual ~type_info();
     int operator==(const type_info& rhs) const;
     int operator!=(const type_info& rhs) const;
     int before(const type_info& rhs) const;
     const char* name() const;
     const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


















#pragma once


















class  bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class  bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class  __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};












 namespace std {

using ::type_info;
using ::bad_cast;
using ::bad_typeid;
using ::__non_rtti_object;






















































 }












#pragma once




#pragma once

















#pragma once











extern "C" {





































 extern const unsigned short _ctype[];
 extern const unsigned short _wctype[];
 extern const unsigned short *_pctype;
 extern const wctype_t *_pwctype;

























 int __cdecl _isctype(int, int);
 int __cdecl isalpha(int);
 int __cdecl isupper(int);
 int __cdecl islower(int);
 int __cdecl isdigit(int);
 int __cdecl isxdigit(int);
 int __cdecl isspace(int);
 int __cdecl ispunct(int);
 int __cdecl isalnum(int);
 int __cdecl isprint(int);
 int __cdecl isgraph(int);
 int __cdecl iscntrl(int);
 int __cdecl toupper(int);
 int __cdecl tolower(int);
 int __cdecl _tolower(int);
 int __cdecl _toupper(int);
 int __cdecl __isascii(int);
 int __cdecl __toascii(int);
 int __cdecl __iscsymf(int);
 int __cdecl __iscsym(int);


















































































































































































}




















#pragma once















#pragma pack(push,8)



extern "C" {



















































struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };














 char * __cdecl setlocale(int, const char *);
 struct lconv * __cdecl localeconv(void);











}



#pragma pack(pop)









































typedef struct _Collvec
	{
	unsigned long _Hand;
	unsigned int _Page;
	} _Collvec;

typedef struct _Ctypevec
	{
	unsigned long _Hand;
	unsigned int _Page;
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{
	unsigned long _Hand;
	unsigned int _Page;
	} _Cvtvec;


extern "C" {
 _Collvec __cdecl _Getcoll();
 _Ctypevec __cdecl _Getctype();
 _Cvtvec __cdecl _Getcvt();

 int __cdecl _Getdateorder();
 char *__cdecl _Getdays();
 char *__cdecl _Getmonths();
 void *__cdecl _Gettnames();

 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 float __cdecl _Stof(const char *, char **, long);
 double __cdecl _Stod(const char *, char **, long);
 long double __cdecl _Stold(const char *, char **, long);
 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
 size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
 int __cdecl _Tolower(int, const _Ctypevec *);
 int __cdecl _Toupper(int, const _Ctypevec *);
 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
}










#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


class  _Timevec
	{
public:
	_Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{
		}

	_Timevec(const _Timevec& _Right)
		{
		*this = _Right;
		}

	~_Timevec()
		{
		free(_Timeptr);
		}

	_Timevec& operator=(const _Timevec& _Right)
		{
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void *_Getptr() const
		{
		return (_Timeptr);
		}

private:
	void *_Timeptr;
	};


class  _Locinfo
	{
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef std::_Timevec _Timevec;

	_Locinfo(const char * = "C");

	_Locinfo(int, const char *);

	~_Locinfo();

	_Locinfo& _Addcats(int, const char *);

	string _Getname() const
		{
		return (_Newlocname);
		}

	_Collvec _Getcoll() const
		{
		return (::_Getcoll());
		}

	_Ctypevec _Getctype() const
		{
		return (::_Getctype());
		}

	_Cvtvec _Getcvt() const
		{
		return (::_Getcvt());
		}

	const lconv *_Getlconv() const
		{
		return (localeconv());
		}

	_Timevec _Gettnames() const
		{
		return (_Timevec(::_Gettnames()));
		}

	const char *_Getdays() const
		{
		const char *_Ptr = ::_Getdays();
		if (_Ptr != 0)
			{
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (_Days.size() != 0 ? _Days.c_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char *_Getmonths() const
		{
		const char *_Ptr = ::_Getmonths();
		if (_Ptr != 0)
			{
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (_Months.size() != 0 ? _Months.c_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char *_Getfalse() const
		{
		return ("false");
		}

	const char *_Gettrue() const
		{
		return ("true");
		}

	int _Getdateorder() const
		{
		return ::_Getdateorder();
		}

private:
	_Lockit _Lock;
	string _Days;
	string _Months;
	string _Oldlocname;
	string _Newlocname;
	};


template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);
		else if (*_First2 < *_First1)
			return (+1);
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}


template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		memcpy(_First1, _First2, _Count * sizeof (_Elem));
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm(char *_First1, char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm(wchar_t *_First1, wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
#pragma warning(pop)
#pragma pack(pop)










#pragma once



#pragma pack(push,8)
#pragma warning(push,3)





























































































































#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)

namespace std {


template<class _Dummy>
	class _Locbase
	{
public:
	static const int collate = ((1 << (1)) >> 1);
	static const int ctype = ((1 << (2)) >> 1);
	static const int monetary = ((1 << (3)) >> 1);
	static const int numeric = ((1 << (4)) >> 1);
	static const int time = ((1 << (5)) >> 1);
	static const int messages = ((1 << (6)) >> 1);
	static const int all = (((1 << (7)) >> 1) - 1);
	static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;


class  locale
	: public _Locbase<int>
	{
public:
	typedef int category;


	class  id
		{
	public:
		id(size_t _Val = 0)
			: _Id(_Val)
			{
			}

		operator size_t()
			{
			if (_Id == 0)
				{
				_Lockit _Lock(0);
				if (_Id == 0)
					_Id = ++_Id_cnt;
				}
			return (_Id);
			}

	private:
		id(const id&);
		id& operator=(const id&);

		size_t _Id;
		static int _Id_cnt;
		};

	class _Locimp;


	class  facet
		{
		friend class locale;
		friend class _Locimp;

	public:
		static size_t __cdecl _Getcat(const facet ** = 0)
			{
			return ((size_t)(-1));
			}

		void _Incref()
			{
			_Lockit _Lock(0);

			if (_Refs < (size_t)(-1))
				++_Refs;
			}

		facet *_Decref()
			{
			_Lockit _Lock(0);

			if (0 < _Refs && _Refs < (size_t)(-1))
				--_Refs;
			return (_Refs == 0 ? this : 0);
			}

		void _Register();


		virtual ~facet()
			{
			}

	protected:
		explicit facet(size_t _Initrefs = 0)
			: _Refs(_Initrefs)
			{
			}

	private:
		facet(const facet&);
		facet& operator=(const facet&);

		size_t _Refs;
		};


	class _Locimp
		: public facet
		{
	protected:
		~_Locimp();

	private:
		friend class locale;

		_Locimp(bool _Transparent = false);

		 _Locimp(const _Locimp&);

		 void _Addfac(facet *, size_t);

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);

		facet **_Facetvec;
		size_t _Facetcount;
		category _Catmask;
		bool _Xparent;
		string _Name;
		static  _Locimp *_Clocptr;
		};

	__declspec(deprecated) locale& _Addfac(facet *, size_t,
		size_t);

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{
		const std::collate<_Elem>& _Fac =
			std::use_facet<std::collate<_Elem> >(*this);

		return (_Fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&std::use_facet<_Facet>(_Loc);
		} catch (...) {
			throw runtime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = new _Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		if (_Facet::_Getcat() != (size_t)(-1))
			{
			_Newimp->_Catmask = 0;
			_Newimp->_Name = "*";
			}
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, _Facet *_Facptr)
			: _Ptr(new _Locimp(*_Loc._Ptr))
		{
		if (_Facptr != 0)
			{
			_Ptr->_Addfac(_Facptr, _Facet::id);
			if (_Facet::_Getcat() != (size_t)(-1))
				_Ptr->_Catmask = 0, _Ptr->_Name = "*";
			}
		}


	locale() throw ();

	locale(_Uninitialized)
		{
		}

	locale(const locale& _Right) throw ()
		: _Ptr(_Right._Ptr)
		{
		_Ptr->_Incref();
		}

	locale(const locale&, const locale&,
		category);

	explicit locale(const char *,
		category = all);

	locale(const locale&, const char *,
		category);

	~locale() throw ()
		{
		if (_Ptr != 0)
			delete (_Ptr->_Decref());
		}

	locale& operator=(const locale& _Right) throw ()
		{
		if (_Ptr != _Right._Ptr)
			{
			delete (_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string name() const
		{
		return (_Ptr->_Name);
		}

	const facet *_Getfacet(size_t) const;

	bool operator==(const locale&) const;

	bool operator!=(const locale& _Right) const
		{
		return (!(*this == _Right));
		}

	static const locale& __cdecl classic();

	static locale __cdecl global(const locale&);

	static locale __cdecl empty();

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{
		}

	static _Locimp *__cdecl _Init();

	_Locimp *_Ptr;
	};


template<class _Facet> inline __declspec(deprecated)
	locale _Addfac(locale _Loc, _Facet *_Fac)
		{
		return (_Loc._Addfac(_Fac, _Facet::id, _Facet::_Getcat()));
		}






template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)
	{
	_Lockit _Lock(0);
	static const locale::facet *_Psave;

	size_t _Id = _Facet::id;
	const locale::facet *_Pf = _Loc._Getfacet(_Id);

	if (_Pf != 0)
		;
	else if (_Psave != 0)
		_Pf = _Psave;
	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

		throw bad_cast();



	else
		{
		_Pf = _Psave;

		locale::facet *_Pfmod = (_Facet *)_Psave;
		_Pfmod->_Incref();
		_Pfmod->_Register();
		}

	return ((const _Facet&)(*_Pf));
	}

template<class _Facet> inline __declspec(deprecated)
	const _Facet& __cdecl use_facet(const locale& _Loc, const _Facet *,
		bool = false)
	{
	return use_facet<_Facet>(_Loc);
	}




template<class _Elem> inline
	char _Narrow(_Elem _Ch)
	{
	return ((char)_Ch);
	}

template<> inline
	char _Narrow(wchar_t _Ch)
	{
	return ((char)wctob(_Ch));
	}




template<class _Elem> inline
	_Elem _Widen(char _Ch, _Elem *)
	{
	return ((_Elem)(unsigned char)_Ch);
	}

template<> inline
	wchar_t _Widen(char _Ch, wchar_t *)
	{
	return (btowc(_Ch));
	}


template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;
	string _Str(_Numfields, '\0');

	int _Ans = -2;
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{
		bool  _Prefix = false;
		size_t _Off = 0;
		size_t _Field = 0;

		for (; _Field < _Numfields; ++_Field)
			{
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);
				_Ans = (int)_Field;
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);
			else
				_Prefix = true;
			}

		if (!_Prefix || _First == _Last)
			break;
		}
	return (_Ans);
	}





template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec &)
	{
	size_t _Count = ::strlen(_Ptr) + 1;
	_Elem *_Ptrdest = new _Elem[_Count];

	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = _Widen(*_Ptr, (_Elem *)0);
	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec &_Cvt)
	{
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	wchar_t *_Ptrdest, *_Ptrnext;

	mbstate_t _Mbst1 = {0};
	_Count = _Count1 = ::strlen(_Ptr) + 1;
	for (_Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; ++_Wchars)
		{
		int _Bytes;
		if ((_Bytes = _Mbrtowc(0, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
		_Ptr1 += _Bytes;
		_Count -= _Bytes;
		}
	++_Wchars;

	_Ptrdest = new wchar_t[_Wchars];
	mbstate_t _Mbst2 = {0};
	for (_Ptrnext = _Ptrdest; 0 < _Wchars; --_Wchars, ++_Ptrnext)
		{
		int _Bytes;
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
		_Ptr += _Bytes;
		_Count1 -= _Bytes;
		}
	*_Ptrnext = 0;
	return (_Ptrdest);
	}


class  codecvt_base
	: public locale::facet
	{
public:
	enum
		{
		ok, partial, error, noconv};
	typedef int result;

	codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		}

	bool always_noconv() const throw ()
		{
		return (do_always_noconv());
		}

	int max_length() const throw ()
		{
		return (do_max_length());
		}

	int encoding() const throw ()
		{
		return (do_encoding());
		}

	~codecvt_base()
		{
		}

protected:
	virtual bool do_always_noconv() const throw ()
		{
		return (true);
		}

	virtual int do_max_length() const throw ()
		{
		return (1);
		}

	virtual int do_encoding() const throw ()
		{
		return (1);
		}
	};


template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const throw ()
		{
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static locale::id id;

	explicit codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{
		_Init(_Locinfo());
		}

	codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>;
		return (2);
		}

protected:
	virtual ~codecvt()
		{
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		_Cvt = _Lobj._Getcvt();
		}

	virtual result do_in(_Statype&,
		const _Byte *_First1, const _Byte *, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *, _Elem *& _Mid2) const
		{
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);
		}

	virtual result do_out(_Statype&,
		const _Elem *_First1, const _Elem *, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);
		}

	virtual result do_unshift(_Statype&,
		_Byte *, _Byte *, _Byte *&) const
		{
		return (noconv);
		}

	virtual int do_length(const _Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const throw ()
		{
		return (int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1);
		}

private:
	_Locinfo::_Cvtvec _Cvt;
	};


template<class _Elem,
	class _Byte,
	class _Statype>
	locale::id codecvt<_Elem, _Byte, _Statype>::id;


template<> class  codecvt<wchar_t, char, mbstate_t>
	: public codecvt_base
	{
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef mbstate_t _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _N2) const throw ()
		{
		return (do_length(_State, _First1, _Last1, _N2));
		}

	static locale::id id;

	explicit codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{
		_Init(_Locinfo());
		}

	codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>;
		return (2);
		}

protected:
	virtual ~codecvt()
		{
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		_Cvt = _Lobj._Getcvt();
		}

	virtual result do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{
			case -2:
				_Mid1 = _Last1;
				return (_Ans);

			case -1:
				return (error);

			case 0:
				_Bytes = (int)::strlen(_Mid1) + 1;


			default:
				_Mid1 += _Bytes, ++_Mid2, _Ans = ok;
			}
		return (_Ans);
		}

	virtual result do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if (___mb_cur_max_func() <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) <= 0)
					return (error);
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) <= 0)
					return (error);
				else if (_Last2 - _Mid2 < _Bytes)
					{
					_State = _Stsave;
					return (_Ans);
					}
				else
					{
					memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;
		else if (_Last2 - _Mid2 < --_Bytes)
			{
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{
			memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int do_length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const throw ()
		{
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{
			case -2:
				return (_Wchars);

			case -1:
				return (_Wchars);

			case 0:
				_Bytes = (int)::strlen(_Mid1) + 1;


			default:
				_Mid1 += _Bytes, ++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool do_always_noconv() const throw ()
		{
		return (false);
		}

	virtual int do_max_length() const throw ()
		{
		return (5);
		}

	virtual int do_encoding() const throw ()
		{
		return (0);
		}

private:
	_Locinfo::_Cvtvec _Cvt;
	};


template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{
public:
	explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{
		}

protected:
	virtual ~codecvt_byname()
		{
		}
	};


struct  ctype_base
	: public locale::facet
	{
	enum
		{
		alnum = 0x4|0x2|0x1|0x100, alpha = 0x2|0x1|0x100,
		cntrl = 0x20, digit = 0x4, graph = 0x4|0x2|0x10|0x1|0x100,
		lower = 0x2, print = 0x4|0x2|0x10|0x40|0x1|0x100|0x80,
		punct = 0x10, space = 0x8|0x40|0x000, upper = 0x1,
		xdigit = 0x80};
	typedef short mask;

	ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		}

	~ctype_base()
		{
		}
	};


template<class _Elem>
	class ctype
		: public ctype_base
	{
public:
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem tolower(_Elem _Ch) const
		{
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{
		return (do_widen(_Byte));
		}

	const char *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		return (do_widen(_First, _Last, _Dest));
		}

	char narrow(_Elem _Ch, char _Dflt = '\0') const
		{
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;

	explicit ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Locinfo());
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>;
		return (2);
		}

protected:
	virtual ~ctype()
		{
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		_Ctype = _Lobj._Getctype();
		}

	virtual bool do_is(mask _Maskval, _Elem _Ch) const
		{
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem do_tolower(_Elem _Ch) const
		{
		return (widen((char)_Tolower((unsigned char)narrow(_Ch),
			&_Ctype)));
		}

	virtual const _Elem *do_tolower(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = widen((char)_Tolower((unsigned char)narrow(*_First),
				&_Ctype));
		return ((const _Elem *)_First);
		}

	virtual _Elem do_toupper(_Elem _Ch) const
		{
		return (widen((char)_Toupper((unsigned char)narrow(_Ch),
			&_Ctype)));
		}

	virtual const _Elem *do_toupper(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = widen((char)_Toupper((unsigned char)narrow(*_First),
				&_Ctype));
		return ((const _Elem *)_First);
		}

	virtual _Elem do_widen(char _Byte) const
		{
		return (_Widen(_Byte, (_Elem *)0));
		}

	virtual const char *do_widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Widen(*_First, (_Elem *)0);
		return (_First);
		}

	virtual char do_narrow(_Elem _Ch, char) const
		{
		return (_Narrow(static_cast<_Elem>(_Ch)));
		}

	virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last,
		char, char *_Dest) const
		{
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Narrow(static_cast<_Elem>(*_First));
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;
	};


template<class _Elem>
	locale::id ctype<_Elem>::id;


template<> class  ctype<char>
	: public ctype_base
	{
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem *is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem *scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem *scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem tolower(_Elem _Ch) const
		{
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{
		return (do_widen(_Byte));
		}

	const _Elem *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem narrow(_Elem _Ch, char _Dflt = '\0') const
		{
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;

	explicit ctype(const mask *_Table = 0, bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Locinfo());
		if (_Table != 0)
			{
			_Tidy();
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>;
		return (2);
		}

	static const size_t table_size;

protected:
	virtual ~ctype()
		{
		_Tidy();
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		_Ctype = _Lobj._Getctype();
		}

	void _Tidy()
		{
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;
		}

	virtual _Elem do_tolower(_Elem _Ch) const
		{
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *do_tolower(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem do_toupper(_Elem _Ch) const
		{
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *do_toupper(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem do_widen(char _Byte) const
		{
		return (_Byte);
		}

	virtual const _Elem *do_widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem do_narrow(_Elem _Ch, char) const
		{
		return (_Ch);
		}

	virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last,
		char, char *_Dest) const
		{
		memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	const mask *table() const throw ()
		{
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() throw ()
		{
		const _Myt& _Fac = use_facet<_Myt >(locale::classic());
		return (_Fac.table());
		}

private:
	_Locinfo::_Ctypevec _Ctype;
	};


template<> class  ctype<wchar_t>
	: public ctype_base
	{
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem tolower(_Elem _Ch) const
		{
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{
		return (do_widen(_Byte));
		}

	const char *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		return (do_widen(_First, _Last, _Dest));
		}

	char narrow(_Elem _Ch, char _Dflt = '\0') const
		{
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;

	explicit ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Locinfo());
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>;
		return (2);
		}

protected:
	virtual ~ctype()
		{
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool do_is(mask _Maskval, _Elem _Ch) const
		{
		return ((_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{
		return (_Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem do_tolower(_Elem _Ch) const
		{
		return (widen((char)_Tolower((unsigned char)narrow(_Ch),
			&_Ctype)));
		}

	virtual const _Elem *do_tolower(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = widen((char)_Tolower((unsigned char)narrow(*_First),
				&_Ctype));
		return ((const _Elem *)_First);
		}

	virtual _Elem do_toupper(_Elem _Ch) const
		{
		return (widen((char)_Toupper((unsigned char)narrow(_Ch),
			&_Ctype)));
		}

	virtual const _Elem *do_toupper(_Elem *_First, const _Elem *_Last) const
		{
		for (; _First != _Last; ++_First)
			*_First = widen((char)_Toupper((unsigned char)narrow(*_First),
				&_Ctype));
		return ((const _Elem *)_First);
		}

	virtual _Elem do_widen(char _Byte) const
		{
		mbstate_t _Mbst = {0};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) <= 0
			? (wchar_t)(unsigned char)_Byte : _Wc);
		}

	virtual const char *do_widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{
		mbstate_t _Mbst = {0};
		while (_First != _Last)
			{
			int _Bytes;

			switch (_Bytes = _Mbrtowc(_Dest, _First, _Last - _First,
				&_Mbst, &_Cvt))
				{
			case -2:
			case -1:
				return (_First);

			case 0:
				_Bytes = (int)::strlen(_First) + 1;


			default:
				_First += _Bytes, ++_Dest;
				}
			}
		return (_First);
		}

	virtual char do_narrow(_Elem _Ch, char _Dflt) const
		{
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{
		mbstate_t _Mbst = {0};
		for (; _First != _Last; ++_First)
			{
			int _Bytes;
			if ((_Bytes = _Wcrtomb(_Dest, *_First, &_Mbst, &_Cvt)) <= 0)
				{
				_Bytes = 1;
				*_Dest = _Dflt;
				}
			_Dest += _Bytes;
			}
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;
	_Locinfo::_Cvtvec _Cvt;
	};


template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{
public:
	explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{
		}

protected:
	virtual ~ctype_byname()
		{
		}
	};




}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Dummy>
	class _Iosb
	{
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};
	enum _Fmtflags
		{
		_Fmtmask = 0x7fff, _Fmtzero = 0};
	typedef int fmtflags;

	static const _Fmtflags skipws = (_Fmtflags)0x0001;
	static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static const _Fmtflags uppercase = (_Fmtflags)0x0004;
	static const _Fmtflags showbase = (_Fmtflags)0x0008;
	static const _Fmtflags showpoint = (_Fmtflags)0x0010;
	static const _Fmtflags showpos = (_Fmtflags)0x0020;
	static const _Fmtflags left = (_Fmtflags)0x0040;
	static const _Fmtflags right = (_Fmtflags)0x0080;
	static const _Fmtflags internal = (_Fmtflags)0x0100;
	static const _Fmtflags dec = (_Fmtflags)0x0200;
	static const _Fmtflags oct = (_Fmtflags)0x0400;
	static const _Fmtflags hex = (_Fmtflags)0x0800;
	static const _Fmtflags scientific = (_Fmtflags)0x1000;
	static const _Fmtflags fixed = (_Fmtflags)0x2000;
	static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static const _Fmtflags adjustfield = (_Fmtflags)0x01c0;
	static const _Fmtflags basefield = (_Fmtflags)0x0e00;
	static const _Fmtflags floatfield = (_Fmtflags)0x3000;

	enum _Iostate
		{
		_Statmask = 0x7};
	typedef int iostate;

	static const _Iostate goodbit = (_Iostate)0x0;
	static const _Iostate eofbit = (_Iostate)0x1;
	static const _Iostate failbit = (_Iostate)0x2;
	static const _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{
		_Openmask = 0x3f};
	typedef int openmode;

	static const _Openmode in = (_Openmode)0x01;
	static const _Openmode out = (_Openmode)0x02;
	static const _Openmode ate = (_Openmode)0x04;
	static const _Openmode app = (_Openmode)0x08;
	static const _Openmode trunc = (_Openmode)0x10;
	static const _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{
		_Seekmask = 0x3};
	typedef int seekdir;

	static const _Seekdir beg = (_Seekdir)0;
	static const _Seekdir cur = (_Seekdir)1;
	static const _Seekdir end = (_Seekdir)2;
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;


class  ios_base
	: public _Iosb<int>
	{
public:

	typedef std::streamoff streamoff;
	typedef std::streampos streampos;

	enum event
		{
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;


	class failure
		: public runtime_error
		{
	public:
		explicit failure(const string &_Message)
			: runtime_error(_Message)
			{
			}

		virtual ~failure()
			{
			}

	protected:
		virtual void _Doraise() const
			{
			throw (*this);
			}
	};


	class  Init
		{
	public:
		Init();

		~Init();

	private:
		static int _Init_cnt;
		};

	ios_base& operator=(const ios_base& _Right)
		{
		if (this != &_Right)
			{
			_Mystate = _Right._Mystate;
			copyfmt(_Right);
			}
		return (*this);
		}

	operator void *() const
		{
		return (fail() ? 0 : (void *)this);
		}

	bool operator!() const
		{
		return (fail());
		}

	void clear(iostate, bool);

	void clear(iostate _State = goodbit)
		{
		clear(_State, false);
		}

	void clear(io_state _State)
		{
		clear((iostate)_State);
		}

	iostate rdstate() const
		{
		return (_Mystate);
		}

	void setstate(iostate _State, bool _Exreraise)
		{
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void setstate(iostate _State)
		{
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void setstate(io_state _State)
		{
		setstate((iostate)_State);
		}

	bool good() const
		{
		return (rdstate() == goodbit);
		}

	bool eof() const
		{
		return ((int)rdstate() & (int)eofbit);
		}

	bool fail() const
		{
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool bad() const
		{
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate exceptions() const
		{
		return (_Except);
		}

	void exceptions(iostate _Newexcept)
		{
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void exceptions(io_state _State)
		{
		exceptions((iostate)_State);
		}

	fmtflags flags() const
		{
		return (_Fmtfl);
		}

	fmtflags flags(fmtflags _Newfmtflags)
		{
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags setf(fmtflags _Newfmtflags)
		{
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| (int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void unsetf(fmtflags _Mask)
		{
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize precision() const
		{
		return (_Prec);
		}

	streamsize precision(streamsize _Newprecision)
		{
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize width() const
		{
		return (_Wide);
		}

	streamsize width(streamsize _Newwidth)
		{
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale getloc() const
		{
		return (*_Ploc);
		}

	locale imbue(const locale&);

	static int __cdecl xalloc()
		{
		_Lockit _Lock(2);
		return (_Index++);
		}

	long& iword(int _Idx)
		{
		return (_Findarr(_Idx)._Lo);
		}

	void *& pword(int _Idx)
		{
		return (_Findarr(_Idx)._Vp);
		}

	void register_callback(event_callback, int);

	ios_base& copyfmt(const ios_base&);

	virtual ~ios_base();

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{
		_Lockit _Lock(2);
		const bool _Oldsync = _Sync;
		_Sync = _Newsync;
		return (_Oldsync);
		}

	void _Addstd();

protected:
	ios_base()
		: _Stdstr(0)
		{
		}

	void _Init();

private:

	struct _Iosarray
		{
	public:
		_Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{
			}

		_Iosarray *_Next;
		int _Index;
		long _Lo;
		void *_Vp;
		};


	struct _Fnarray
		{
		_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{
			}

		_Fnarray *_Next;
		int _Index;
		event_callback _Pfn;
		};

	void _Callfns(event);

	_Iosarray& _Findarr(int);

	void _Tidy();

	iostate _Mystate;
	iostate _Except;
	fmtflags _Fmtfl;
	streamsize _Prec;
	streamsize _Wide;
	_Iosarray *_Arr;
	_Fnarray *_Calls;
	locale *_Ploc;
	size_t _Stdstr;

	static int _Index;
	static bool _Sync;
	};





}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Elem, class _Traits>
	class basic_streambuf
	{
	basic_streambuf(const basic_streambuf<_Elem, _Traits>&);
	basic_streambuf<_Elem, _Traits>&
		operator=(const basic_streambuf<_Elem, _Traits>&);

protected:
	basic_streambuf()
		: _Plocale(new locale)
		{
		_Init();
		}

	basic_streambuf(_Uninitialized)
		{
		}

public:
	typedef basic_streambuf<_Elem, _Traits> _Myt;
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual ~basic_streambuf()
		{
		delete (_Plocale);
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{
		return (seekpos(_Pos, _Mode));
		}

	pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
		{
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt *pubsetbuf(_Elem *_Buffer, streamsize _Count)
		{
		return (setbuf(_Buffer, _Count));
		}

	locale pubimbue(const locale &_Newlocale)
		{
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale getloc() const
		{
		return (*_Plocale);
		}

	streamsize in_avail()
		{
		return (gptr() != 0 && gptr() < egptr()
			? (streamsize)(egptr() - gptr()) : showmanyc());
		}

	int pubsync()
		{
		return (sync());
		}

	int_type sbumpc()
		{
		return (gptr() != 0 && gptr() < egptr()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type sgetc()
		{
		return (gptr() != 0 && gptr() < egptr()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize sgetn(_Elem *_Ptr, streamsize _Count)
		{
		return (xsgetn(_Ptr, _Count));
		}

	int_type snextc()
		{
		return (_Traits::eq_int_type(_Traits::eof(), sbumpc())
			? _Traits::eof() : sgetc());
		}

	int_type sputbackc(_Elem _Ch)
		{
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void stossc()
		{
		if (gptr() != 0 && gptr() < egptr())
			_Gninc();
		else
			uflow();
		}

	int_type sungetc()
		{
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type sputc(_Elem _Ch)
		{
		return (pptr() != 0 && pptr() < epptr()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize sputn(const _Elem *_Ptr, streamsize _Count)
		{
		return (xsputn(_Ptr, _Count));
		}

	void _Lock()
		{
		_Mylock._Lock();
		}

	void _Unlock()
		{
		_Mylock._Unlock();
		}

protected:
	_Elem *eback() const
		{
		return (*_IGfirst);
		}

	_Elem *gptr() const
		{
		return (*_IGnext);
		}

	_Elem *pbase() const
		{
		return (*_IPfirst);
		}

	_Elem *pptr() const
		{
		return (*_IPnext);
		}

	_Elem *egptr() const
		{
		return (*_IGnext + *_IGcount);
		}

	void gbump(int _Off)
		{
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem *epptr() const
		{
		return (*_IPnext + *_IPcount);
		}

	_Elem *_Gndec()
		{
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem *_Gninc()
		{
		--*_IGcount;
		return ((*_IGnext)++);
		}

	void pbump(int _Off)
		{
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void setp(_Elem *_First, _Elem *_Last)
		{
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem *_Pninc()
		{
		--*_IPcount;
		return ((*_IPnext)++);
		}

	void _Init()
		{
		_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;
		_IGnext = &_Gnext, _IPnext = &_Pnext;
		_IGcount = &_Gcount, _IPcount = &_Pcount;
		setp(0, 0), setg(0, 0, 0);
		}

	void _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{
		_IGfirst = _Gf, _IPfirst = _Pf;
		_IGnext = _Gn, _IPnext = _Pn;
		_IGcount = _Gc, _IPcount = _Pc;
		}

	virtual int_type overflow(int_type = _Traits::eof())
		{
		return (_Traits::eof());
		}

	virtual int_type pbackfail(int_type = _Traits::eof())
		{
		return (_Traits::eof());
		}

	virtual streamsize showmanyc()
		{
		return (0);
		}

	virtual int_type underflow()
		{
		return (_Traits::eof());
		}

	virtual int_type uflow()
		{
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize xsgetn(_Elem * _Ptr, streamsize _Count)
		{
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (gptr() != 0 && 0 < (_Size = (streamsize)(egptr() - gptr())))
				{
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), _Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;
			else
				{
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize xsputn(const _Elem *_Ptr, streamsize _Count)
		{
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (pptr() != 0 && 0 < (_Size = (streamsize)(epptr() - pptr())))
				{
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, _Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;
			else
				{
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type seekoff(off_type, ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{
		return (streampos(_BADOFF));
		}

	virtual pos_type seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{
		return (streampos(_BADOFF));
		}

	virtual _Myt *setbuf(_Elem *, streamsize)
		{
		return (this);
		}

	virtual int sync()
		{
		return (0);
		}

	virtual void imbue(const locale&)
		{
		}

private:
	_Mutex _Mylock;
	_Elem *_Gfirst;
	_Elem *_Pfirst;
	_Elem **_IGfirst;
	_Elem **_IPfirst;
	_Elem *_Gnext;
	_Elem *_Pnext;
	_Elem **_IGnext;
	_Elem **_IPnext;
	int _Gcount;
	int _Pcount;
	int *_IGcount;
	int *_IPcount;
	locale *_Plocale;
	};





}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)

namespace std {


template<class _Elem>
	class numpunct
		: public locale::facet
	{
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	static locale::id id;

	_Elem decimal_point() const
		{
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{
		return (do_thousands_sep());
		}

	string grouping() const
		{
		return (do_grouping());
		}

	string_type falsename() const
		{
		return (do_falsename());
		}

	string_type truename() const
		{
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Locinfo());
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>;
		return (4);
		}

protected:
	virtual ~numpunct()
		{
		_Tidy();
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{
		const lconv *_Ptr = _Lobj._Getlconv();

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Ptr->grouping, (char *)0, _Lobj._Getcvt());
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Lobj._Getcvt());
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Lobj._Getcvt());
		} catch (...) {
		_Tidy();
		throw;
		}

		_Dp = _Widen(_Ptr->decimal_point[0], (_Elem *)0);
		_Kseparator = _Widen(_Ptr->thousands_sep[0], (_Elem *)0);
		}

	virtual _Elem do_decimal_point() const
		{
		return (_Dp);
		}

	virtual _Elem do_thousands_sep() const
		{
		return (_Kseparator);
		}

	virtual string do_grouping() const
		{
		return (string(_Grouping));
		}

	virtual string_type do_falsename() const
		{
		return (string_type(_Falsename));
		}

	virtual string_type do_truename() const
		{
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{
		delete[] ((void *)_Grouping);
		delete[] ((void *)_Falsename);
		delete[] ((void *)_Truename);
		}

	const char *_Grouping;
	_Elem _Dp;
	_Elem _Kseparator;
	const _Elem *_Falsename;
	const _Elem *_Truename;
	};

typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;


template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locinfo(_Locname), _Refs)
		{
		}

protected:
	virtual ~numpunct_byname()
		{
		}
	};


template<class _Elem>
	locale::id numpunct<_Elem>::id;




template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>;
		return (4);
		}

	static locale::id id;

protected:
	virtual ~num_get()
		{
		}

protected:
	void _Init(const _Locinfo&)
		{
		}

public:
	explicit num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Locinfo());
		}

	num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, _Bool& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned short& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned int& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, long& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned long& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}


	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, __int64& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned __int64& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}


	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, float& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, double& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, long double& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, void *& _Val) const
		{
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, _Bool& _Val) const
		{
		int _Ans = -1;

		if (_Iosbase.flags() & ios_base::boolalpha)
			{
			const _Mypunct& _Fac = use_facet<_Mypunct >(_Iosbase.getloc());
			_Mystr _Str((typename _Mystr::size_type)1, (char_type)0);
			_Str += _Fac.falsename();
			_Str += (char_type)0;
			_Str += _Fac.truename();
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{
			char _Ac[32], *_Ep;
			errno = 0;
			const unsigned long _Ulo = ::strtoul(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()));
			if (_Ep != _Ac && errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned short& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
		const unsigned long _Ans =
			::strtoul(_Ptr, &_Ep, _Base);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned int& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
		const unsigned long _Ans =
			::strtoul(_Ptr, &_Ep, _Base);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, long& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		const long _Ans = ::strtol(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned long& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		const unsigned long _Ans = ::strtoul(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}


	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, __int64& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		const __int64 _Ans = ::_strtoi64(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, unsigned __int64& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;
		const unsigned __int64 _Ans = ::_strtoui64(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}


	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, float& _Val) const
		{
		char _Ac[8 + 36 + 16], *_Ep;
		errno = 0;
		const float _Ans = ::_Stof(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, double& _Val) const
		{
		char _Ac[8 + 36 + 16], *_Ep;
		errno = 0;
		const double _Ans = ::_Stod(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, long double& _Val) const
		{
		char _Ac[8 + 36 + 16], *_Ep;
		errno = 0;
		const long double _Ans = ::_Stold(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase.getloc()));

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;
		return (_First);
		}

	virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase,
		ios_base::iostate& _State, void *& _Val) const
		{
		char _Ac[32], *_Ep;
		errno = 0;


		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64)::strtoul(_Ac, &_Ep, _Base)
				: ::_strtoui64(_Ac, &_Ep, _Base);







		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);
		return (_First);
		}

private:
	static int __cdecl _Getifld(char *_Ac, _InIt& _First, _InIt& _Last,
		ios_base::fmtflags _Basefield, const locale& _Loc)
		{
		const _Elem _E0 = _Widen('0', (_Elem *)0);
		const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
		const string _Grouping = _Fac.grouping();
		const _Elem _Kseparator = _Fac.thousands_sep();
		char *_Ptr = _Ac;

		if (_First == _Last)
			;
		else if (*_First == _Widen('+', (_Elem *)0))
			*_Ptr++ = '+', ++_First;
		else if (*_First == _Widen('-', (_Elem *)0))
			*_Ptr++ = '-', ++_First;

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;
		bool _Nonzero = false;

		if (_First != _Last && *_First == _E0)
			{
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Widen('x', (_Elem *)0)
					|| *_First == _Widen('X', (_Elem *)0))
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		int _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			if (::memchr("0123456789abcdefABCDEF",
				*_Ptr = _Narrow(static_cast<_Elem>(*_First)), _Dlen) != 0)
				{
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;
			else
				{
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}

		if (_Group == 0)
			;
		else if ('\0' < _Groups[_Group])
			++_Group;
		else
			_Seendigit = false;

		for (const char *_Pg = _Grouping.c_str(); _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;
			else if (0 < --_Group && *_Pg != _Groups[_Group]
				|| 0 == _Group && *_Pg < _Groups[_Group])
				_Seendigit = false;
			else if ('\0' < _Pg[1])
				++_Pg;

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';
		else if (!_Seendigit)
			_Ptr = _Ac;
		*_Ptr = '\0';
		return (_Base);
		}

	static int __cdecl _Getffld(char *_Ac, _InIt& _First, _InIt &_Last,
		const locale& _Loc)
		{
		const _Elem _E0 = _Widen('0', (_Elem *)0);
		const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
		char *_Ptr = _Ac;

		if (_First == _Last)
			;
		else if (*_First == _Widen('+', (_Elem *)0))
			*_Ptr++ = '+', ++_First;
		else if (*_First == _Widen('-', (_Elem *)0))
			*_Ptr++ = '-', ++_First;

		bool _Seendigit = false;
		for (; _First != _Last && *_First == _E0; _Seendigit = true, ++_First)
			;
		if (_Seendigit)
			*_Ptr++ = '0';

		int _Significant = 0;
		int _Pten = 0;

		for (; _First != _Last
			&& (::isdigit)(*_Ptr = _Narrow(static_cast<_Elem>(*_First)));
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				++_Ptr, ++_Significant;
			else
				++_Pten;

		if (_First != _Last && *_First == _Fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;

		if (_Significant == 0)
			{
			for (; _First != _Last && *_First == _E0;
				_Seendigit = true, ++_First)
				--_Pten;
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;
			}

		for (; _First != _Last
			&& (::isdigit)(*_Ptr = _Narrow(static_cast<_Elem>(*_First)));
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				++_Ptr, ++_Significant;

		if (_Seendigit && _First != _Last
			&& (*_First == _Widen('e', (_Elem *)0)
				|| *_First == _Widen('E', (_Elem *)0)))
			{
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;
			else if (*_First == _Widen('+', (_Elem *)0))
				*_Ptr++ = '+', ++_First;
			else if (*_First == _Widen('-', (_Elem *)0))
				*_Ptr++ = '-', ++_First;
			for (; _First != _Last && *_First == _E0; )
				_Seendigit = true, ++_First;
			if (_Seendigit)
				*_Ptr++ = '0';
			for (; _First != _Last
				&& (::isdigit)(*_Ptr = _Narrow(static_cast<_Elem>(*_First)));
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					++_Ptr, ++_Significant;
			}

		if (!_Seendigit)
			_Ptr = _Ac;
		*_Ptr = '\0';
		return (_Pten);
		};
	};


template<class _Elem,
	class _InIt>
	locale::id num_get<_Elem, _InIt>::id;


template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0)
		{
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>;
		return (4);
		}

	static locale::id id;

protected:
	virtual ~num_put()
		{
		}

protected:
	void _Init(const _Locinfo&)
		{
		}

public:
	explicit num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Locinfo());
		}

	num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		_Bool _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		long _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		unsigned long _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}


	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		__int64 _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		unsigned __int64 _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}


	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		double _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		long double _Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		const void *_Val) const
		{
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		_Bool _Val) const
		{
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{
			const _Mypunct& _Fac = use_facet<_Mypunct >(_Iosbase.getloc());
			const _Mystr _Str(_Val ? _Fac.truename() : _Fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
			}
		}

	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		long _Val) const
		{
		char _Buf[2 * 32], _Fmt[6];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf(_Buf, _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		unsigned long _Val) const
		{
		char _Buf[2 * 32], _Fmt[6];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf(_Buf, _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}


	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		__int64 _Val) const
		{
		char _Buf[2 * 32], _Fmt[8];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf(_Buf, _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		unsigned __int64 _Val) const
		{
		char _Buf[2 * 32], _Fmt[8];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf(_Buf, _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}


	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		double _Val) const
		{
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;
		_Precision -= _Significance;
		size_t _Beforepoint = 0;
		size_t _Afterpoint = 0;

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, _Precision,
				::sprintf(_Buf, _Ffmt(_Fmt, 0, _Iosbase.flags()),
					_Significance, _Val)));
		}

	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		long double _Val) const
		{
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;
		_Precision -= _Significance;
		size_t _Beforepoint = 0;
		size_t _Afterpoint = 0;

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, _Precision,
				::sprintf(_Buf, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
					_Significance, _Val)));
		}

	virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		const void *_Val) const
		{
		char _Buf[2 * 32];
		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			::sprintf(_Buf, "%p", _Val)));
		}

	static char *__cdecl _Ffmt(char *_Fmt, char _Spec,
		ios_base::fmtflags _Flags)
		{
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';
		if (_Spec != '\0')
			*_Ptr++ = _Spec;

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
			: _Ffl == ios_base::scientific ? 'e' : 'g';
		*_Ptr = '\0';
		return (_Fmt);
		}

	static _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase,
		_Elem _Fill, const char *_Buf,
			size_t _Beforepoint, size_t _Afterpoint,
				size_t _Trailing, size_t _Count)
		{
		_Elem _E0 = _Widen('0', (_Elem *)0);
		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
		_Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Fillcount
				? 0 : (size_t)_Iosbase.width() - _Fillcount;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else if (_Adjustfield == ios_base::internal)
			{
			if (0 < _Count && (*_Buf == '+' || *_Buf == '-'))
				{
				_Dest = _Putc(_Dest, _Buf, 1);
				++_Buf, --_Count;
				}
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}

		const char *_Ptr = (const char *)::memchr(_Buf,
			localeconv()->decimal_point[0], _Count);
		if (_Ptr != 0)
			{
			const _Mypunct& _Fac = use_facet<_Mypunct >(_Iosbase.getloc());
			size_t _Fracoffset = _Ptr - _Buf + 1;
			_Dest = _Putc(_Dest, _Buf, _Fracoffset - 1);
			_Dest = _Rep(_Dest, _E0, _Beforepoint);
			_Dest = _Rep(_Dest, _Fac.decimal_point(), 1);
			_Dest = _Rep(_Dest, _E0, _Afterpoint);
			_Buf += _Fracoffset, _Count -= _Fracoffset;
			}

		if ((_Ptr = (const char *)::memchr(_Buf, 'e', _Count)) != 0)
			{
			size_t _Expoffset = _Ptr - _Buf + 1;
			_Dest = _Putc(_Dest, _Buf, _Expoffset - 1);
			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;
			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
				? "E" : "e", 1);
			_Buf += _Expoffset, _Count -= _Expoffset;
			}

		_Dest = _Putc(_Dest, _Buf, _Count);
		_Dest = _Rep(_Dest, _E0, _Trailing);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));
		}

	static char *__cdecl _Ifmt(char *_Fmt, const char *_Spec,
		ios_base::fmtflags _Flags)
		{
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];
		else
			{
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	static _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
		char *_Buf, size_t _Count)
		{
		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
			: 0;
		const _Mypunct& _Fac = use_facet<_Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Fac.grouping();
		const _Elem _Kseparator = _Fac.thousands_sep();
		bool _Grouped = '\0' < *_Grouping.c_str();

		if (_Grouped)
			{
			const char *_Pg = _Grouping.c_str();
			size_t _Off = _Count;
			for (_Grouped = false; *_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Off - _Prefix; _Grouped = true)
				{
				_Off -= *_Pg;
				::memmove(&_Buf[_Off + 1], &_Buf[_Off],
					_Count + 1 - _Off);
				_Buf[_Off] = ',', ++_Count;
				if ('\0' < _Pg[1])
					++_Pg;
				}
			}

		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else if (_Adjustfield == ios_base::internal)
			{
			_Dest = _Putc(_Dest, _Buf, _Prefix);
			_Buf += _Prefix, _Count -= _Prefix;
			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;
			}

		if (!_Grouped)
			_Dest = _Putc(_Dest, _Buf, _Count);
		else
			for (; ; ++_Buf, --_Count)
				{
				size_t _Groupsize = strcspn(_Buf, ",");
				_Dest = _Putc(_Dest, _Buf, _Groupsize);
				_Buf += _Groupsize, _Count -= _Groupsize;
				if (_Count == 0)
					break;
				if (_Kseparator != (_Elem)0)
					_Dest = _Rep(_Dest, _Kseparator, 1);
				}

		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));
		}

	static _OutIt __cdecl _Put(_OutIt _Dest, const _Elem *_Ptr, size_t _Count)
		{
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	static _OutIt __cdecl _Putc(_OutIt _Dest, const char *_Ptr, size_t _Count)
		{
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = _Widen(*_Ptr, (_Elem *)0);
		return (_Dest);
		}

	static _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count)
		{
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};


template<class _Elem,
	class _OutIt>
	locale::id num_put<_Elem, _OutIt>::id;













}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit basic_ios(_Mysb *_Strbuf)
		{
		init(_Strbuf);
		}

	virtual ~basic_ios()
		{
		}

	void clear(iostate _State = goodbit, bool _Except = false)
		{
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Except);
		}

	void clear(io_state _State)
		{
		clear((iostate)_State);
		}

	void setstate(iostate _State, bool _Except = false)
		{
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Except);
		}

	void setstate(io_state _State)
		{
		setstate((iostate)_State);
		}

	_Myt& copyfmt(const _Myt& _Right)
		{
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos *tie() const
		{
		return (_Tiestr);
		}

	_Myos *tie(_Myos *_Newtie)
		{
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb *rdbuf() const
		{
		return (_Mystrbuf);
		}

	_Mysb *rdbuf(_Mysb *_Strbuf)
		{
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale imbue(const locale& _Loc)
		{
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem fill() const
		{
		return (_Fillch);
		}

	_Elem fill(_Elem _Newfill)
		{
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char narrow(_Elem _Ch, char _Dflt = '\0') const
		{
		const _Ctype& _Facet = use_facet<_Ctype >(getloc());
		return (_Facet.narrow(_Ch, _Dflt));
		}

	_Elem widen(char _Byte) const
		{
		const _Ctype& _Facet = use_facet<_Ctype >(getloc());
		return (_Facet.widen(_Byte));
		}

protected:
	void init(_Mysb *_Strbuf = 0, bool _Isstd = false)
		{
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = _Widen(' ', (_Elem *)0);
		_Init();

		if (_Mystrbuf == 0)
			setstate(badbit);
		if (_Isstd)
			_Addstd();
		}

	basic_ios()
		{
		}

private:
	basic_ios(const _Myt&);
	_Myt& operator=(const _Myt&);

	_Mysb *_Mystrbuf;
	_Myos *_Tiestr;
	_Elem _Fillch;
	};









inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {





















template<class _Elem, class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit basic_ostream(basic_streambuf<_Elem, _Traits> *_Strbuf,
		bool _Isstd = false)
		{
		_Myios::init(_Strbuf, _Isstd);
		}

	basic_ostream(_Uninitialized)
		{
		ios_base::_Addstd();
		}

	virtual ~basic_ostream()
		{
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{
	public:
		_Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		~_Sentry_base()
			{
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;
		};

	class sentry
		: public _Sentry_base
		{
	public:
		explicit sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{
			if (_Ostr.good() && _Ostr.tie() != 0)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();
			}

		~sentry()
			{

			if (!uncaught_exception())
				_Myostr._Osfx();
			}





		operator bool() const
			{
			return (_Ok);
			}

	private:
		sentry(const sentry&);
		sentry& operator=(const sentry&);

		bool _Ok;
		};

	bool opfx()
		{
		if (ios_base::good() && _Myios::tie() != 0)
			_Myios::tie()->flush();
		return (ios_base::good());
		}

	void osfx()
		{
		_Osfx();
		}

	void _Osfx()
		{
		if (ios_base::flags() & ios_base::unitbuf)
			flush();
		}

	_Myt& operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{
		return ((*_Pfn)(*this));
		}

	_Myt& operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt& operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt& operator<<(_Bool _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(short _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
			ios_base::fmtflags _Bfl =
				ios_base::flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(unsigned short _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(int _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
			ios_base::fmtflags _Bfl =
				ios_base::flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(unsigned int _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(long _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(unsigned long _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}


	_Myt& operator<<(__int64 _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(unsigned __int64 _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}


	_Myt& operator<<(float _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(double _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(long double _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(const void *_Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());

			try {
			if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator<<(_Mysb *_Strbuf)
		{
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		ios_base::width(0);
		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt& put(_Elem _Ch)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& write(const _Elem *_Str, streamsize _Count)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& flush()
		{
		ios_base::iostate _State = ios_base::goodbit;
		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)
			_State |= ios_base::badbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& seekp(pos_type _Pos)
		{
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt& seekp(off_type _Off, ios_base::seekdir _Way)
		{
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type tellp()
		{
		if (!ios_base::fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};








template<class _Elem, class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem, class _Traits> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& __cdecl operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{
	return (_Ostr << (char)_Ch);
	}


template<class _Elem, class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem, class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem, class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{
	_Ostr.flush();
	return (_Ostr);
	}

 inline basic_ostream<char, char_traits<char> >&
	__cdecl endl(basic_ostream<char, char_traits<char> >& _Ostr)
	{
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}

 inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl endl(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}

 inline basic_ostream<char, char_traits<char> >&
	__cdecl ends(basic_ostream<char, char_traits<char> >& _Ostr)
	{
	_Ostr.put('\0');
	return (_Ostr);
	}

 inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl ends(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{
	_Ostr.put('\0');
	return (_Ostr);
	}

 inline basic_ostream<char, char_traits<char> >&
	__cdecl flush(basic_ostream<char, char_traits<char> >& _Ostr)
	{
	_Ostr.flush();
	return (_Ostr);
	}

 inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl flush(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{
	_Ostr.flush();
	return (_Ostr);
	}























}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

	explicit basic_istream(_Mysb *_Strbuf, bool _Isstd = false,
		bool _Noinit = false)
		: _Chcount(0)
		{
		if (!_Noinit)
			_Myios::init(_Strbuf, _Isstd);
		}

	basic_istream(_Uninitialized)
		{
		ios_base::_Addstd();
		}

	virtual ~basic_istream()
		{
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;


	class _Sentry_base
		{
	public:
		_Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		~_Sentry_base()
			{
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;
		};

	class sentry
		: public _Sentry_base
		{
	public:
		explicit sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{
			_Ok = _Myistr._Ipfx(_Noskip);
			}

		operator bool() const
			{
			return (_Ok);
			}

	private:
		sentry(const sentry&);
		sentry& operator=(const sentry&);

		bool _Ok;
		};

	bool _Ipfx(bool _Noskip = false)
		{
		if (ios_base::good())
			{
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && ios_base::flags() & ios_base::skipws)
				{
				const _Ctype& _Facet = use_facet<_Ctype >(ios_base::getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Facet.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (ios_base::good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool ipfx(bool _Noskip = false)
		{
		return _Ipfx(_Noskip);
		}

	void isfx()
		{
		}

	_Myt& operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{
		return ((*_Pfn)(*this));
		}

	_Myt& operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt& operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt& operator>>(_Bool& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(short& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			long _Tmp = 0;
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(unsigned short& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(int& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			long _Tmp = 0;
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(unsigned int& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(long& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());
			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(unsigned long& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}


	_Myt& operator>>(__int64& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(unsigned __int64& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}


	_Myt& operator>>(float& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(double& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(long double& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());
			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(void *& _Val)
		{
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{
			const _Nget& _Facet = use_facet<_Nget >(ios_base::getloc());

			try {
			_Facet.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& operator>>(_Mysb *_Strbuf)
		{
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
					_State |= ios_base::eofbit;
					break;
					}
				else
					{
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type get()
		{
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();
		else
			{
			try {
			_Meta = _Myios::rdbuf()->sbumpc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;
			else
				++_Chcount;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt& get(_Elem *_Str, streamsize _Count)
		{
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt& get(_Elem *_Str, streamsize _Count, _Elem _Delim)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;
				else
					{
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();
		return (*this);
		}

	_Myt& get(_Elem& _Ch)
		{
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt& get(_Mysb& _Strbuf)
		{
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt& get(_Mysb& _Strbuf, _Elem _Delim)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
					_State |= ios_base::eofbit;
					break;
					}
				else
					{
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& getline(_Elem *_Str, streamsize _Count)
		{
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt& getline(_Elem *_Str, streamsize _Count, _Elem _Delim)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{
					_State |= ios_base::failbit;
					break;
					}
				else
					{
					++_Chcount;
					*_Str++ = _Traits::to_char_type(_Meta);
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt& ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof())
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{
			try {
			for (; ; )
				{
				int_type _Meta;
				if (_Count != 2147483647 && --_Count < 0)
					break;
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{
					_State |= ios_base::eofbit;
					break;
					}
				else
					{
					++_Chcount;
					if (_Meta == _Metadelim)
						break;
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& read(_Elem *_Str, streamsize _Count)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{
			try {
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize readsome(_Elem *_Str, streamsize _Count)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;
		else if (0 < _Num)
			read(_Str, _Num < _Count ? _Num : _Count);

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type peek()
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();
		else
			{
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt& putback(_Elem _Ch)
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt& unget()
		{
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize gcount() const
		{
		return (_Chcount);
		}

	int sync()
		{
		ios_base::iostate _State = ios_base::goodbit;
		int _Ans;

		if (_Myios::rdbuf() == 0)
			_Ans = -1;
		else if (_Myios::rdbuf()->pubsync() == -1)
			{
			_State |= ios_base::badbit;
			_Ans = -1;
			}
		else
			_Ans = 0;

		_Myios::setstate(_State);
		return (_Ans);
		}

	_Myt& seekg(pos_type _Pos)
		{
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt& seekg(off_type _Off, ios_base::seekdir _Way)
		{
		if (!ios_base::fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type tellg()
		{
		if (!ios_base::fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;
	};







template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{
public:
	explicit basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: basic_istream<_Elem, _Traits>(_Strbuf, false, true),
			basic_ostream<_Elem, _Traits>(_Strbuf)
		{
		}

	virtual ~basic_iostream()
		{
		}
	};







template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{
		const _Ctype& _Facet = use_facet<_Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Facet.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;
			else
				*_Str++ = _Traits::to_char_type(_Meta);
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{
	typedef basic_istream<_Elem, _Traits> _Myis;
	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;
		else
			_Ch = _Traits::to_char_type(_Meta);
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}


template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, signed char *_Str)
	{
	return (_Istr >> (char *)_Str);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, signed char& _Ch)
	{
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, unsigned char *_Str)
	{
	return (_Istr >> (char *)_Str);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, unsigned char& _Ch)
	{
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr, signed short * _Str)
	{
	return (_Istr >> (wchar_t *)_Str);
	}





















template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{
		const _Ctype& _Facet = use_facet<_Ctype >(_Istr.getloc());

		try {
		for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
			_Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (!_Facet.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

 inline basic_istream<char, char_traits<char> >&
	__cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
	{
	typedef char _Elem;
	typedef char_traits<_Elem> _Traits;
	ios_base::iostate _State = ios_base::goodbit;
	const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

	if (_Ok)
		{
		const ctype<_Elem>& _Facet = use_facet<ctype<_Elem> >(_Istr.getloc());

		try {
		for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
			_Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (!_Facet.is(ctype<_Elem>::space,
				_Traits::to_char_type(_Meta)))
				break;
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

 inline basic_istream<wchar_t, char_traits<wchar_t> >&
	__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
	{
	typedef wchar_t _Elem;
	typedef char_traits<_Elem> _Traits;
	ios_base::iostate _State = ios_base::goodbit;
	const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

	if (_Ok)
		{
		const ctype<_Elem>& _Facet = use_facet<ctype<_Elem> >(_Istr.getloc());

		try {
		for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
			_Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (!_Facet.is(ctype<_Elem>::space,
				_Traits::to_char_type(_Meta)))
				break;

		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}
	_Istr.setstate(_State);
	return (_Istr);
	}
}
#pragma warning(pop)
#pragma pack(pop)









#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4189)

namespace std {


template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{
	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool __cdecl operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{
	return (!(_Left < _Right));
	}













































































































































































template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{
		const _Ctype& _Fac = use_facet<_Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))
				break;
			else
				{
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& __cdecl getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim)
	{
	typedef basic_istream<_Elem, _Traits> _Myis;
	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{
				_State |= ios_base::failbit;
				break;
				}
			else
				{
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& __cdecl operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
			? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit)
			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Str[_Count])))
					{
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}







































}
 #pragma warning(default: 4189)
#pragma warning(pop)
#pragma pack(pop)








#pragma warning (pop)






typedef std::basic_string<wchar_t> QStdWString;












typedef QtValidLicenseForCoreModule QtCoreModule;

class QCharRef;
class QRegExp;
class QStringList;
class QTextCodec;
class QLatin1String;

class __declspec(dllimport) QString
{
public:
    inline QString();
    QString(const QChar *unicode, int size);
    explicit QString(QChar c);
    QString(int size, QChar c);
    inline QString(const QLatin1String &latin1);
    inline QString(const QString &);
    inline ~QString();
    QString &operator=(QChar c);
    QString &operator=(const QString &);
    inline QString &operator=(const QLatin1String &);

    inline int size() const { return d->size; }
    inline int count() const { return d->size; }
    inline int length() const;
    inline bool isEmpty() const;
    void resize(int size);

    QString &fill(QChar c, int size = -1);
    void truncate(int pos);
    void chop(int n);

    int capacity() const;
    inline void reserve(int size);
    inline void squeeze() { if (d->size < d->alloc) realloc(); }

    inline const QChar *unicode() const;
    inline QChar *data();
    inline const QChar *data() const;
    inline const QChar *constData() const;

    inline void detach();
    inline bool isDetached() const;
    void clear();

    inline const QChar at(int i) const;
    const QChar operator[](int i) const;
    QCharRef operator[](int i);
    const QChar operator[](uint i) const;
    QCharRef operator[](uint i);

    QString arg(qlonglong a, int fieldwidth=0, int base=10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(qulonglong a, int fieldwidth=0, int base=10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(long a, int fieldwidth=0, int base=10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(ulong a, int fieldwidth=0, int base=10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(short a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(ushort a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(char a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const;
    QString arg(const QString &a1, const QString &a2) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3) const;
    QString arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const;

    QString    &vsprintf(const char *format, va_list ap);
    QString    &sprintf(const char *format, ...)



        ;

    int indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QChar c, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline QBool contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline QBool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;


    int indexOf(const QRegExp &, int from = 0) const;
    int lastIndexOf(const QRegExp &, int from = -1) const;
    inline QBool contains(const QRegExp &rx) const { return QBool(indexOf(rx) != -1); }
    int count(const QRegExp &) const;


    enum SectionFlag {
        SectionDefault             = 0x00,
        SectionSkipEmpty           = 0x01,
        SectionIncludeLeadingSep   = 0x02,
        SectionIncludeTrailingSep  = 0x04,
        SectionCaseInsensitiveSeps = 0x08
    };
    typedef QFlags<SectionFlag> SectionFlags;

    QString section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;
    QString section(const QString &in_sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;

    QString section(const QRegExp &reg, int start, int end = -1, SectionFlags flags = SectionDefault) const;


    QString left(int len) const;
    QString right(int len) const;
    QString mid(int i, int len = -1) const;

    bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    QString leftJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const;
    QString rightJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const;

    QString toLower() const;
    QString toUpper() const;

    QString trimmed() const;
    QString simplified() const;

    QString &insert(int i, QChar c);
    QString &insert(int i, const QChar *uc, int len);
    inline QString &insert(int i, const QString &s) { return insert(i, s.constData(), s.length()); }
    QString &insert(int i, const QLatin1String &s);
    QString &append(QChar c);
    QString &append(const QString &s);
    QString &append(const QLatin1String &s);
    inline QString &prepend(QChar c) { return insert(0, c); }
    inline QString &prepend(const QString &s) { return insert(0, s); }
    inline QString &prepend(const QLatin1String &s) { return insert(0, s); }
    inline QString &operator+=(QChar c) { return append(c); }
    inline QString &operator+=(QChar::SpecialCharacter c) { return append(QChar(c)); }
    inline QString &operator+=(const QString &s) { return append(s); }
    inline QString &operator+=(const QLatin1String &s) { return append(s); }

    QString &remove(int i, int len);
    QString &remove(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &remove(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(int i, int len, QChar after);
    QString &replace(int i, int len, const QChar *s, int slen);
    QString &replace(int i, int len, const QString &after);
    QString &replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QString &before, const QString &after,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive);

    QString &replace(const QRegExp &rx, const QString &after);
    inline QString &remove(const QRegExp &rx)
    { return replace(rx, QString()); }


    enum SplitBehavior { KeepEmptyParts, SkipEmptyParts };

    QStringList split(const QString &sep, SplitBehavior behavior = KeepEmptyParts,
                      Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    QStringList split(const QChar &sep, SplitBehavior behavior = KeepEmptyParts,
                      Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    QStringList split(const QRegExp &sep, SplitBehavior behavior = KeepEmptyParts) const;


    enum NormalizationForm {
        NormalizationForm_D,
        NormalizationForm_C,
        NormalizationForm_KD,
        NormalizationForm_KC
    };
    QString normalized(NormalizationForm mode) const;
    QString normalized(NormalizationForm mode, QChar::UnicodeVersion version) const;

    const ushort *utf16() const;

    QByteArray toAscii() const;
    QByteArray toLatin1() const;
    QByteArray toUtf8() const;
    QByteArray toLocal8Bit() const;

    static QString fromAscii(const char *, int size = -1);
    static QString fromLatin1(const char *, int size = -1);
    static QString fromUtf8(const char *, int size = -1);
    static QString fromLocal8Bit(const char *, int size = -1);
    static QString fromUtf16(const ushort *, int size = -1);
    static QString fromRawData(const QChar *, int size);

    QString &setUnicode(const QChar *unicode, int size);
    inline QString &setUtf16(const ushort *utf16, int size);

    int compare(const QString &s) const;
    static inline int compare(const QString &s1, const QString &s2)
    { return s1.compare(s2); }
    int localeAwareCompare(const QString& s) const;
    static int localeAwareCompare(const QString& s1, const QString& s2)
    { return s1.localeAwareCompare(s2); }

    short  toShort(bool *ok=0, int base=10) const;
    ushort toUShort(bool *ok=0, int base=10) const;
    int toInt(bool *ok=0, int base=10) const;
    uint toUInt(bool *ok=0, int base=10) const;
    long toLong(bool *ok=0, int base=10) const;
    ulong toULong(bool *ok=0, int base=10) const;
    qlonglong toLongLong(bool *ok=0, int base=10) const;
    qulonglong toULongLong(bool *ok=0, int base=10) const;
    float toFloat(bool *ok=0) const;
    double toDouble(bool *ok=0) const;

    QString &setNum(short, int base=10);
    QString &setNum(ushort, int base=10);
    QString &setNum(int, int base=10);
    QString &setNum(uint, int base=10);
    QString &setNum(long, int base=10);
    QString &setNum(ulong, int base=10);
    QString &setNum(qlonglong, int base=10);
    QString &setNum(qulonglong, int base=10);
    QString &setNum(float, char f='g', int prec=6);
    QString &setNum(double, char f='g', int prec=6);

    static QString number(int, int base=10);
    static QString number(uint, int base=10);
    static QString number(long, int base=10);
    static QString number(ulong, int base=10);
    static QString number(qlonglong, int base=10);
    static QString number(qulonglong, int base=10);
    static QString number(double, char f='g', int prec=6);

    bool operator==(const QString &s) const;
    bool operator<(const QString &s) const;
    inline bool operator>(const QString &s) const { return s < *this; }
    inline bool operator!=(const QString &s) const { return !operator==(s); }
    inline bool operator<=(const QString &s) const { return !operator>(s); }
    inline bool operator>=(const QString &s) const { return !operator<(s); }

    bool operator==(const QLatin1String &s) const;
    bool operator<(const QLatin1String &s) const;
    bool operator>(const QLatin1String &s) const;
    inline bool operator!=(const QLatin1String &s) const { return !operator==(s); }
    inline bool operator<=(const QLatin1String &s) const { return !operator>(s); }
    inline bool operator>=(const QLatin1String &s) const { return !operator<(s); }



    inline QString(const char *ch) : d(&shared_null)
    { d->ref.ref(); *this = fromAscii(ch); }
    inline QString(const QByteArray &a) : d(&shared_null)
    { d->ref.ref(); *this = fromAscii(a); }
    inline QString &operator=(const char *ch)
    { return (*this = fromAscii(ch)); }
    inline QString &operator=(const QByteArray &a)
    { return (*this = fromAscii(a)); }
    inline QString &operator=(char c)
    { return (*this = QChar(c)); }


    inline QString &prepend(const char *s)
    { return prepend(QString::fromAscii(s)); }
    inline QString &prepend(const QByteArray &s)
    { return prepend(QString(s)); }
    inline QString &append(const char *s)
    { return append(QString::fromAscii(s)); }
    inline QString &append(const QByteArray &s)
    { return append(QString(s)); }
    inline QString &operator+=(const char *s)
    { return append(QString::fromAscii(s)); }
    inline QString &operator+=(const QByteArray &s)
    { return append(QString(s)); }
    inline QString &operator+=(char c)
    { return append(QChar(c)); }

    inline bool operator==(const char *s) const;
    inline bool operator!=(const char *s) const;
    inline bool operator<(const char *s) const;
    inline bool operator<=(const char *s2) const;
    inline bool operator>(const char *s2) const;
    inline bool operator>=(const char *s2) const;

    inline bool operator==(const QByteArray &s) const { return (*this == s.constData()); }
    inline bool operator!=(const QByteArray &s) const { return !(*this == s.constData()); }
    inline bool operator<(const QByteArray &s) const { return *this < s.constData(); }
    inline bool operator>(const QByteArray &s) const { return *this > s.constData(); }
    inline bool operator<=(const QByteArray &s) const { return *this <= s.constData(); }
    inline bool operator>=(const QByteArray &s) const { return *this >= s.constData(); }


    typedef QChar *iterator;
    typedef const QChar *const_iterator;
    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    iterator begin();
    const_iterator begin() const;
    const_iterator constBegin() const;
    iterator end();
    const_iterator end() const;
    const_iterator constEnd() const;


    inline void push_back(QChar c) { append(c); }
    inline void push_back(const QString &s) { append(s); }
    inline void push_front(QChar c) { prepend(c); }
    inline void push_front(const QString &s) { prepend(s); }


    static inline QString fromStdString(const std::string &s);
    inline std::string toStdString() const;





    static inline QString fromStdWString(const QStdWString &s);
    inline QStdWString toStdWString() const;





    struct Null { };
    static const Null null;
    inline QString(const Null &): d(&shared_null) { d->ref.ref(); }
    inline QString &operator=(const Null &) { *this = QString(); return *this; }
    inline bool isNull() const { return d == &shared_null; }














































































    bool isSimpleText() const { if (!d->clean) updateProperties(); return d->simpletext; }
    bool isRightToLeft() const { if (!d->clean) updateProperties(); return d->righttoleft; }

private:









    struct Data {
        QBasicAtomic ref;
        int alloc, size;
        ushort *data;
        ushort clean : 1;
        ushort simpletext : 1;
        ushort righttoleft : 1;
        ushort asciiCache : 1;
        ushort reserved : 12;
        ushort array[1];
    };
    static Data shared_null;
    static Data shared_empty;
    Data *d;
    QString(Data *dd, int ) : d(dd) {}

    static QTextCodec *codecForCStrings;

    static int grow(int);
    static void free(Data *);
    void realloc();
    void realloc(int alloc);
    void expand(int i);
    void updateProperties() const;
    QString multiArg(int numArgs, const QString **args) const;

    int toWCharArray(wchar_t *array) const;
    static QString fromWCharArray(const wchar_t *, int);

    friend class QCharRef;
    friend class QTextCodec;
};


class __declspec(dllimport) QLatin1String
{
public:
    inline explicit QLatin1String(const char *s) : chars(s) {}
    inline const char *latin1() const { return chars; }

    inline bool operator==(const QString &s) const
    { return s == *this; }
    inline bool operator!=(const QString &s) const
    { return s != *this; }
    inline bool operator>(const QString &s) const
    { return s < *this; }
    inline bool operator<(const QString &s) const
    { return s > *this; }
    inline bool operator>=(const QString &s) const
    { return s <= *this; }
    inline bool operator<=(const QString &s) const
    { return s >= *this; }

private:
    const char *chars;
};


inline QString::QString(const QLatin1String &latin1) : d(&shared_null)
{ d->ref.ref(); *this = fromLatin1(latin1.latin1()); }
inline int QString::length() const
{ return d->size; }
inline const QChar QString::at(int i) const
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstring.h",530);} while (0); return d->data[i]; }
inline const QChar QString::operator[](int i) const
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstring.h",532);} while (0); return d->data[i]; }
inline const QChar QString::operator[](uint i) const
{ do {if(!(i < uint(size())))qt_assert("i < uint(size())","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstring.h",534);} while (0); return d->data[i]; }
inline bool QString::isEmpty() const
{ return d->size == 0; }
inline const QChar *QString::unicode() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline const QChar *QString::data() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QChar *QString::data()
{ detach(); return reinterpret_cast<QChar*>(d->data); }
inline const QChar *QString::constData() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline void QString::detach()
{ if (d->ref != 1 || d->data != d->array) realloc(); }
inline bool QString::isDetached() const
{ return d->ref == 1; }
inline QString &QString::operator=(const QLatin1String &s)
{
    *this = fromLatin1(s.latin1());
    return *this;
}
inline void QString::clear()
{ if (!isNull()) *this = QString(); }
inline QString::QString(const QString &s) : d(s.d)
{ do {if(!(&s != this))qt_assert("&s != this","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstring.h",557);} while (0); d->ref.ref(); }
inline int QString::capacity() const
{ return d->alloc; }
inline QString &QString::setNum(short n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(int n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(long n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ulong n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }
inline QString QString::arg(int a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(uint a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(long a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ulong a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(short a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ushort a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(const QString &a1, const QString &a2) const
{ const QString *args[2] = { &a1, &a2 }; return multiArg(2, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3) const
{ const QString *args[3] = { &a1, &a2, &a3 }; return multiArg(3, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const
{ const QString *args[4] = { &a1, &a2, &a3, &a4 }; return multiArg(4, args); }
inline QString QString::section(QChar asep, int astart, int aend, SectionFlags aflags) const
{ return section(QString(asep), astart, aend, aflags); }


class __declspec(dllimport) QCharRef {
    QString &s;
    int i;
    inline QCharRef(QString &str, int idx)
        : s(str),i(idx) {}
    friend class QString;
public:




    inline operator QChar() const
        { return i < s.d->size ? s.d->data[i] : 0; }
    inline QCharRef &operator=(const QChar &c)
        { if (s.d->ref != 1 || i >= s.d->size) s.expand(i);
          s.d->data[i] = c.unicode();  return *this; }



    inline QCharRef &operator=(char c) { return operator=(QChar(c)); }
    inline QCharRef &operator=(uchar c) { return operator=(QChar(c)); }

    inline QCharRef &operator=(const QCharRef &c) { return operator=(QChar(c)); }
    inline QCharRef &operator=(ushort rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(short rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(uint rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(int rc) { return operator=(QChar(rc)); }


    inline bool isNull() const { return QChar(*this).isNull(); }
    inline bool isPrint() const { return QChar(*this).isPrint(); }
    inline bool isPunct() const { return QChar(*this).isPunct(); }
    inline bool isSpace() const { return QChar(*this).isSpace(); }
    inline bool isMark() const { return QChar(*this).isMark(); }
    inline bool isLetter() const { return QChar(*this).isLetter(); }
    inline bool isNumber() const { return QChar(*this).isNumber(); }
    inline bool isLetterOrNumber() { return QChar(*this).isLetterOrNumber(); }
    inline bool isDigit() const { return QChar(*this).isDigit(); }

    inline int digitValue() const { return QChar(*this).digitValue(); }
    QChar toLower() const { return QChar(*this).toLower(); }
    QChar toUpper() const { return QChar(*this).toUpper(); }





    QChar::Category category() const { return QChar(*this).category(); }
    QChar::Direction direction() const { return QChar(*this).direction(); }
    QChar::Joining joining() const { return QChar(*this).joining(); }
    bool hasMirrored() const { return QChar(*this).hasMirrored(); }



    QChar mirroredChar() const { return QChar(*this).mirroredChar(); }
    QString decomposition() const { return QChar(*this).decomposition(); }
    QChar::Decomposition decompositionTag() const { return QChar(*this).decompositionTag(); }
    uchar combiningClass() const { return QChar(*this).combiningClass(); }

    QChar::UnicodeVersion unicodeVersion() const { return QChar(*this).unicodeVersion(); }

    inline uchar cell() const { return QChar(*this).cell(); }
    inline uchar row() const { return QChar(*this).row(); }
    inline void setCell(uchar cell);
    inline void setRow(uchar row);

    const char toAscii() const { return QChar(*this).toAscii(); }
    const char toLatin1() const { return QChar(*this).toLatin1(); }




    const ushort unicode() const { return QChar(*this).unicode(); }
};

inline void QCharRef::setRow(uchar arow) { QChar(*this).setRow(arow); }
inline void QCharRef::setCell(uchar acell) { QChar(*this).setCell(acell); }


inline QString::QString() : d(&shared_null) { d->ref.ref(); }
inline QString::~QString() { if (!d->ref.deref()) free(d); }
inline void QString::reserve(int asize) { if (d->ref != 1 || asize > d->alloc) realloc(asize); }
inline QString &QString::setUtf16(const ushort *autf16, int asize)
{ return setUnicode(reinterpret_cast<const QChar *>(autf16), asize); }
inline QCharRef QString::operator[](int i)
{ do {if(!(i >= 0))qt_assert("i >= 0","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstring.h",681);} while (0); return QCharRef(*this, i); }
inline QCharRef QString::operator[](uint i)
{ return QCharRef(*this, i); }
inline QString::iterator QString::begin()
{ detach(); return reinterpret_cast<QChar*>(d->data); }
inline QString::const_iterator QString::begin() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QString::const_iterator QString::constBegin() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QString::iterator QString::end()
{ detach(); return reinterpret_cast<QChar*>(d->data + d->size); }
inline QString::const_iterator QString::end() const
{ return reinterpret_cast<const QChar*>(d->data + d->size); }
inline QString::const_iterator QString::constEnd() const
{ return reinterpret_cast<const QChar*>(d->data + d->size); }
inline QBool QString::contains(const QString &s, Qt::CaseSensitivity cs) const
{ return QBool(indexOf(s, 0, cs) != -1); }
inline QBool QString::contains(QChar c, Qt::CaseSensitivity cs) const
{ return QBool(indexOf(c, 0, cs) != -1); }


inline bool operator==(QString::Null, QString::Null) { return true; }
inline bool operator==(QString::Null, const QString &s) { return s.isNull(); }
inline bool operator==(const QString &s, QString::Null) { return s.isNull(); }
inline bool operator!=(QString::Null, QString::Null) { return false; }
inline bool operator!=(QString::Null, const QString &s) { return !s.isNull(); }
inline bool operator!=(const QString &s, QString::Null) { return !s.isNull(); }


inline bool QString::operator==(const char *s) const {

    if (codecForCStrings) return (*this == QString::fromAscii(s));

    return (*this == QLatin1String(s));
}
inline bool QString::operator!=(const char *s) const{ return !(*this == s); }
inline bool QString::operator<(const char *s) const { return *this < QString::fromAscii(s); }
inline bool QString::operator>(const char *s) const { return *this > QString::fromAscii(s); }
inline bool QString::operator<=(const char *s) const { return *this <= QString::fromAscii(s); }
inline bool QString::operator>=(const char *s) const { return *this >= QString::fromAscii(s); }

inline bool operator==(const char *s1, const QString &s2) { return (s2 == s1); }
inline bool operator!=(const char *s1, const QString &s2) { return !(s2 == s1); }
inline bool operator<(const char *s1, const QString &s2) { return (QString::fromAscii(s1) < s2); }
inline bool operator>(const char *s1, const QString &s2) { return (QString::fromAscii(s1) > s2); }
inline bool operator<=(const char *s1, const QString &s2) { return (QString::fromAscii(s1) <= s2); }
inline bool operator>=(const char *s1, const QString &s2) { return (QString::fromAscii(s1) >= s2); }

inline bool QByteArray::operator==(const QString &s) const { return constData() == s; }
inline bool QByteArray::operator!=(const QString &s) const { return !(constData() == s); }
inline bool QByteArray::operator<(const QString &s) const { return constData() < s; }
inline bool QByteArray::operator>(const QString &s) const { return constData() > s; }
inline bool QByteArray::operator<=(const QString &s) const { return constData() <= s; }
inline bool QByteArray::operator>=(const QString &s) const { return constData() >= s; }



inline QByteArray &QByteArray::append(const QString &s)
{ return append(s.toAscii()); }
inline QByteArray &QByteArray::insert(int i, const QString &s)
{ return insert(i, s.toAscii()); }
inline QByteArray &QByteArray::replace(char c, const QString &after)
{ return replace(c, after.toAscii()); }
inline QByteArray &QByteArray::replace(const QString &before, const char *after)
{ return replace(before.toAscii(), after); }
inline QByteArray &QByteArray::replace(const QString &before, const QByteArray &after)
{ return replace(before, after.constData()); }
inline QByteArray &QByteArray::operator+=(const QString &s)
{ return operator+=(s.toAscii()); }
inline int QByteArray::indexOf(const QString &s, int from) const
{ return indexOf(s.toAscii(), from); }
inline int QByteArray::lastIndexOf(const QString &s, int from) const
{ return lastIndexOf(s.toAscii(), from); }








inline const QString operator+(const QString &s1, const QString &s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(const QString &s1, QChar s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(QChar s1, const QString &s2)
{ QString t(s1); t += s2; return t; }

inline const QString operator+(const QString &s1, const char *s2)
{ QString t(s1); t += QString::fromAscii(s2); return t; }
inline const QString operator+(const char *s1, const QString &s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(char c, const QString &s)
{ QString t = s; t.prepend(QChar(c)); return t; }
inline const QString operator+(const QString &s, char c)
{ QString t(s); t += c; return t; }
inline const QString operator+(const QByteArray &ba, const QString &s)
{ QString t(ba); t += s; return t; }
inline const QString operator+(const QString &s, const QByteArray &ba)
{ QString t(s); t += ba; return t; }



inline std::string QString::toStdString() const
{ return toAscii().data(); }

inline QString QString::fromStdString(const std::string &s)
{ return fromAscii(s.c_str()); }


inline QStdWString QString::toStdWString() const
{
    QStdWString str;
    str.resize(length());
    str.resize(toWCharArray(&(*str.begin())));
    return str;
}
inline QString QString::fromStdWString(const QStdWString &s)
{ return fromWCharArray(s.c_str(), int(s.length())); }













__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QString &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QString &);












template <> class QTypeInfo<QString> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QString)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QString"; } };
template <> inline bool qIsDetached<QString>(QString &t) { return t.isDetached(); }
inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QString::SectionFlags::enum_type f2) { return QFlags<QString::SectionFlags::enum_type>(f1) | f2; } inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QFlags<QString::SectionFlags::enum_type> f2) { return f2 | f1; }


extern __declspec(dllimport) QByteArray qt_winQString2MB(const QString& s, int len=-1);
extern __declspec(dllimport) QByteArray qt_winQString2MB(const QChar *ch, int len);
extern __declspec(dllimport) QString qt_winMB2QString(const char* mb, int len=-1);


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

namespace std { struct bidirectional_iterator_tag; struct random_access_iterator_tag; }





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;





namespace QAlgorithmsPrivate {

template <typename BiIterator, typename T, typename LessThan>
inline void qSortHelper(BiIterator start, BiIterator end, const T &t, LessThan lessThan);
template <typename BiIterator, typename T>
inline void qSortHelper(BiIterator begin, BiIterator end, const T &dummy);

template <typename BiIterator, typename T, typename LessThan>
inline void qStableSortHelper(BiIterator start, BiIterator end, const T &t, LessThan lessThan);
template <typename BiIterator, typename T, typename LessThan>
inline void qStableSortHelper2(BiIterator, BiIterator, LessThan, T *);
template <typename BiIterator, typename T>
inline void qStableSortHelper(BiIterator, BiIterator, const T &);

}

template <typename InputIterator, typename OutputIterator>
inline OutputIterator qCopy(InputIterator begin, InputIterator end, OutputIterator dest)
{
    while (begin != end)
        *dest++ = *begin++;
    return dest;
}

template <typename BiIterator1, typename BiIterator2>
inline BiIterator2 qCopyBackward(BiIterator1 begin, BiIterator1 end, BiIterator2 dest)
{
    while (begin != end)
        *--dest = *--end;
    return dest;
}

template <typename InputIterator1, typename InputIterator2>
inline bool qEqual(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!(*first1 == *first2))
            return false;
    return true;
}

template <typename ForwardIterator, typename T>
inline void qFill(ForwardIterator first, ForwardIterator last, const T &val)
{
    for (; first != last; ++first)
        *first = val;
}

template <typename InputIterator, typename T>
inline InputIterator qFind(InputIterator first, InputIterator last, const T &val)
{
    while (first != last && !(*first == val))
        ++first;
    return first;
}

template <typename InputIterator, typename T, typename Size>
inline void qCount(InputIterator first, InputIterator last, const T &value, Size &n)
{
    for (; first != last; ++first)
        if (*first == value)
            ++n;
}

template <typename T>
inline void qSwap(T &value1, T &value2)
{
    if (!QTypeInfo<T>::isComplex || QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        T t = value1;
        value1 = value2;
        value2 = t;
    } else {
        const void * const t = reinterpret_cast<const void * const &>(value1);
        const_cast<const void *&>(reinterpret_cast<const void * const &>(value1)) =
            reinterpret_cast<const void * const &>(value2);
        const_cast<const void *&>(reinterpret_cast<const void * const &>(value2)) = t;
    }
}

template <typename T>
class qLess
{
public:
    inline bool operator()(const T &t1, const T &t2) const
    {
        return (t1 < t2);
    }
};

template <typename T>
class qGreater
{
public:
    inline bool operator()(const T &t1, const T &t2) const
    {
        return (t2 < t1);
    }
};

template <typename BiIterator>
inline void qSort(BiIterator start, BiIterator end)
{
    if (start != end)
        QAlgorithmsPrivate::qSortHelper(start, end, *start);
}

template <typename BiIterator, typename LessThan>
inline void qSort(BiIterator start, BiIterator end, LessThan lessThan)
{
    if (start != end)
        QAlgorithmsPrivate::qSortHelper(start, end, *start, lessThan);
}

template<typename Container>
inline void qSort(Container &c)
{




    if (!c.empty())
        QAlgorithmsPrivate::qSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename BiIterator>
inline void qStableSort(BiIterator start, BiIterator end)
{
    if (start != end)
        QAlgorithmsPrivate::qStableSortHelper(start, end, *start);
}

template <typename BiIterator, typename LessThan>
inline void qStableSort(BiIterator start, BiIterator end, LessThan lessThan)
{
    if (start != end)
        QAlgorithmsPrivate::qStableSortHelper(start, end, *start, lessThan);
}

template<typename Container>
inline void qStableSort(Container &c)
{




    if (!c.empty())
        QAlgorithmsPrivate::qStableSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator, typename T>
inline RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{
    RandomAccessIterator middle;
    int n = end - begin;
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (*middle < value) {
            begin = middle + 1;
            n -= half + 1;
        } else {
            n = half;
        }
    }
    return begin;
}

template <typename RandomAccessIterator, typename T>
inline RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{
    RandomAccessIterator middle;
    int n = end - begin;
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (value < *middle) {
            n = half;
        } else {
            begin = middle + 1;
            n -= half + 1;
        }
    }
    return begin;
}

template <typename RandomAccessIterator, typename T>
inline RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{
    int l = 0;
    int r = end - begin - 1;
    if (r < 0)
        return end;
    int i = (l + r + 1) / 2;

    while (r != l) {
        if (value < begin[i])
            r = i - 1;
        else
            l = i;
        i = (l + r + 1) / 2;
    }
    if (begin[i] < value || value < begin[i])
        return end;
    else
        return begin + i;
}

template <typename ForwardIterator>
inline void qDeleteAll(ForwardIterator begin, ForwardIterator end)
{
    while (begin != end) {
        delete *begin;
        ++begin;
    }
}

template <typename Container>
inline void qDeleteAll(const Container &c)
{
    qDeleteAll(c.begin(), c.end());
}





namespace QAlgorithmsPrivate {

template <typename BiIterator, typename T, typename LessThan>
inline void qSortHelper(BiIterator start, BiIterator end, const T &t, LessThan lessThan)
{
top:
    int span = end - start;
    if (span < 2)
        return;

    --end;
    BiIterator low = start, high = end - 1;
    BiIterator pivot = start + span / 2;

    if (lessThan(*end, *start))
        qSwap(*end, *start);
    if (span == 2)
        return;

    if (lessThan(*pivot, *start))
        qSwap(*pivot, *start);
    if (lessThan(*end, *pivot))
        qSwap(*end, *pivot);
    if (span == 3)
        return;

    qSwap(*pivot, *end);

    while (low < high) {
        while (low < high && lessThan(*low, *end))
            ++low;

        while (high > low && lessThan(*end, *high))
            --high;

        if (low < high) {
            qSwap(*low, *high);
            ++low;
            --high;
        } else {
            break;
        }
    }

    if (lessThan(*low, *end))
        ++low;

    qSwap(*end, *low);
    qSortHelper(start, low, t, lessThan);

    start = low + 1;
    ++end;
    goto top;
}

template <typename BiIterator, typename T>
inline void qSortHelper(BiIterator begin, BiIterator end, const T &dummy)
{
    qSortHelper(begin, end, dummy, qLess<T>());
}


template <typename BiIterator, typename T, typename LessThan>
inline void qStableSortHelper2(BiIterator start, BiIterator end, LessThan lessThan, T * buf)
{
    if (end - start < 2)
       return;

    BiIterator middle = start + (end - start) / 2;
    qStableSortHelper2(start, middle, lessThan, buf);
    qStableSortHelper2(middle, end, lessThan, buf);

    BiIterator pos = start;
    T *bufPos = buf;
    while (pos != end) {
        *bufPos++ = *pos++;
    }

    T *bufEnd = bufPos;
    T *bufMiddle = buf  + (bufEnd - buf) /2;
    T *b1 = buf;
    T *b2 = bufMiddle;

    pos = start;
    while(b1 < bufMiddle && b2 < bufEnd) {
        if(lessThan(*b2, *b1))
            *pos++ = *b2++;
        else
            *pos++ = *b1++;
    }

    while (b1 < bufMiddle)
        *pos++ = *b1++;
    while (b2 < bufEnd)
        *pos++ = *b2++;
}


template <typename BiIterator, typename T, typename LessThan>
inline void qStableSortHelper(BiIterator start, BiIterator end, const T &t, LessThan lessThan)
{
    (void)t;;
    if(end - start < 2)
       return;

    int size = end - start;
    T *buf = new T[size];
    qStableSortHelper2(start, end, lessThan, buf);
    delete[] buf;
}


template <typename BiIterator, typename T>
inline void qStableSortHelper(BiIterator begin, BiIterator end, const T &dummy)
{
    qStableSortHelper(begin, end, dummy, qLess<T>());
}

}









#pragma once




#pragma pack(push,8)
#pragma warning(push,3)

namespace std {


template<class _Container>
	class back_insert_iterator
		: public _Outit
	{
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	explicit back_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{
		}

	back_insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{
		container->push_back(_Val);
		return (*this);
		}

	back_insert_iterator<_Container>& operator*()
		{
		return (*this);
		}

	back_insert_iterator<_Container>& operator++()
		{
		return (*this);
		}

	back_insert_iterator<_Container> operator++(int)
		{
		return (*this);
		}

protected:
	_Container *container;
	};


template<class _Container> inline
	back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{
	return (std::back_insert_iterator<_Container>(_Cont));
	}


template<class _Container>
	class front_insert_iterator
		: public _Outit
	{
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	explicit front_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{
		}

	front_insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{
		container->push_front(_Val);
		return (*this);
		}

	front_insert_iterator<_Container>& operator*()
		{
		return (*this);
		}

	front_insert_iterator<_Container>& operator++()
		{
		return (*this);
		}

	front_insert_iterator<_Container> operator++(int)
		{
		return (*this);
		}

protected:
	_Container *container;
	};


template<class _Container> inline
	front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{
	return (std::front_insert_iterator<_Container>(_Cont));
	}


template<class _Container>
	class insert_iterator
		: public _Outit
	{
public:
	typedef _Container container_type;
	typedef typename _Container::reference reference;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(&_Cont), iter(_Where)
		{
		}

	insert_iterator<_Container>& operator=(
		typename _Container::const_reference _Val)
		{
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	insert_iterator<_Container>& operator*()
		{
		return (*this);
		}

	insert_iterator<_Container>& operator++()
		{
		return (*this);
		}

	insert_iterator<_Container>& operator++(int)
		{
		return (*this);
		}

protected:
	_Container *container;
	typename _Container::iterator iter;
	};


template<class _Container,
	class _Iter> inline
	insert_iterator<_Container> inserter(_Container& _Cont, _Iter _Where)
	{
	return (std::insert_iterator<_Container>(_Cont, _Where));
	}


template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
		: public iterator<input_iterator_tag, _Ty, _Diff,
			const _Ty *, const _Ty&>
	{
public:
	typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	istream_iterator()
		: _Myistr(0)
		{
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(&_Istr)
		{
		_Getval();
		}

	const _Ty& operator*() const
		{
		return (_Myval);
		}

	const _Ty *operator->() const
		{
		return (&**this);
		}

	_Myt& operator++()
		{
		_Getval();
		return (*this);
		}

	_Myt operator++(int)
		{
		_Myt _Tmp = *this;
		_Getval();
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			_Myistr = 0;
		}

	istream_type *_Myistr;
	_Ty _Myval;
	};


template<class _Ty, class _Elem, class _Traits, class _Diff> inline
	bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{
	return (_Left._Equal(_Right));
	}

template<class _Ty, class _Elem, class _Traits, class _Diff> inline
	bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{
	return (!(_Left == _Right));
	}


template<class _Ty, class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
		: public _Outit
	{
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostream_iterator(ostream_type& _Ostr,
		const _Elem *_Delim = 0)
		: _Myostr(&_Ostr), _Mydelim(_Delim)
		{
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
		{
		*_Myostr << _Val;
		if (_Mydelim != 0)
			*_Myostr << _Mydelim;
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
		{
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
		{
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits> operator++(int)
		{
		return (*this);
		}

protected:
	const _Elem *_Mydelim;
	ostream_type *_Myostr;
	};


template<class _Category, class _Ty, class _Diff,
	class _Pointer, class _Reference> inline
	_Ty *_Val_type(const iterator<_Category, _Ty, _Diff,
		_Pointer, _Reference>&)
	{
	return ((_Ty *)0);
	}

template<class _Ty> inline
	_Ty *_Val_type(const _Ty *)
	{
	return ((_Ty *)0);
	}


template<class _InIt, class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

template<class _InIt, class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{
	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FI, class _Diff> inline
	void _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)
	{
	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BI, class _Diff> inline
	void _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)
	{
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RI, class _Diff> inline
	void _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)
	{
	_Where += _Off;
	}


template<class _Category, class _Ty, class _Diff,
	class _Pointer, class _Reference> inline
	_Diff *_Dist_type(const iterator<_Category, _Ty, _Diff,
		_Pointer, _Reference>&)
	{
	return ((_Diff *)0);
	}

template<class _Ty> inline
	ptrdiff_t *_Dist_type(const _Ty *)
	{
	return ((ptrdiff_t *)0);
	}

}
#pragma warning(pop)
#pragma pack(pop)



























#pragma once




#pragma once




#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4244)
namespace std {


template<class _Arg,
	class _Result>
	struct unary_function
	{
	typedef _Arg argument_type;
	typedef _Result result_type;
	};


template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};


template<class _Ty>
	struct plus
		: public binary_function<_Ty, _Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left + _Right);
		}
	};


template<class _Ty>
	struct minus
		: public binary_function<_Ty, _Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left - _Right);
		}
	};


template<class _Ty>
	struct multiplies
		: public binary_function<_Ty, _Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left * _Right);
		}
	};


template<class _Ty>
	struct divides
		: public binary_function<_Ty, _Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left / _Right);
		}
	};


template<class _Ty>
	struct modulus
		: public binary_function<_Ty, _Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left % _Right);
		}
	};


template<class _Ty>
	struct negate
		: public unary_function<_Ty, _Ty>
	{
	_Ty operator()(const _Ty& _Left) const
		{
		return (-_Left);
		}
	};


template<class _Ty>
	struct equal_to
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left == _Right);
		}
	};


template<class _Ty>
	struct not_equal_to
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left != _Right);
		}
	};


template<class _Ty>
	struct greater
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left > _Right);
		}
	};


template<class _Ty>
	struct less
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left < _Right);
		}
	};


template<class _Ty>
	struct greater_equal
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left >= _Right);
		}
	};


template<class _Ty>
	struct less_equal
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left <= _Right);
		}
	};


template<class _Ty>
	struct logical_and
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left && _Right);
		}
	};


template<class _Ty>
	struct logical_or
		: public binary_function<_Ty, _Ty, bool>
	{
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{
		return (_Left || _Right);
		}
	};


template<class _Ty>
	struct logical_not
		: public unary_function<_Ty, bool>
	{
	bool operator()(const _Ty& _Left) const
		{
		return (!_Left);
		}
	};


template<class _Fn1>
	class unary_negate
	: public unary_function<typename _Fn1::argument_type, bool>
	{
public:
	explicit unary_negate(const _Fn1& _Func)
		: _Functor(_Func)
		{
		}

	bool operator()(const typename _Fn1::argument_type& _Left) const
		{
		return (!_Functor(_Left));
		}

protected:
	_Fn1 _Functor;
	};


template<class _Fn1> inline
	unary_negate<_Fn1> not1(const _Fn1& _Func)
	{
	return (std::unary_negate<_Fn1>(_Func));
	}


template<class _Fn2>
	class binary_negate
		: public binary_function<typename _Fn2::first_argument_type,
			typename _Fn2::second_argument_type, bool>
	{
public:
	explicit binary_negate(const _Fn2& _Func)
		: _Functor(_Func)
		{
		}

	bool operator()(const typename _Fn2::first_argument_type& _Left,
		const typename _Fn2::second_argument_type& _Right) const
		{
		return (!_Functor(_Left, _Right));
		}

protected:
	_Fn2 _Functor;
	};


template<class _Fn2> inline
	binary_negate<_Fn2> not2(const _Fn2& _Func)
	{
	return (std::binary_negate<_Fn2>(_Func));
	}


template<class _Fn2>
	class binder1st
		: public unary_function<typename _Fn2::second_argument_type,
			typename _Fn2::result_type>
	{
public:
	typedef unary_function<typename _Fn2::second_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder1st(const _Fn2& _Func,
		const typename _Fn2::first_argument_type& _Left)
		: op(_Func), value(_Left)
		{
		}

	result_type operator()(const argument_type& _Right) const
		{
		return (op(value, _Right));
		}

protected:
	_Fn2 op;
	typename _Fn2::first_argument_type value;
	};


template<class _Fn2,
	class _Ty> inline
	binder1st<_Fn2> bind1st(const _Fn2& _Func, const _Ty& _Left)
		{
		typename _Fn2::first_argument_type _Val(_Left);
		return (std::binder1st<_Fn2>(_Func, _Val));
		}


template<class _Fn2>
	class binder2nd
		: public unary_function<typename _Fn2::first_argument_type,
			typename _Fn2::result_type>
	{
public:
	typedef unary_function<typename _Fn2::first_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder2nd(const _Fn2& _Func,
		const typename _Fn2::second_argument_type& _Right)
		: op(_Func), value(_Right)
		{
		}

	result_type operator()(const argument_type& _Left) const
		{
		return (op(_Left, value));
		}

protected:
	_Fn2 op;
	typename _Fn2::second_argument_type value;
	};


template<class _Fn2,
	class _Ty> inline
	binder2nd<_Fn2> bind2nd(const _Fn2& _Func, const _Ty& _Right)
	{
	typename _Fn2::second_argument_type _Val(_Right);
	return (std::binder2nd<_Fn2>(_Func, _Val));
	}


template<class _Arg,
	class _Result>
	class pointer_to_unary_function
		: public unary_function<_Arg, _Result>
	{
public:
	explicit pointer_to_unary_function(_Result (__cdecl *_Left)(_Arg))
		: _Pfun(_Left)
		{
		}

	_Result operator()(_Arg _Left) const
		{
		return (_Pfun(_Left));
		}

protected:
	_Result (__cdecl *_Pfun)(_Arg);
	};


template<class _Arg1,
	class _Arg2,
	class _Result>
	class pointer_to_binary_function
		: public binary_function<_Arg1, _Arg2, _Result>
	{
public:
	explicit pointer_to_binary_function(
		_Result (__cdecl *_Left)(_Arg1, _Arg2))
		: _Pfun(_Left)
		{
		}

	_Result operator()(_Arg1 _Left, _Arg2 _Right) const
		{
		return (_Pfun(_Left, _Right));
		}

protected:
	_Result (__cdecl *_Pfun)(_Arg1, _Arg2);
	};


template<class _Arg,
	class _Result> inline
	pointer_to_unary_function<_Arg, _Result>
		ptr_fun(_Result (__cdecl *_Left)(_Arg))
	{
	return (std::pointer_to_unary_function<_Arg, _Result>(_Left));
	}

template<class _Arg1,
	class _Arg2,
	class _Result> inline
	pointer_to_binary_function<_Arg1, _Arg2, _Result>
		ptr_fun(_Result (__cdecl *_Left)(_Arg1, _Arg2))
	{
	return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Left));
	}


template<class _Result,
	class _Ty>
	class mem_fun_t
		: public unary_function<_Ty *, _Result>
	{
public:
	explicit mem_fun_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(_Ty *_Pleft) const
		{
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();
	};


template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_t
		: public binary_function<_Ty *, _Arg, _Result>
	{
public:
	explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(_Ty *_Pleft, _Arg _Right) const
		{
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);
	};


template<class _Result,
	class _Ty>
	class const_mem_fun_t
		: public unary_function<const _Ty *, _Result>
	{
public:
	explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(const _Ty *_Pleft) const
		{
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;
	};


template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_t
		: public binary_function<_Ty *, _Arg, _Result>
	{
public:
	explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(const _Ty *_Pleft, _Arg _Right) const
		{
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;
	};


template<class _Result,
	class _Ty> inline
	mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
	{
	return (std::mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
	{
	return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_t<_Result, _Ty>
		mem_fun(_Result (_Ty::*_Pm)() const)
	{
	return (std::const_mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_t<_Result, _Ty, _Arg>
		mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
	{
	return (std::const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}


template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun1(_Result (_Ty::*_Pm)(_Arg))
	{
	return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}


template<class _Result,
	class _Ty>
	class mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{
public:
	explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(_Ty& _Left) const
		{
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();
	};


template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{
public:
	explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(_Ty& _Left, _Arg _Right) const
		{
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);
	};


template<class _Result,
	class _Ty>
	class const_mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{
public:
	explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(const _Ty& _Left) const
		{
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;
	};


template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{
public:
	explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{
		}

	_Result operator()(const _Ty& _Left, _Arg _Right) const
		{
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;
	};


template<class _Result,
	class _Ty> inline
	mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
	{
	return (std::mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
	{
	return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_ref_t<_Result, _Ty>
		mem_fun_ref(_Result (_Ty::*_Pm)() const)
	{
	return (std::const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
	{
	return (std::const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}


template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun1_ref(_Result (_Ty::*_Pm)(_Arg))
	{
	return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
}

  #pragma warning(default: 4244)
#pragma warning(pop)
#pragma pack(pop)



























#pragma once





#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Ty> inline
	pair<_Ty  *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _Count)
	{
	_Ty  *_Pbuf;

	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty  *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty  *, ptrdiff_t>(_Pbuf, _Count));
	}


template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{
	operator delete(_Pbuf);
	}


template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
	return (_Uninit_copy(_First, _Last, _Dest,
		_Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Nonscalar_ptr_iterator_tag)
	{
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _Ty> inline
	_Ty *_Uninit_copy(const _Ty *_First, const _Ty *_Last, _Ty *_Dest,
		_Scalar_ptr_iterator_tag)
	{
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty *)memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);
	}


template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Nonscalar_ptr_iterator_tag)
	{
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _Ty> inline
	_Ty *_Uninit_copy(const _Ty *_First, const _Ty *_Last, _Ty *_Dest,
		allocator<_Ty>&, _Scalar_ptr_iterator_tag)
	{
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty *)memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);
	}


template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{
	std::fill(_First, _Last, _Val);
	}


template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{
	_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{
	std::fill_n(_First, _Count, _Val);
	}


template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{
	_Uninit_fill_n(_First, _Count, _Val, _Al,
		_Ptr_cat(_First, _First));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al, _Nonscalar_ptr_iterator_tag)
	{
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Al.construct(_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval& _Val, allocator<_Ty>&, _Scalar_ptr_iterator_tag)
	{
	fill_n(_First, _Count, _Val);
	}


template<class _FwdIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{
public:
	typedef _FwdIt iterator_type;
	typedef _FwdIt iter_type;
	typedef _Ty element_type;

	explicit raw_storage_iterator(_FwdIt _First)
		: _Next(_First)
		{
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator*()
		{
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator=(const _Ty& _Val)
		{
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator++()
		{
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty> operator++(int)
		{
		raw_storage_iterator<_FwdIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_FwdIt _Next;
	};


template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{
public:
	typedef _Ty  *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{
		pair<_Pty, ptrdiff_t> _Pair =
			std::get_temporary_buffer<_Ty>(_Count);
		_Buf._Begin = _Pair.first;
		_Buf._Current = _Pair.first;
		_Buf._Hiwater = _Pair.first;
		_Buf._Size = _Pair.second;
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator()
		{
		if (_Buf._Begin != 0)
			{
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			std::return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;
		else
			{
			_Construct(&*_Pbuf->_Current, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen() const
		{
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{
		_Pty _Begin;
		_Pty _Current;
		_Pty _Hiwater;
		ptrdiff_t _Size;
		};
	_Bufpar _Buf;
	_Bufpar *_Pbuf;
	};


template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{
	auto_ptr_ref(auto_ptr<_Ty>& _Right)
		: _Ref(_Right)
		{
		}

	auto_ptr<_Ty>& _Ref;
	};

template<class _Ty>
	class auto_ptr
		{
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) throw ()
		: _Myptr(_Ptr)
		{
		}

	auto_ptr(auto_ptr<_Ty>& _Right) throw ()
		: _Myptr(_Right.release())
		{
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
		: _Myptr(_Right._Ref.release())
		{
		}

	template<class _Other>
		operator auto_ptr<_Other>() throw ()
		{
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() throw ()
		{
		return (auto_ptr_ref<_Other>(*this));
		}

	template<class _Other>
		auto_ptr<_Ty>& operator=(auto_ptr<_Other>& _Right) throw ()
		{
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) throw ()
		: _Myptr(_Right.release())
		{
		}

	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Right) throw ()
		{
		reset(_Right.release());
		return (*this);
		}

	auto_ptr<_Ty>& operator=(auto_ptr_ref<_Ty>& _Right) throw ()
		{
		reset(_Right._Ref.release());
		return (*this);
		}

	~auto_ptr()
		{
		delete _Myptr;
		}

	_Ty& operator*() const throw ()
		{
		return (*get());
		}

	_Ty *operator->() const throw ()
		{
		return (get());
		}

	_Ty *get() const throw ()
		{
		return (_Myptr);
		}

	_Ty *release() throw ()
		{
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty* _Ptr = 0)
		{
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;
	};
}
#pragma warning(pop)
#pragma pack(pop)



























#pragma pack(push,8)
#pragma warning(push,3)

namespace std {


template<class _Ty,
	class _Alloc>
	class _List_nod
	{
protected:
	struct _Node;
	friend struct _Node;
	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Genptr;

	struct _Node
		{
		_Node(_Genptr _Nextarg, _Genptr _Prevarg, const _Ty& _Myvalarg)
			: _Next(_Nextarg), _Prev(_Prevarg), _Myval(_Myvalarg)
			{
			}

		_Genptr _Next;
		_Genptr _Prev;
		_Ty _Myval;
		};

	_List_nod(_Alloc _Al)
		: _Alnod(_Al)
		{
		}

	typename _Alloc::template rebind<_Node>::other
		_Alnod;
	};


template<class _Ty,
	class _Alloc>
	class _List_ptr
		: public _List_nod<_Ty, _Alloc>
	{
protected:
	typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Nodeptr;

	_List_ptr(_Alloc _Al)
		: _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
		{
		}

	typename _Alloc::template rebind<_Nodeptr>::other
		_Alptr;
	};


template<class _Ty,
	class _Alloc>
	class _List_val
		: public _List_ptr<_Ty, _Alloc>
	{
protected:
	typedef typename _Alloc::template rebind<_Ty>::other _Alty;

	_List_val(_Alloc _Al = _Alloc())
		: _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
		{
		}

	_Alty _Alval;
	};


template<class _Ty,
	class _Ax = allocator<_Ty> >
	class list
		: public _List_val<_Ty, _Ax>
	{
public:
	typedef list<_Ty, _Ax> _Myt;
	typedef _List_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;

protected:
	typedef typename _List_nod<_Ty, _Alloc>::_Genptr _Genptr;
	typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
	typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
	typedef typename _Alloc::template rebind<_Nodeptr>::other::reference _Nodepref;
	typedef typename _Alloc::reference _Vref;

	static _Nodepref _Next(_Nodeptr _Pnode)
		{
		return ((_Nodepref)(*_Pnode)._Next);
		}

	static _Nodepref _Prev(_Nodeptr _Pnode)
		{
		return ((_Nodepref)(*_Pnode)._Prev);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;


	class const_iterator;
	friend class const_iterator;

	class const_iterator
		: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
		{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		const_iterator()
			: _Ptr(0)
			{
			}

		const_iterator(_Nodeptr _Pnode)
			: _Ptr(_Pnode)
			{
			}

		const_reference operator*() const
			{
			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{
			return (&**this);
			}

		const_iterator& operator++()
			{
			_Ptr = _Next(_Ptr);
			return (*this);
			}

		const_iterator operator++(int)
			{
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{
			_Ptr = _Prev(_Ptr);
			return (*this);
			}

		const_iterator operator--(int)
			{
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _Right) const
			{
			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const const_iterator& _Right) const
			{
			return (!(*this == _Right));
			}

		_Nodeptr _Mynode() const
			{
			return (_Ptr);
			}


	protected:
		_Nodeptr _Ptr;
		};


	class iterator;
	friend class iterator;

	class iterator
		: public const_iterator
		{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Tptr pointer;
		typedef _Reft reference;

		iterator()
			: const_iterator(0)
			{
			}

		iterator(_Nodeptr _Pnode)
			: const_iterator(_Pnode)
			{
			}

		reference operator*() const
			{
			return (_Myval(_Ptr));
			}


		_Tptr operator->() const
			{
			return (&**this);
			}

		iterator& operator++()
			{
			_Ptr = _Next(_Ptr);
			return (*this);
			}

		iterator operator++(int)
			{
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{
			_Ptr = _Prev(_Ptr);
			return (*this);
			}

		iterator operator--(int)
			{
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	list()
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
		}

	explicit list(const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
		}

	explicit list(size_type _Count)
		: _Mybase(), _Myhead(0), _Mysize(0)
		{
		_Ty _Val = _Ty();
		_Myhead = _Buynode();
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
		_Construct_n(_Count, _Val);
		}

	list(const _Myt& _Right)
		: _Mybase(_Right._Alval),
			_Myhead(_Buynode()), _Mysize(0)
		{
		try {
		insert(begin(), _Right.begin(), _Right.end());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		_Construct_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count, const _Ty& _Val)
		{
		try {
		_Insert_n(begin(), _Count, _Val);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	~list()
		{
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{
		if (this != &_Right)
			assign(_Right.begin(), _Right.end());
		return (*this);
		}

	iterator begin()
		{
		return (iterator(_Myhead == 0 ? 0 : _Next(_Myhead)));
		}

	const_iterator begin() const
		{
		return (const_iterator(_Myhead == 0 ? 0 : _Next(_Myhead)));
		}

	iterator end()
		{
		return (iterator(_Myhead));
		}

	const_iterator end() const
		{
		return (const_iterator(_Myhead));
		}

	reverse_iterator rbegin()
		{
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else
			while (_Newsize < size())
				pop_back();
		}

	size_type size() const
		{
		return (_Mysize);
		}

	size_type max_size() const
		{
		return (this->_Alval.max_size());
		}

	bool empty() const
		{
		return (_Mysize == 0);
		}

	allocator_type get_allocator() const
		{
		return (this->_Alval);
		}

	reference front()
		{
		return (*begin());
		}

	const_reference front() const
		{
		return (*begin());
		}

	reference back()
		{
		return (*(--end()));
		}

	const_reference back() const
		{
		return (*(--end()));
		}

	void push_front(const _Ty& _Val)
		{
		_Insert(begin(), _Val);
		}

	void pop_front()
		{
		erase(begin());
		}

	void push_back(const _Ty& _Val)
		{
		_Insert(end(), _Val);
		}

	void pop_back()
		{
		erase(--end());
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{
		_Insert(_Where, _Val);
		return (--_Where);
		}

	void _Insert(iterator _Where, const _Ty& _Val)
		{
		_Nodeptr _Pnode = _Where._Mynode();
		_Nodeptr _Newnode = _Buynode(_Pnode, _Prev(_Pnode), _Val);
		_Incsize(1);
		_Prev(_Pnode) = _Newnode;
		_Next(_Prev(_Newnode)) = _Newnode;
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{
		_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{
		size_type _Num = 0;

		try {
		for (; _First != _Last; ++_First, ++_Num)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; 0 < _Num; --_Num)
			{
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			forward_iterator_tag)
		{
		_Iter _Next = _First;

		try {
		for (; _First != _Last; ++_First)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; _Next != _First; ++_Next)
			{
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	iterator erase(iterator _Where)
		{
		_Nodeptr _Pnode = (_Where++)._Mynode();
		if (_Pnode != _Myhead)
			{
			_Next(_Prev(_Pnode)) = _Next(_Pnode);
			_Prev(_Next(_Pnode)) = _Prev(_Pnode);
			this->_Alnod.destroy(_Pnode);
			this->_Alnod.deallocate(_Pnode, 1);
			--_Mysize;
			}
		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{
		while (_First != _Last)
			erase(_First++);
		return (_First);
		}

	void clear()
		{
		erase(begin(), end());
		}

	void swap(_Myt& _Right)
		{
		if (this->_Alval == _Right._Alval)
			{
			std::swap(_Myhead, _Right._Myhead);
			std::swap(_Mysize, _Right._Mysize);
			}
		else
			{
			iterator _Where = begin();
			splice(_Where, _Right);
			_Right.splice(_Right.begin(), *this, _Where, end());
			}
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

	void splice(iterator _Where, _Myt& _Right)
		{
		if (this != &_Right && !_Right.empty())
			{
			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
				_Right._Mysize);
			}
		}

	void splice(iterator _Where, _Myt& _Right, iterator _First)
		{
		iterator _Last = _First;
		if (_First != _Right.end() && _Where != _First && _Where != ++_Last)
			{
			_Splice(_Where, _Right, _First, _Last, 1);
			}
		}

	void splice(iterator _Where, _Myt& _Right,
		iterator _First, iterator _Last)
		{
		if (_First != _Last && _Where != _Last)
			{
			size_type _Count = 0;
			if (this == &_Right)
				;
			else if (_First == _Right.begin() && _Last == _Right.end())
				_Count = _Right.size();
			else
				_Distance(_First, _Last, _Count);
			_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}

	void remove(const _Ty& _Val)
		{
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (*_First == _Val)
				erase(_First++);
			else
				++_First;
		}

	template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (_Pred(*_First))
				erase(_First++);
			else
				++_First;
		}

	void unique()
		{
		iterator _First = begin(), _Last = end();
		if (_First != _Last)
			for (iterator _Next = _First; ++_Next != _Last; _Next = _First)
				if (*_First == *_Next)
					erase(_Next);
				else
					_First = _Next;
		}

	template<class _Pr2>
		void unique(_Pr2 _Pred)
		{
		iterator _First = begin(), _Last = end();
		if (_First != _Last)
			for (iterator _Next = _First; ++_Next != _Last; _Next = _First)
				if (_Pred(*_First, *_Next))
					erase(_Next);
				else
					_First = _Next;
		}

	void merge(_Myt& _Right)
		{
		if (&_Right != this)
			{
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();

			while (_First1 != _Last1 && _First2 != _Last2)
				if (*_First2 < *_First1)
					{
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);
			}
		}

	template<class _Pr3>
		void merge(_Myt& _Right, _Pr3 _Pred)
		{
		if (&_Right != this)
			{
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();

			while (_First1 != _Last1 && _First2 != _Last2)
				if (_Pred(*_First2, *_First1))
					{
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);
			}
		}

	void sort()
		{
		if (2 <= size())
			{
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{
				_Templist.splice(_Templist.begin(), *this, begin());
				size_t _Bin;

				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{
					_Binlist[_Bin].merge(_Templist);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist);
				else
					{
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);
			swap(_Binlist[_Maxbin - 1]);
			}
		}

	template<class _Pr3>
		void sort(_Pr3 _Pred)
		{
		if (2 <= size())
			{
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{
				_Templist.splice(_Templist.begin(), *this, begin());
				size_t _Bin;

				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{
					_Binlist[_Bin].merge(_Templist, _Pred);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist, _Pred);
				else
					{
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
					_Pred);
			swap(_Binlist[_Maxbin - 1]);
			}
		}

	void reverse()
		{
		if (2 <= size())
			{
			iterator _Last = end();
			for (iterator _Next = ++begin(); _Next != _Last; )
				{
				iterator _Before = _Next;
				_Splice(begin(), *this, _Before, ++_Next, 1);
				}
			}
		}

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{
		_Ty _Tmp = _Val;
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Tmp);
		}

	_Nodeptr _Buynode()
		{
		_Nodeptr _Pnode = this->_Alnod.allocate(1, (void *)0);
		int _Linkcnt = 0;

		try {
		this->_Alptr.construct(&_Next(_Pnode), _Pnode);
		++_Linkcnt;
		this->_Alptr.construct(&_Prev(_Pnode), _Pnode);
		} catch (...) {
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Next(_Pnode));
		this->_Alnod.deallocate(_Pnode, 1);
		throw;
		}
		return (_Pnode);
		}

	_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev, const _Ty& _Val)
		{
		_Nodeptr _Pnode = this->_Alnod.allocate(1, (void *)0);
		try {
		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);
		} catch (...) {
		this->_Alnod.deallocate(_Pnode, 1);
		throw;
		}
		return (_Pnode);
		}

	void _Tidy()
		{
		erase(begin(), end());
		this->_Alptr.destroy(&_Next(_Myhead));
		this->_Alptr.destroy(&_Prev(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0, _Mysize = 0;
		}

	void _Insert_n(iterator _Where, size_type _Count, const _Ty& _Val)
		{
		size_type _Countsave = _Count;

		try {
		for (; 0 < _Count; --_Count)
			_Insert(_Where, _Val);
		} catch (...) {
		for (; _Count < _Countsave; ++_Count)
			{
			iterator _Before = _Where;
			erase(--_Before);
			}
		throw;
		}
		}

	void _Splice(iterator _Where, _Myt& _Right,
		iterator _First, iterator _Last, size_type _Count)
		{
		if (this->_Alval == _Right._Alval)
			{
			if (this != &_Right)
				{
				_Incsize(_Count);
				_Right._Mysize -= _Count;
				}
			_Next(_Prev(_First._Mynode())) = _Last._Mynode();
			_Next(_Prev(_Last._Mynode())) = _Where._Mynode();
			_Next(_Prev(_Where._Mynode())) = _First._Mynode();
			_Nodeptr _Pnode = _Prev(_Where._Mynode());
			_Prev(_Where._Mynode()) = _Prev(_Last._Mynode());
			_Prev(_Last._Mynode()) = _Prev(_First._Mynode());
			_Prev(_First._Mynode()) = _Pnode;
			}
		else
			{
			insert(_Where, _First, _Last);
			_Right.erase(_First, _Last);
			}
		}

	void _Incsize(size_type _Count)
		{
		if (max_size() - size() < _Count)
			throw length_error("list<T> too long");
		_Mysize += _Count;
		}

	_Nodeptr _Myhead;
	size_type _Mysize;
	};


template<class _Ty, class _Alloc> inline
	bool operator==(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty, class _Alloc> inline
	bool operator!=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Ty, class _Alloc> inline
	bool operator<(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty, class _Alloc> inline
	bool operator>(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Ty, class _Alloc> inline
	bool operator<=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Ty, class _Alloc> inline
	bool operator>=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{
	return (!(_Left < _Right));
	}

}
#pragma warning(pop)
#pragma pack(pop)



























typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T> class QVector;
template <typename T> class QSet;

struct __declspec(dllimport) QListData {
    struct Data {
        QBasicAtomic ref;
        int alloc, begin, end;
        uint sharable : 1;
        void *array[1];
    };
    enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };

    Data *detach();
    void realloc(int alloc);
    static Data shared_null;
    Data *d;
    void **erase(void **xi);
    void **append();
    void **append(const QListData &l);
    void **prepend();
    void **insert(int i);
    void remove(int i);
    void remove(int i, int n);
    void move(int from, int to);
    inline int size() const { return d->end - d->begin; }
    inline bool isEmpty() const { return d->end  == d->begin; }
    inline void **at(int i) const { return d->array + d->begin + i; }
    inline void **begin() const { return d->array + d->begin; }
    inline void **end() const { return d->array + d->end; }
};

template <typename T>
class QList
{
    struct Node { void *v;



        inline T &t()
        { return *reinterpret_cast<T*>(QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic
                                       ? v : this); }

    };

    union { QListData p; QListData::Data *d; };

public:
    inline QList() : d(&QListData::shared_null) { d->ref.ref(); }
    inline QList(const QList &l) : d(l.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }
    ~QList();
    QList &operator=(const QList &l);
    bool operator==(const QList &l) const;
    inline bool operator!=(const QList &l) const { return !(*this == l); }

    inline int size() const { return p.size(); }

    inline void detach() { if (d->ref != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref == 1; }
    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

    inline bool isEmpty() const { return p.isEmpty(); }

    void clear();

    const T &at(int i) const;
    const T &operator[](int i) const;
    T &operator[](int i);

    void append(const T &t);
    void prepend(const T &t);
    void insert(int i, const T &t);
    void replace(int i, const T &t);
    void removeAt(int i);
    int removeAll(const T &t);
    T takeAt(int i);
    T takeFirst();
    T takeLast();
    void move(int from, int to);
    void swap(int i, int j);
    int indexOf(const T &t, int from = 0) const;
    int lastIndexOf(const T &t, int from = -1) const;
    QBool contains(const T &t) const;
    int count(const T &t) const;

    class const_iterator;

    class iterator {
    public:
        Node *i;
        typedef std::random_access_iterator_tag  iterator_category;
        typedef ptrdiff_t  difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline iterator() : i(0) {}
        inline iterator(Node *n) : i(n) {}
        inline iterator(const iterator &o): i(o.i){}
        inline T &operator*() const { return i->t(); }
        inline T *operator->() const { return &i->t(); }
        inline T &operator[](int j) const { return i[j].t(); }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator<(const iterator& other) const { return i < other.i; }
        inline bool operator<=(const iterator& other) const { return i <= other.i; }
        inline bool operator>(const iterator& other) const { return i > other.i; }
        inline bool operator>=(const iterator& other) const { return i >= other.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == reinterpret_cast<const iterator &>(o).i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != reinterpret_cast<const iterator &>(o).i; }
        inline bool operator<(const const_iterator& other) const
            { return i < reinterpret_cast<const iterator &>(other).i; }
        inline bool operator<=(const const_iterator& other) const
            { return i <= reinterpret_cast<const iterator &>(other).i; }
        inline bool operator>(const const_iterator& other) const
            { return i > reinterpret_cast<const iterator &>(other).i; }
        inline bool operator>=(const const_iterator& other) const
            { return i >= reinterpret_cast<const iterator &>(other).i; }
        inline iterator &operator++() { ++i; return *this; }
        inline iterator operator++(int) { Node *n = i; ++i; return n; }
        inline iterator &operator--() { i--; return *this; }
        inline iterator operator--(int) { Node *n = i; i--; return n; }
        inline iterator &operator+=(int j) { i+=j; return *this; }
        inline iterator &operator-=(int j) { i-=j; return *this; }
        inline iterator operator+(int j) const { return iterator(i+j); }
        inline iterator operator-(int j) const { return iterator(i-j); }
        inline int operator-(iterator j) const { return i - j.i; }
    };
    friend class iterator;

    class const_iterator {
    public:
        Node *i;
        typedef std::random_access_iterator_tag  iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline const_iterator() : i(0) {}
        inline const_iterator(Node *n) : i(n) {}
        inline const_iterator(const const_iterator &o): i(o.i) {}
        inline const_iterator(const iterator &o): i(o.i) {}
        inline const T &operator*() const { return i->t(); }
        inline const T *operator->() const { return &i->t(); }
        inline const T &operator[](int j) const { return i[j].t(); }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline bool operator<(const const_iterator& other) const { return i < other.i; }
        inline bool operator<=(const const_iterator& other) const { return i <= other.i; }
        inline bool operator>(const const_iterator& other) const { return i > other.i; }
        inline bool operator>=(const const_iterator& other) const { return i >= other.i; }
        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { Node *n = i; ++i; return n; }
        inline const_iterator &operator--() { i--; return *this; }
        inline const_iterator operator--(int) { Node *n = i; i--; return n; }
        inline const_iterator &operator+=(int j) { i+=j; return *this; }
        inline const_iterator &operator-=(int j) { i+=j; return *this; }
        inline const_iterator operator+(int j) const { return const_iterator(i+j); }
        inline const_iterator operator-(int j) const { return const_iterator(i-j); }
        inline int operator-(const_iterator j) const { return i - j.i; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return reinterpret_cast<Node *>(p.begin()); }
    inline const_iterator begin() const { return reinterpret_cast<Node *>(p.begin()); }
    inline const_iterator constBegin() const { return reinterpret_cast<Node *>(p.begin()); }
    inline iterator end() { detach(); return reinterpret_cast<Node *>(p.end()); }
    inline const_iterator end() const { return reinterpret_cast<Node *>(p.end()); }
    inline const_iterator constEnd() const { return reinterpret_cast<Node *>(p.end()); }
    iterator insert(iterator before, const T &t);
    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return p.size(); }
    inline T& first() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",208);} while (0); return *begin(); }
    inline const T& first() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",209);} while (0); return *begin(); }
    T& last() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",210);} while (0); return *(--end()); }
    const T& last() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",211);} while (0); return *(--end()); }
    inline void removeFirst() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",212);} while (0); erase(begin()); }
    inline void removeLast() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",213);} while (0); erase(--end()); }
    QList<T> mid(int pos, int length = -1) const;

    T value(int i) const;
    T value(int i, const T &defaultValue) const;


    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    inline T& front() { return first(); }
    inline const T& front() const { return first(); }
    inline T& back() { return last(); }
    inline const T& back() const { return last(); }
    inline void pop_front() { removeFirst(); }
    inline void pop_back() { removeLast(); }
    inline bool empty() const { return isEmpty(); }
    typedef int size_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
















    QList &operator+=(const QList &l);
    inline QList operator+(const QList &l) const
    { QList n = *this; n += l; return n; }
    inline QList &operator+=(const T &t)
    { append(t); return *this; }
    inline QList &operator<< (const T &t)
    { append(t); return *this; }
    inline QList &operator<<(const QList &l)
    { *this += l; return *this; }

    QVector<T> toVector() const;
    QSet<T> toSet() const;

    static QList<T> fromVector(const QVector<T> &vector);
    static QList<T> fromSet(const QSet<T> &set);


    static inline QList<T> fromStdList(const std::list<T> &list)
    { QList<T> tmp; qCopy(list.begin(), list.end(), std::back_inserter(tmp)); return tmp; }
    inline std::list<T> toStdList() const
    { std::list<T> tmp; qCopy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }


private:
    void detach_helper();
    void free(QListData::Data *d);

    void node_construct(Node *n, const T &t);
    void node_destruct(Node *n);
    void node_copy(Node *from, Node *to, Node *src);
    void node_destruct(Node *from, Node *to);
};







template <typename T>
inline void QList<T>::node_construct(Node *n, const T &t)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) n->v = new T(t);
    else if (QTypeInfo<T>::isComplex) new (n) T(t);
    else *reinterpret_cast<T*>(n) = t;
}

template <typename T>
inline void QList<T>::node_destruct(Node *n)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) delete reinterpret_cast<T*>(n->v);
    else if (QTypeInfo<T>::isComplex) reinterpret_cast<T*>(n)->~T();
}

template <typename T>
inline void QList<T>::node_copy(Node *from, Node *to, Node *src)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
        while(from != to)
            (from++)->v = new T(*reinterpret_cast<T*>((src++)->v));
    else if (QTypeInfo<T>::isComplex)
        while(from != to)
            new (from++) T(*reinterpret_cast<T*>(src++));
}

template <typename T>
inline void QList<T>::node_destruct(Node *from, Node *to)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
        while(from != to) --to, delete reinterpret_cast<T*>(to->v);
    else if (QTypeInfo<T>::isComplex)
        while (from != to) --to, reinterpret_cast<T*>(to)->~T();
}

template <typename T>
inline QList<T> &QList<T>::operator=(const QList<T> &l)
{
    if (d != l.d) {
        QListData::Data *x = l.d;
        x->ref.ref();
        x = qAtomicSetPtr(&d, x);
        if (!x->ref.deref())
            free(x);
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::insert(iterator before, const T &t)
{ Node *n = reinterpret_cast<Node *>(p.insert(before.i-reinterpret_cast<Node *>(p.begin())));
 node_construct(n,t); return n; }
template <typename T>
inline typename QList<T>::iterator QList<T>::erase(iterator it)
{ node_destruct(it.i);
 return reinterpret_cast<Node *>(p.erase(reinterpret_cast<void**>(it.i))); }
template <typename T>
inline const T &QList<T>::at(int i) const
{ do {if(!(i >= 0 && i < p.size()))qt_assert_x("QList<T>::at", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",349);} while (0);
 return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline const T &QList<T>::operator[](int i) const
{ do {if(!(i >= 0 && i < p.size()))qt_assert_x("QList<T>::operator[]", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",353);} while (0);
 return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline T &QList<T>::operator[](int i)
{ do {if(!(i >= 0 && i < p.size()))qt_assert_x("QList<T>::operator[]", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",357);} while (0);
  detach(); return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline void QList<T>::removeAt(int i)
{ if(i >= 0 && i < p.size()) { detach();
 node_destruct(reinterpret_cast<Node *>(p.at(i))); p.remove(i); } }
template <typename T>
inline T QList<T>::takeAt(int i)
{ do {if(!(i >= 0 && i < p.size()))qt_assert_x("QList<T>::take", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",365);} while (0);
 detach(); Node *n = reinterpret_cast<Node *>(p.at(i)); T t = n->t(); node_destruct(n);
 p.remove(i); return t; }
template <typename T>
inline T QList<T>::takeFirst()
{ T t = first(); removeFirst(); return t; }
template <typename T>
inline T QList<T>::takeLast()
{ T t = last(); removeLast(); return t; }

template <typename T>
void QList<T>::append(const T &t)
{
    detach();
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        node_construct(reinterpret_cast<Node *>(p.append()), t);
    } else {
        const T cpy(t);
        node_construct(reinterpret_cast<Node *>(p.append()), cpy);
    }
}

template <typename T>
inline void QList<T>::prepend(const T &t)
{
    detach();
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        node_construct(reinterpret_cast<Node *>(p.prepend()), t);
    } else {
        const T cpy(t);
        node_construct(reinterpret_cast<Node *>(p.prepend()), cpy);
    }
}

template <typename T>
inline void QList<T>::insert(int i, const T &t)
{
    detach();
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        node_construct(reinterpret_cast<Node *>(p.insert(i)), t);
    } else {
        const T cpy(t);
        node_construct(reinterpret_cast<Node *>(p.insert(i)), cpy);
    }
}

template <typename T>
inline void QList<T>::replace(int i, const T &t)
{
    do {if(!(i >= 0 && i < p.size()))qt_assert_x("QList<T>::replace", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",414);} while (0);
    detach();
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        reinterpret_cast<Node *>(p.at(i))->t() = t;
    } else {
        const T cpy(t);
        reinterpret_cast<Node *>(p.at(i))->t() = cpy;
    }
}

template <typename T>
inline void QList<T>::swap(int i, int j)
{
    do {if(!(i >= 0 && i < p.size() && j >= 0 && j < p.size()))qt_assert_x("QList<T>::swap", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",428);} while (0);
    detach();
    void *t = d->array[d->begin + i];
    d->array[d->begin + i] = d->array[d->begin + j];
    d->array[d->begin + j] = t;
}

template <typename T>
inline void QList<T>::move(int from, int to)
{
    do {if(!(from >= 0 && from < p.size() && to >= 0 && to < p.size()))qt_assert_x("QList<T>::move", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",439);} while (0);
    detach();
    p.move(from, to);
}

template<typename T>
inline QList<T> QList<T>::mid(int pos, int length) const
{
    if (length < 0)
        length = size() - pos;
    if (pos == 0 && length == size())
        return *this;
    QList<T> cpy;
    if (pos + length > size())
        length = size() - pos;
    for (int i = pos; i < pos + length; ++i)
        cpy += at(i);
    return cpy;
}

template<typename T>
inline T QList<T>::value(int i) const
{
    if (i < 0 || i >= p.size()) {
        return T();
    }
    return reinterpret_cast<Node *>(p.at(i))->t();
}
template<typename T>
inline T QList<T>::value(int i, const T& defaultValue) const
{
    return ((i < 0 || i >= p.size()) ? defaultValue : reinterpret_cast<Node *>(p.at(i))->t());
}

template <typename T>
inline void QList<T>::detach_helper()
{
    Node *n = reinterpret_cast<Node *>(p.begin());
    QListData::Data *x = p.detach();
    if (x)
        free(x);
    node_copy(reinterpret_cast<Node *>(p.begin()), reinterpret_cast<Node *>(p.end()), n);
}

template <typename T>
inline QList<T>::~QList()
{
    if (!d)
        return;
    QListData::Data *x = &QListData::shared_null;
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        free(x);
}

template <typename T>
inline bool QList<T>::operator==(const QList<T> &l) const
{
    if (p.size() != l.p.size())
        return false;
    if (d == l.d)
        return true;
    Node *i = reinterpret_cast<Node *>(p.end());
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *li = reinterpret_cast<Node *>(l.p.end());
    while (i != b) {
        --i; --li;
        if (!(i->t() == li->t()))
            return false;
    }
    return true;
}


template <typename T>
inline void QList<T>::free(QListData::Data *data)
{
    node_destruct(reinterpret_cast<Node *>(data->array + data->begin),
                  reinterpret_cast<Node *>(data->array + data->end));
    if (data->ref == 0)
        qFree(data);
}


template <typename T>
inline void QList<T>::clear()
{
    *this = QList<T>();
}

template <typename T>
inline int QList<T>::removeAll(const T &_t)
{
    detach();
    const T t = _t;
    int removedCount=0, i=0;
    Node *n;
    while (i < p.size())
        if ((n = reinterpret_cast<Node *>(p.at(i)))->t() == t) {
            node_destruct(n);
            p.remove(i);
            ++removedCount;
        } else {
            ++i;
        }
    return removedCount;
}

template <typename T>
inline typename QList<T>::iterator QList<T>::erase(typename QList<T>::iterator afirst,
                                                                 typename QList<T>::iterator alast)
{
    for (Node *n = afirst.i; n < alast.i; ++n)
        node_destruct(n);
    int idx = afirst - begin();
    p.remove(idx, alast - afirst);
    return begin() + idx;
}

template <typename T>
inline QList<T> &QList<T>::operator+=(const QList<T> &l)
{
    detach();
    Node *n = reinterpret_cast<Node *>(p.append(l.p));
    node_copy(n, reinterpret_cast<Node *>(p.end()), reinterpret_cast<Node *>(l.p.begin()));
    return *this;
}

template <typename T>
inline int QList<T>::indexOf(const T &t, int from) const
{
    if (from < 0)
        from = qMax(from + p.size(), 0);
    if (from < p.size()) {
        Node *n = reinterpret_cast<Node *>(p.at(from -1));
        Node *e = reinterpret_cast<Node *>(p.end());
        while (++n != e)
            if (n->t() == t)
                return n - reinterpret_cast<Node *>(p.begin());
    }
    return -1;
}

template <typename T>
inline int QList<T>::lastIndexOf(const T &t, int from) const
{
    if (from < 0)
        from += p.size();
    else if (from >= p.size())
        from = p.size()-1;
    if (from >= 0) {
        Node *b = reinterpret_cast<Node *>(p.begin());
        Node *n = reinterpret_cast<Node *>(p.at(from + 1));
        while (n-- != b) {
            if (n->t() == t)
                return n - b;
        }
    }
    return -1;
}

template <typename T>
inline QBool QList<T>::contains(const T &t) const
{
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *i = reinterpret_cast<Node *>(p.end());
    while (i-- != b)
        if (i->t() == t)
            return QBool(true);
    return QBool(false);
}

template <typename T>
inline int QList<T>::count(const T &t) const
{
    int c = 0;
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *i = reinterpret_cast<Node *>(p.end());
    while (i-- != b)
        if (i->t() == t)
            ++c;
    return c;
}

template <class T> class QListIterator { typedef typename QList<T>::const_iterator const_iterator; QList<T> c; const_iterator i; public: inline QListIterator(const QList<T> &container) : c(container), i(c.constBegin()) {} inline QListIterator &operator=(const QList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableListIterator { typedef typename QList<T>::iterator iterator; QList<T> *c; iterator i, n; inline bool item_exists() const { return n != c->constEnd(); } public: inline QMutableListIterator(QList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableListIterator() { c->setSharable(true); } inline QMutableListIterator &operator=(QList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != i; } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != i; } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != n) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != n) *n = t; } inline T &value() { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",624);} while (0); return *n; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlist.h",624);} while (0); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != (n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != i) if (*(n = --i) == t) return true; n = c->end(); return false; } };





typedef QtValidLicenseForCoreModule QtCoreModule;



class QTextCodec;
class QIODevice;

class QTextDecoder;
class QTextEncoder;

class __declspec(dllimport) QTextCodec
{
public:
    static QTextCodec* codecForName(const QByteArray &name);
    static QTextCodec* codecForName(const char *name) { return codecForName(QByteArray(name)); }
    static QTextCodec* codecForMib(int mib);

    static QList<QByteArray> availableCodecs();
    static QList<int> availableMibs();

    static QTextCodec* codecForLocale();
    static void setCodecForLocale(QTextCodec *c);

    static QTextCodec* codecForTr();
    static void setCodecForTr(QTextCodec *c);

    static QTextCodec* codecForCStrings();
    static void setCodecForCStrings(QTextCodec *c);

    QTextDecoder* makeDecoder() const;
    QTextEncoder* makeEncoder() const;

    bool canEncode(QChar) const;
    bool canEncode(const QString&) const;

    QString toUnicode(const QByteArray&) const;
    QString toUnicode(const char* chars) const;
    QByteArray fromUnicode(const QString& uc) const;
    enum ConversionFlag {
        DefaultConversion,
        ConvertInvalidToNull = 0x80000000,
        IgnoreHeader = 0x1
    };
    typedef QFlags<ConversionFlag> ConversionFlags;

    struct ConverterState {
        ConverterState(ConversionFlags f = DefaultConversion)
            : flags(f), remainingChars(0), invalidChars(0), d(0) { state_data[0] = state_data[1] = state_data[2] = 0; }
        ~ConverterState() { if (d) qFree(d); }
        ConversionFlags flags;
        int remainingChars;
        int invalidChars;
        uint state_data[3];
        void *d;
    };

    QString toUnicode(const char *in, int length, ConverterState *state = 0) const
        { return convertToUnicode(in, length, state); }
    QByteArray fromUnicode(const QChar *in, int length, ConverterState *state = 0) const
        { return convertFromUnicode(in, length, state); }

    virtual QByteArray name() const = 0;
    virtual QList<QByteArray> aliases() const;
    virtual int mibEnum() const = 0;

protected:
    virtual QString convertToUnicode(const char *in, int length, ConverterState *state) const = 0;
    virtual QByteArray convertFromUnicode(const QChar *in, int length, ConverterState *state) const = 0;

    QTextCodec();
    virtual ~QTextCodec();

public:










private:
    friend class QTextCodecCleanup;
    static QTextCodec *cftr;
};
inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QTextCodec::ConversionFlags::enum_type f2) { return QFlags<QTextCodec::ConversionFlags::enum_type>(f1) | f2; } inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QFlags<QTextCodec::ConversionFlags::enum_type> f2) { return f2 | f1; }

inline QTextCodec* QTextCodec::codecForTr() { return cftr; }
inline void QTextCodec::setCodecForTr(QTextCodec *c) { cftr = c; }
inline QTextCodec* QTextCodec::codecForCStrings() { return QString::codecForCStrings; }
inline void QTextCodec::setCodecForCStrings(QTextCodec *c) { QString::codecForCStrings = c; }

class __declspec(dllimport) QTextEncoder {
public:
    explicit QTextEncoder(const QTextCodec *codec) : c(codec) {}
    ~QTextEncoder();
    QByteArray fromUnicode(const QString& str);
    QByteArray fromUnicode(const QChar *uc, int len);



private:
    const QTextCodec *c;
    QTextCodec::ConverterState state;
};

class __declspec(dllimport) QTextDecoder {
public:
    explicit QTextDecoder(const QTextCodec *codec) : c(codec) {}
    ~QTextDecoder();
    QString toUnicode(const char* chars, int len);
    QString toUnicode(const QByteArray &ba);
private:
    const QTextCodec *c;
    QTextCodec::ConverterState state;
};


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QString;

class QByteArray;















































































































class QObject;
class QMetaMethod;
class QMetaEnum;
class QMetaProperty;
class QMetaClassInfo;


class __declspec(dllimport) QGenericArgument
{
public:
    inline QGenericArgument(const char *aName = 0, const void *aData = 0)
        : _data(aData), _name(aName) {}
    inline void *data() const { return const_cast<void *>(_data); }
    inline const char *name() const { return _name; }

private:
    const void *_data;
    const char *_name;
};

class __declspec(dllimport) QGenericReturnArgument: public QGenericArgument
{
public:
    inline QGenericReturnArgument(const char *aName = 0, void *aData = 0)
        : QGenericArgument(aName, aData)
        {}
};

template <class T>
class QArgument: public QGenericArgument
{
public:
    inline QArgument(const char *aName, const T &aData)
        : QGenericArgument(aName, static_cast<const void *>(&aData))
        {}
};


template<class T>
class QReturnArgument: public QGenericReturnArgument
{
public:
    inline QReturnArgument(const char *aName, T &aData)
        : QGenericReturnArgument(aName, static_cast<void *>(&aData))
        {}
};

struct __declspec(dllimport) QMetaObject
{
    const char *className() const;
    const QMetaObject *superClass() const;

    QObject *cast(QObject *obj) const;


    QString tr(const char *s, const char *c) const;
    QString trUtf8(const char *s, const char *c) const;


    int methodOffset() const;
    int enumeratorOffset() const;
    int propertyOffset() const;
    int classInfoOffset() const;

    int methodCount() const;
    int enumeratorCount() const;
    int propertyCount() const;
    int classInfoCount() const;

    int indexOfMethod(const char *method) const;
    int indexOfSignal(const char *signal) const;
    int indexOfSlot(const char *slot) const;
    int indexOfEnumerator(const char *name) const;
    int indexOfProperty(const char *name) const;
    int indexOfClassInfo(const char *name) const;

    QMetaMethod method(int index) const;
    QMetaEnum enumerator(int index) const;
    QMetaProperty property(int index) const;
    QMetaClassInfo classInfo(int index) const;

    static bool checkConnectArgs(const char *signal, const char *method);
    static QByteArray normalizedSignature(const char *method);


    static bool connect(const QObject *sender, int signal_index,
                        const QObject *receiver, int method_index,
                        int type = 0, int *types = 0);

    static bool disconnect(const QObject *sender, int signal_index,
                           const QObject *receiver, int method_index);

    static void connectSlotsByName(QObject *o);


    static void activate(QObject *sender, int signal_index, void **argv);
    static void activate(QObject *sender, int from_signal_index, int to_signal_index, void **argv);
    static void activate(QObject *sender, const QMetaObject *, int local_signal_index, void **argv);
    static void activate(QObject *sender, const QMetaObject *, int from_local_signal_index, int to_local_signal_index, void **argv);

    static void addGuard(QObject **ptr);
    static void removeGuard(QObject **ptr);
    static void changeGuard(QObject **ptr, QObject *o);

    static bool invokeMethod(QObject *obj, const char *member,
                             Qt::ConnectionType,
                             QGenericReturnArgument ret,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument());

    static inline bool invokeMethod(QObject *obj, const char *member,
                             QGenericReturnArgument ret,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, Qt::AutoConnection, ret, val0, val1, val2, val3,
                val4, val5, val6, val7, val8, val9);
    }

    static inline bool invokeMethod(QObject *obj, const char *member,
                             Qt::ConnectionType type,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, type, QGenericReturnArgument(), val0, val1, val2,
                                 val3, val4, val5, val6, val7, val8, val9);
    }


    static inline bool invokeMethod(QObject *obj, const char *member,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, Qt::AutoConnection, QGenericReturnArgument(), val0,
                val1, val2, val3, val4, val5, val6, val7, val8, val9);
    }

    enum Call {
        InvokeMetaMethod,
        ReadProperty,
        WriteProperty,
        ResetProperty,
        QueryPropertyDesignable,
        QueryPropertyScriptable,
        QueryPropertyStored,
        QueryPropertyEditable
    };





    struct {
        const QMetaObject *superdata;
        const char *stringdata;
        const uint *data;
        const QMetaObject **extradata;
    } d;
};

inline const char *QMetaObject::className() const
{ return d.stringdata; }

inline const QMetaObject *QMetaObject::superClass() const
{ return d.superdata; }






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QEvent;
class QTimerEvent;
class QChildEvent;
struct QMetaObject;
class QVariant;
class QObjectPrivate;
class QObject;
class QThread;
class QWidget;

class QRegExp;


class QObjectUserData;


typedef QList<QObject*> QObjectList;








template<typename T> inline T qFindChild(const QObject *, const QString & = QString());
template<typename T> inline QList<T> qFindChildren(const QObject *, const QString & = QString());

template<typename T> inline QList<T> qFindChildren(const QObject *, const QRegExp &);



class QObjectData {
public:
    virtual ~QObjectData() = 0;
    QObject *q_ptr;
    QObject *parent;
    QObjectList children;

    uint isWidget : 1;
    uint pendTimer : 1;
    uint blockSig : 1;
    uint wasDeleted : 1;
    uint ownObjectName : 1;
    uint sendChildEvents : 1;
    uint receiveChildEvents : 1;
    uint unused : 25;
    int postedEvents;



    int reserved;

};


class __declspec(dllimport) QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

    inline QObjectPrivate* d_func() { return reinterpret_cast<QObjectPrivate *>(d_ptr); } inline const QObjectPrivate* d_func() const { return reinterpret_cast<const QObjectPrivate *>(d_ptr); } friend class QObjectPrivate;

public:
    explicit QObject(QObject *parent=0);
    virtual ~QObject();

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);















    QString objectName() const;
    void setObjectName(const QString &name);

    inline bool isWidgetType() const { return d_ptr->isWidget; }

    inline bool signalsBlocked() const { return d_ptr->blockSig; }
    bool blockSignals(bool b);

    QThread *thread() const;
    void moveToThread(QThread *thread);

    int startTimer(int interval);
    void killTimer(int id);


    template<typename T>
    inline T findChild(const QString &name = QString()) const
    { return qFindChild<T>(this, name); }

    template<typename T>
    inline QList<T> findChildren(const QString &name = QString()) const
    { return qFindChildren<T>(this, name); }


    template<typename T>
    inline QList<T> findChildren(const QRegExp &re) const
    { return qFindChildren<T>(this, re); }











    inline const QObjectList &children() const { return d_ptr->children; }

    void setParent(QObject *);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);


    static bool connect(const QObject *sender, const char *signal,
                        const QObject *receiver, const char *member, Qt::ConnectionType =



                        Qt::AutoConnection

        );
    inline bool connect(const QObject *sender, const char *signal,
                        const char *member, Qt::ConnectionType type =



                        Qt::AutoConnection

        ) const;

    static bool disconnect(const QObject *sender, const char *signal,
                           const QObject *receiver, const char *member);
    inline bool disconnect(const char *signal = 0,
                           const QObject *receiver = 0, const char *member = 0)
        { return disconnect(this, signal, receiver, member); }
    inline bool disconnect(const QObject *receiver, const char *member = 0)
        { return disconnect(this, 0, receiver, member); }

    void dumpObjectTree();
    void dumpObjectInfo();


    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;



    static uint registerUserData();
    void setUserData(uint id, QObjectUserData* data);
    QObjectUserData* userData(uint id) const;


protected:
    void destroyed(QObject * = 0);

public:
    inline QObject *parent() const { return d_ptr->parent; }

    inline bool inherits(const char *classname) const
        { return const_cast<QObject *>(this)->qt_metacast(classname) != 0; }

public :
    void deleteLater();

protected:
    QObject *sender() const;
    int receivers(const char* signal) const;

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);

    virtual void connectNotify(const char *signal);
    virtual void disconnectNotify(const char *signal);
























protected:
    QObject(QObjectPrivate &dd, QObject *parent = 0);

protected:
    QObjectData *d_ptr;

    static const QMetaObject staticQtMetaObject;

    friend struct QMetaObject;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QCoreApplication;
    friend class QCoreApplicationPrivate;
    friend class QWidget;
    friend class QThreadData;

private:
    QObject(const QObject &); QObject &operator=(const QObject &);

};

inline bool QObject::connect(const QObject *asender, const char *asignal,
                             const char *amember, Qt::ConnectionType atype) const
{ return connect(asender, asignal, this, amember, atype); }


class __declspec(dllimport) QObjectUserData {
public:
    virtual ~QObjectUserData();
};



__declspec(dllimport) void qt_qFindChildren_helper(const QObject *parent, const QString &name, const QRegExp *re,
                         const QMetaObject &mo, QList<void*> *list);
__declspec(dllimport) QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo);







































































template<typename T>
inline T qFindChild(const QObject *o, const QString &name)
{ return static_cast<T>(qt_qFindChild_helper(o, name, reinterpret_cast<T>(0)->staticMetaObject)); }

template<typename T>
inline QList<T> qFindChildren(const QObject *o, const QString &name)
{
    QList<T> list;
    qt_qFindChildren_helper(o, name, 0, reinterpret_cast<T>(0)->staticMetaObject,
                         reinterpret_cast<QList<void *>*>(&list));
    return list;
}


template<typename T>
inline QList<T> qFindChildren(const QObject *o, const QRegExp &re)
{
    QList<T> list;
    qt_qFindChildren_helper(o, 0, &re, reinterpret_cast<T>(0)->staticMetaObject,
                        reinterpret_cast<QList<void*>*>(&list));
    return list;
}


template <class T>
inline T qobject_cast(QObject *object)
{ return static_cast<T>(reinterpret_cast<T>(0)->staticMetaObject.cast(object)); }

template <class T>
inline T qobject_cast(const QObject *object)
{ return static_cast<T>(const_cast<const QObject *>(reinterpret_cast<T>(0)->staticMetaObject.cast(const_cast<QObject *>(object)))); }











__declspec(dllimport) QDebug operator<<(QDebug, const QObject *);












































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QPointer
{
    QObject *o;
public:
    inline QPointer() : o(0) {}
    inline QPointer(T *p) : o(p)
        { QMetaObject::addGuard(&o); }
    inline QPointer(const QPointer<T> &p) : o(p.o)
        { QMetaObject::addGuard(&o); }
    inline ~QPointer()
        { QMetaObject::removeGuard(&o); }
    inline QPointer<T> &operator=(const QPointer<T> &p)
        { if (this != &p) QMetaObject::changeGuard(&o, p.o); return *this; }
    inline QPointer<T> &operator=(T* p)
        { if (o != p) QMetaObject::changeGuard(&o, p); return *this; }

    inline bool isNull() const
        { return !o; }

    inline T* operator->() const
        { return static_cast<T*>(const_cast<QObject*>(o)); }
    inline T& operator*() const
        { return *static_cast<T*>(const_cast<QObject*>(o)); }
    inline operator T*() const
        { return static_cast<T*>(const_cast<QObject*>(o)); }
};


template <class T>
inline bool operator==(const T *o, const QPointer<T> &p)
{ return o == p.operator->(); }


template<class T>
inline bool operator==(const QPointer<T> &p, const T *o)
{ return p.operator->() == o; }


template <class T>
inline bool operator==(T *o, const QPointer<T> &p)
{ return o == p.operator->(); }

template<class T>
inline bool operator==(const QPointer<T> &p, T *o)
{ return p.operator->() == o; }

template<class T>
inline bool operator==(const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() == p2.operator->(); }


template <class T>
inline bool operator!=(const T *o, const QPointer<T> &p)
{ return o != p.operator->(); }


template<class T>
inline bool operator!= (const QPointer<T> &p, const T *o)
{ return p.operator->() != o; }


template <class T>
inline bool operator!=(T *o, const QPointer<T> &p)
{ return o != p.operator->(); }

template<class T>
inline bool operator!= (const QPointer<T> &p, T *o)
{ return p.operator->() != o; }

template<class T>
inline bool operator!= (const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() != p2.operator->() ; }





typedef QtValidLicenseForCoreModule QtCoreModule;









typedef QObject *(*QtPluginInstanceFunction)();





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QIODevicePrivate;

class __declspec(dllimport) QIODevice

    : public QObject

{

    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    enum OpenModeFlag {
        NotOpen = 0x0000,
        ReadOnly = 0x0001,
        WriteOnly = 0x0002,
        ReadWrite = ReadOnly | WriteOnly,
        Append = 0x0004,
        Truncate = 0x0008,
        Text = 0x0010,
        Unbuffered = 0x0020
    };
    typedef QFlags<OpenModeFlag> OpenMode;

    QIODevice();

    explicit QIODevice(QObject *parent);

    virtual ~QIODevice();

    OpenMode openMode() const;

    void setTextModeEnabled(bool enabled);
    bool isTextModeEnabled() const;

    bool isOpen() const;
    bool isReadable() const;
    bool isWritable() const;
    virtual bool isSequential() const;

    virtual bool open(OpenMode mode);
    virtual void close();

    virtual qint64 pos() const;
    virtual qint64 size() const;
    virtual bool seek(qint64 pos);
    virtual bool atEnd() const;
    virtual bool reset();

    virtual qint64 bytesAvailable() const;
    virtual qint64 bytesToWrite() const;

    qint64 read(char *data, qint64 maxlen);
    QByteArray read(qint64 maxlen);
    QByteArray readAll();
    qint64 readLine(char *data, qint64 maxlen);
    QByteArray readLine(qint64 maxlen = 0);
    virtual bool canReadLine() const;

    qint64 write(const char *data, qint64 len);
    inline qint64 write(const QByteArray &data)
    { return write(data.constData(), data.size()); }

    qint64 peek(char *data, qint64 maxlen);
    QByteArray peek(qint64 maxlen);

    virtual bool waitForReadyRead(int msecs);
    virtual bool waitForBytesWritten(int msecs);

    void ungetChar(char c);
    inline bool putChar(char c) { return write(&c, 1) == 1; }
    inline bool getChar(char *c)
    { char ch; bool result = read(&ch, 1) == 1; if (c) *c = ch; return result; }

    QString errorString() const;


protected:
    void readyRead();
    void bytesWritten(qint64 bytes);
    void aboutToClose();


protected:



    QIODevice(QIODevicePrivate &dd, QObject *parent = 0);

    virtual qint64 readData(char *data, qint64 maxlen) = 0;
    virtual qint64 readLineData(char *data, qint64 maxlen);
    virtual qint64 writeData(const char *data, qint64 len) = 0;

    void setOpenMode(OpenMode openMode);

    void setErrorString(const QString &errorString);





private:
    inline QIODevicePrivate* d_func() { return reinterpret_cast<QIODevicePrivate *>(d_ptr); } inline const QIODevicePrivate* d_func() const { return reinterpret_cast<const QIODevicePrivate *>(d_ptr); } friend class QIODevicePrivate;
    QIODevice(const QIODevice &); QIODevice &operator=(const QIODevice &);


































};

inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QIODevice::OpenMode::enum_type f2) { return QFlags<QIODevice::OpenMode::enum_type>(f1) | f2; } inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QFlags<QIODevice::OpenMode::enum_type> f2) { return f2 | f1; }







































class QDebug;
__declspec(dllimport) QDebug operator<<(QDebug debug, QIODevice::OpenMode modes);














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QIODevice;

template <typename T> class QList;
template <typename T> class QLinkedList;
template <typename T> class QVector;
template <typename T> class QSet;
template <class Key, class T> class QHash;
template <class Key, class T> class QMap;

class QDataStreamPrivate;


class __declspec(dllimport) QDataStream
{
public:
    enum Version {
        Qt_1_0 = 1,
        Qt_2_0 = 2,
        Qt_2_1 = 3,
        Qt_3_0 = 4,
        Qt_3_1 = 5,
        Qt_3_3 = 6,
        Qt_4_0 = 7,
        Qt_4_1 = Qt_4_0



    };

    enum ByteOrder {
        BigEndian = QSysInfo::BigEndian,
        LittleEndian = QSysInfo::LittleEndian
    };




    enum Status {
        Ok,
        ReadPastEnd,
	ReadCorruptData
    };

    QDataStream();
    explicit QDataStream(QIODevice *);



    QDataStream(QByteArray *, QIODevice::OpenMode flags);
    QDataStream(const QByteArray &);
    virtual ~QDataStream();

    QIODevice *device() const;
    void setDevice(QIODevice *);
    void unsetDevice();

    bool atEnd() const;




    Status status() const;
    void setStatus(Status status);
    void resetStatus();

    ByteOrder byteOrder() const;
    void setByteOrder(ByteOrder);

    int version() const;
    void setVersion(int);

    QDataStream &operator>>(qint8 &i);
    QDataStream &operator>>(quint8 &i);
    QDataStream &operator>>(qint16 &i);
    QDataStream &operator>>(quint16 &i);
    QDataStream &operator>>(qint32 &i);
    QDataStream &operator>>(quint32 &i);
    QDataStream &operator>>(qint64 &i);
    QDataStream &operator>>(quint64 &i);

    QDataStream &operator>>(bool &i);
    QDataStream &operator>>(float &f);
    QDataStream &operator>>(double &f);
    QDataStream &operator>>(char *&str);

    QDataStream &operator<<(qint8 i);
    QDataStream &operator<<(quint8 i);
    QDataStream &operator<<(qint16 i);
    QDataStream &operator<<(quint16 i);
    QDataStream &operator<<(qint32 i);
    QDataStream &operator<<(quint32 i);
    QDataStream &operator<<(qint64 i);
    QDataStream &operator<<(quint64 i);
    QDataStream &operator<<(bool i);
    QDataStream &operator<<(float f);
    QDataStream &operator<<(double f);
    QDataStream &operator<<(const char *str);

    QDataStream &readBytes(char *&, uint &len);
    int readRawData(char *, int len);

    QDataStream &writeBytes(const char *, uint len);
    int writeRawData(const char *, int len);

    int skipRawData(int len);










private:
    QDataStream(const QDataStream &); QDataStream &operator=(const QDataStream &);

    QDataStreamPrivate *d;

    QIODevice *dev;
    bool owndev;
    bool noswap;
    ByteOrder byteorder;
    int ver;
    Status q_status;
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline QDataStream::ByteOrder QDataStream::byteOrder() const
{ return byteorder; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion(int v)
{ ver = v; }

inline QDataStream &QDataStream::operator>>(quint8 &i)
{ return *this >> reinterpret_cast<qint8&>(i); }

inline QDataStream &QDataStream::operator>>(quint16 &i)
{ return *this >> reinterpret_cast<qint16&>(i); }

inline QDataStream &QDataStream::operator>>(quint32 &i)
{ return *this >> reinterpret_cast<qint32&>(i); }

inline QDataStream &QDataStream::operator>>(quint64 &i)
{ return *this >> reinterpret_cast<qint64&>(i); }

inline QDataStream &QDataStream::operator<<(quint8 i)
{ return *this << qint8(i); }

inline QDataStream &QDataStream::operator<<(quint16 i)
{ return *this << qint16(i); }

inline QDataStream &QDataStream::operator<<(quint32 i)
{ return *this << qint32(i); }

inline QDataStream &QDataStream::operator<<(quint64 i)
{ return *this << qint64(i); }

template <typename T>
QDataStream& operator>>(QDataStream& s, QList<T>& l)
{
    l.clear();
    quint32 c;
    s >> c;
    for(quint32 i = 0; i < c; ++i)
    {
        T t;
        s >> t;
        l.append(t);
        if (s.atEnd())
            break;
    }
    return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QList<T>& l)
{
    s << quint32(l.size());
    for (int i = 0; i < l.size(); ++i)
        s << l.at(i);
    return s;
}

template <typename T>
QDataStream& operator>>(QDataStream& s, QLinkedList<T>& l)
{
    l.clear();
    quint32 c;
    s >> c;
    for(quint32 i = 0; i < c; ++i)
    {
        T t;
        s >> t;
        l.append(t);
        if (s.atEnd())
            break;
    }
    return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QLinkedList<T>& l)
{
    s << quint32(l.size());
    typename QLinkedList<T>::ConstIterator it = l.constBegin();
    for(; it != l.constEnd(); ++it)
        s << *it;
    return s;
}

template<typename T>
QDataStream& operator>>(QDataStream& s, QVector<T>& v)
{
    v.clear();
    quint32 c;
    s >> c;
    v.resize(c);
    for(quint32 i = 0; i < c; ++i) {
        T t;
        s >> t;
        v[i] = t;
    }
    return s;
}

template<typename T>
QDataStream& operator<<(QDataStream& s, const QVector<T>& v)
{
    s << quint32(v.size());
    const T* it = v.begin();
    for(; it != v.end(); ++it)
        s << *it;
    return s;
}

template <typename T>
QDataStream &operator>>(QDataStream &in, QSet<T> &set)
{
    set.clear();
    quint32 c;
    in >> c;
    for (quint32 i = 0; i < c; ++i) {
        T t;
        in >> t;
        set << t;
        if (in.atEnd())
            break;
    }
    return in;
}

template <typename T>
QDataStream& operator<<(QDataStream &out, const QSet<T> &set)
{
    out << quint32(set.size());
    typename QSet<T>::const_iterator i = set.constBegin();
    while (i != set.constEnd()) {
        out << *i;
        ++i;
    }
    return out;
}

template <class Key, class T>
inline QDataStream &operator>>(QDataStream &in, QHash<Key, T> &hash)
{
    QDataStream::Status oldStatus = in.status();
    in.resetStatus();
    hash.clear();

    quint32 n;
    in >> n;

    for (quint32 i = 0; i < n; ++i) {
        if (in.status() != QDataStream::Ok)
            break;

        Key k;
        T t;
        in >> k >> t;
        hash.insertMulti(k, t);
    }

    if (in.status() != QDataStream::Ok)
        hash.clear();
    if (oldStatus != QDataStream::Ok)
        in.setStatus(oldStatus);
    return in;
}

template <class Key, class T>
inline QDataStream &operator<<(QDataStream &out, const QHash<Key, T>& hash)
{
    out << quint32(hash.size());
    typename QHash<Key, T>::ConstIterator it = hash.end();
    typename QHash<Key, T>::ConstIterator begin = hash.begin();
    while (it != begin) {
        --it;
        out << it.key() << it.value();
    }
    return out;
}




template <class aKey, class aT>
inline QDataStream &operator>>(QDataStream &in, QMap<aKey, aT> &map)

{
    QDataStream::Status oldStatus = in.status();
    in.resetStatus();
    map.clear();

    quint32 n;
    in >> n;

    map.detach();

    map.d->insertInOrder = true;

    for (quint32 i = 0; i < n; ++i) {
        if (in.status() != QDataStream::Ok)
            break;

        aKey key;
        aT value;
        in >> key >> value;
        map.insertMulti(key, value);
    }

    map.d->insertInOrder = false;

    if (in.status() != QDataStream::Ok)
        map.clear();
    if (oldStatus != QDataStream::Ok)
        in.setStatus(oldStatus);
    return in;
}

template <class Key, class T>
inline QDataStream &operator<<(QDataStream &out, const QMap<Key, T> &map)
{
    out << quint32(map.size());
    typename QMap<Key, T>::ConstIterator it = map.end();
    typename QMap<Key, T>::ConstIterator begin = map.begin();
    while (it != begin) {
        --it;
        out << it.key() << it.value();
    }
    return out;
}


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

struct QRegExpPrivate;
class QStringList;

class __declspec(dllimport) QRegExp
{
public:
    enum PatternSyntax { RegExp, Wildcard };
    enum CaretMode { CaretAtZero, CaretAtOffset, CaretWontMatch };

    QRegExp();
    explicit QRegExp(const QString &pattern, Qt::CaseSensitivity cs = Qt::CaseSensitive,
		     PatternSyntax syntax = RegExp);
    QRegExp(const QRegExp &rx);
    ~QRegExp();
    QRegExp &operator=(const QRegExp &rx);

    bool operator==(const QRegExp &rx) const;
    inline bool operator!=(const QRegExp &rx) const { return !operator==(rx); }

    bool isEmpty() const;
    bool isValid() const;
    QString pattern() const;
    void setPattern(const QString &pattern);
    Qt::CaseSensitivity caseSensitivity() const;
    void setCaseSensitivity(Qt::CaseSensitivity cs);






    PatternSyntax patternSyntax() const;
    void setPatternSyntax(PatternSyntax syntax);







    bool isMinimal() const;
    void setMinimal(bool minimal);




    bool exactMatch(const QString &str) const;

    int indexIn(const QString &str, int offset = 0, CaretMode caretMode = CaretAtZero) const;
    int lastIndexIn(const QString &str, int offset = -1, CaretMode caretMode = CaretAtZero) const;








    int matchedLength() const;

    int numCaptures() const;
    QStringList capturedTexts();
    QString cap(int nth = 0);
    int pos(int nth = 0);
    QString errorString();


    static QString escape(const QString &str);










private:
    QRegExpPrivate *priv;
};
template <> class QTypeInfo<QRegExp> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegExp)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRegExp"; } };











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QStringMatcherPrivate;

class __declspec(dllimport) QStringMatcher
{
public:
    QStringMatcher();
    QStringMatcher(const QString &pattern,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QStringMatcher(const QStringMatcher &other);
    ~QStringMatcher();

    QStringMatcher &operator=(const QStringMatcher &other);

    void setPattern(const QString &pattern);
    void setCaseSensitivity(Qt::CaseSensitivity cs);

    int indexIn(const QString &str, int from = 0) const;
    inline QString pattern() const { return q_pattern; }
    inline Qt::CaseSensitivity caseSensitivity() const { return q_cs; }

private:
    QStringMatcherPrivate *d_ptr;
    QString q_pattern;
    Qt::CaseSensitivity q_cs;
    uint q_skiptable[256];
};









typedef QtValidLicenseForCoreModule QtCoreModule;

class QRegExp;

typedef QListIterator<QString> QStringListIterator;
typedef QMutableListIterator<QString> QMutableStringListIterator;

class QStringList : public QList<QString>
{
public:
    inline QStringList() { }
    inline explicit QStringList(const QString &i) { append(i); }
    inline QStringList(const QStringList &l) : QList<QString>(l) { }
    inline QStringList(const QList<QString> &l) : QList<QString>(l) { }

    inline void sort();

    inline QString join(const QString &sep) const;

    inline QStringList filter(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline QBool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline QStringList &replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

    inline QStringList operator+(const QStringList &other) const
    { QStringList n = *this; n += other; return n; }
    inline QStringList &operator<<(const QString &str)
    { append(str); return *this; }
    inline QStringList &operator<<(const QStringList &l)
    { *this += l; return *this; }


    inline QStringList filter(const QRegExp &rx) const;
    inline QStringList &replaceInStrings(const QRegExp &rx, const QString &after);
    inline int indexOf(const QRegExp &rx, int from = 0) const;
    inline int lastIndexOf(const QRegExp &rx, int from = -1) const;


    using QList<QString>::indexOf;
    using QList<QString>::lastIndexOf;
























};

namespace QtPrivate {
    void __declspec(dllimport) QStringList_sort(QStringList *that);
    QString __declspec(dllimport) QStringList_join(const QStringList *that, const QString &sep);
    QStringList __declspec(dllimport) QStringList_filter(const QStringList *that, const QString &str,
                                               Qt::CaseSensitivity cs);

    QBool __declspec(dllimport) QStringList_contains(const QStringList *that, const QString &str, Qt::CaseSensitivity cs);
    void __declspec(dllimport) QStringList_replaceInStrings(QStringList *that, const QString &before, const QString &after,
                                      Qt::CaseSensitivity cs);


    void __declspec(dllimport) QStringList_replaceInStrings(QStringList *that, const QRegExp &rx, const QString &after);
    QStringList __declspec(dllimport) QStringList_filter(const QStringList *that, const QRegExp &re);
    int __declspec(dllimport) QStringList_indexOf(const QStringList *that, const QRegExp &rx, int from);
    int __declspec(dllimport) QStringList_lastIndexOf(const QStringList *that, const QRegExp &rx, int from);

}

inline void QStringList::sort()
{
    QtPrivate::QStringList_sort(this);
}

inline QString QStringList::join(const QString &sep) const
{
    return QtPrivate::QStringList_join(this, sep);
}

inline QStringList QStringList::filter(const QString &str, Qt::CaseSensitivity cs) const
{
    return QtPrivate::QStringList_filter(this, str, cs);
}

inline QBool QStringList::contains(const QString &str, Qt::CaseSensitivity cs) const
{
    return QtPrivate::QStringList_contains(this, str, cs);
}

inline QStringList &QStringList::replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs)
{
    QtPrivate::QStringList_replaceInStrings(this, before, after, cs);
    return *this;
}


inline QStringList &QStringList::replaceInStrings(const QRegExp &rx, const QString &after)
{
    QtPrivate::QStringList_replaceInStrings(this, rx, after);
    return *this;
}

inline QStringList QStringList::filter(const QRegExp &rx) const
{
    return QtPrivate::QStringList_filter(this, rx);
}

inline int QStringList::indexOf(const QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}


































inline QDataStream &operator>>(QDataStream &in, QStringList &list)
{
    return operator>>(in, static_cast<QList<QString> &>(list));
}
inline QDataStream &operator<<(QDataStream &out, const QStringList &list)
{
    return operator<<(out, static_cast<const QList<QString> &>(list));
}






typedef QtValidLicenseForCoreModule QtCoreModule;

struct QFactoryInterface
{
    virtual ~QFactoryInterface() {}
    virtual QStringList keys() const = 0;
};

template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QFactoryInterface") : 0)); } template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(const QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QFactoryInterface") : 0)); }




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;



class QTextCodec;

struct __declspec(dllimport) QTextCodecFactoryInterface : public QFactoryInterface
{
    virtual QTextCodec *create(const QString &key) = 0;
};



template <> inline QTextCodecFactoryInterface *qobject_cast<QTextCodecFactoryInterface *>(QObject *object) { return reinterpret_cast<QTextCodecFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QTextCodecFactoryInterface") : 0)); } template <> inline QTextCodecFactoryInterface *qobject_cast<QTextCodecFactoryInterface *>(const QObject *object) { return reinterpret_cast<QTextCodecFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QTextCodecFactoryInterface") : 0)); }

class __declspec(dllimport) QTextCodecPlugin : public QObject, public QTextCodecFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QTextCodecPlugin(QObject *parent = 0);
    ~QTextCodecPlugin();

    virtual QList<QByteArray> names() const = 0;
    virtual QList<QByteArray> aliases() const = 0;
    virtual QTextCodec *createForName(const QByteArray &name) = 0;

    virtual QList<int> mibEnums() const = 0;
    virtual QTextCodec *createForMib(int mib) = 0;

private:
    QStringList keys() const;
    QTextCodec *create(const QString &name);
};



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;



class __declspec(dllimport) QLibraryInfo
{
public:
    static QString licensee();
    static QString licensedProducts();

    static QString buildKey();

    enum LibraryLocation
    {
        PrefixPath,
        DocumentationPath,
        HeadersPath,
        LibrariesPath,
        BinariesPath,
        PluginsPath,
        DataPath,
        TranslationsPath,
        SettingsPath,
        DemosPath,
        ExamplesPath
    };
    static QString location(LibraryLocation);

private:
    QLibraryInfo();
};


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractFileEngine;
class QFilePrivate;
class __declspec(dllimport) QFile : public QIODevice
{

    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

    inline QFilePrivate* d_func() { return reinterpret_cast<QFilePrivate *>(d_ptr); } inline const QFilePrivate* d_func() const { return reinterpret_cast<const QFilePrivate *>(d_ptr); } friend class QFilePrivate;

public:

    enum FileError {
        NoError = 0,
        ReadError = 1,
        WriteError = 2,
        FatalError = 3,
        ResourceError = 4,
        OpenError = 5,
        AbortError = 6,
        TimeOutError = 7,
        UnspecifiedError = 8,
        RemoveError = 9,
        RenameError = 10,
        PositionError = 11,
        ResizeError = 12,
        PermissionsError = 13,
        CopyError = 14



    };

    enum Permission {
        ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
        ReadUser  = 0x0400, WriteUser  = 0x0200, ExeUser  = 0x0100,
        ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
        ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
    };
    typedef QFlags<Permission> Permissions;

    QFile();
    QFile(const QString &name);

    explicit QFile(QObject *parent);
    QFile(const QString &name, QObject *parent);

    ~QFile();

    FileError error() const;
    void unsetError();

    QString fileName() const;
    void setFileName(const QString &name);

    typedef QByteArray (*EncoderFn)(const QString &fileName);
    typedef QString (*DecoderFn)(const QByteArray &localfileName);
    static QByteArray encodeName(const QString &fileName);
    static QString decodeName(const QByteArray &localFileName);
    inline static QString decodeName(const char *localFileName)
        { return decodeName(QByteArray(localFileName)); };
    static void setEncodingFunction(EncoderFn);
    static void setDecodingFunction(DecoderFn);

    bool exists() const;
    static bool exists(const QString &fileName);

    QString readLink() const;
    static QString readLink(const QString &fileName);

    bool remove();
    static bool remove(const QString &fileName);

    bool rename(const QString &newName);
    static bool rename(const QString &oldName, const QString &newName);

    bool link(const QString &newName);
    static bool link(const QString &oldname, const QString &newName);

    bool copy(const QString &newName);
    static bool copy(const QString &fileName, const QString &newName);

    bool isSequential() const;

    bool open(OpenMode flags);
    bool open(FILE *f, OpenMode flags);
    bool open(int fd, OpenMode flags);
    virtual void close();

    qint64 size() const;
    qint64 pos() const;
    bool seek(qint64 offset);
    bool atEnd() const;
    bool flush();

    bool resize(qint64 sz);
    static bool resize(const QString &filename, qint64 sz);

    Permissions permissions() const;
    static Permissions permissions(const QString &filename);
    bool setPermissions(Permissions permissionSpec);
    static bool setPermissions(const QString &filename, Permissions permissionSpec);

    int handle() const;

    virtual QAbstractFileEngine *fileEngine() const;









protected:



    QFile(QFilePrivate &dd, QObject *parent = 0);


    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);
    qint64 readLineData(char *data, qint64 maxlen);

private:
    QFile(const QFile &); QFile &operator=(const QFile &);
};

inline QFlags<QFile::Permissions::enum_type> operator|(QFile::Permissions::enum_type f1, QFile::Permissions::enum_type f2) { return QFlags<QFile::Permissions::enum_type>(f1) | f2; } inline QFlags<QFile::Permissions::enum_type> operator|(QFile::Permissions::enum_type f1, QFlags<QFile::Permissions::enum_type> f2) { return f2 | f1; }



























































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QDir;
class QDateTime;
class QFileInfoPrivate;

class __declspec(dllimport) QFileInfo
{
public:
    QFileInfo();
    QFileInfo(const QString &file);
    QFileInfo(const QFile &file);
    QFileInfo(const QDir &dir, const QString &file);
    QFileInfo(const QFileInfo &fileinfo);
    ~QFileInfo();

    QFileInfo &operator=(const QFileInfo &fileinfo);
    bool operator==(const QFileInfo &fileinfo);
    inline bool operator!=(const QFileInfo &fileinfo) { return !(operator==(fileinfo)); }

    void setFile(const QString &file);
    void setFile(const QFile &file);
    void setFile(const QDir &dir, const QString &file);
    bool exists() const;
    void refresh();

    QString filePath() const;
    QString absoluteFilePath() const;
    QString canonicalFilePath() const;
    QString fileName() const;
    QString baseName() const;
    QString completeBaseName() const;
    QString suffix() const;
    QString completeSuffix() const;

    QString path() const;
    QString absolutePath() const;
    QString canonicalPath() const;
    QDir dir() const;
    QDir absoluteDir() const;

    bool isReadable() const;
    bool isWritable() const;
    bool isExecutable() const;
    bool isHidden() const;

    bool isRelative() const;
    inline bool isAbsolute() const { return !isRelative(); }
    bool makeAbsolute();

    bool isFile() const;
    bool isDir() const;
    bool isSymLink() const;
    bool isRoot() const;

    QString readLink() const;

    QString owner() const;
    uint ownerId() const;
    QString group() const;
    uint groupId() const;

    bool permission(QFile::Permissions permissions) const;
    QFile::Permissions permissions() const;

    qint64 size() const;

    QDateTime created() const;
    QDateTime lastModified() const;
    QDateTime lastRead() const;

    void detach();

    bool caching() const;
    void setCaching(bool on);



































protected:
    QFileInfoPrivate *d_ptr;
private:
    inline QFileInfoPrivate* d_func() { return reinterpret_cast<QFileInfoPrivate *>(d_ptr); } inline const QFileInfoPrivate* d_func() const { return reinterpret_cast<const QFileInfoPrivate *>(d_ptr); } friend class QFileInfoPrivate;
};
template <> class QTypeInfo<QFileInfo> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFileInfo)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QFileInfo"; } };





typedef QList<QFileInfo> QFileInfoList;























































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QDirPrivate;

class __declspec(dllimport) QDir
{
protected:
    QDirPrivate *d_ptr;
private:
    inline QDirPrivate* d_func() { return reinterpret_cast<QDirPrivate *>(d_ptr); } inline const QDirPrivate* d_func() const { return reinterpret_cast<const QDirPrivate *>(d_ptr); } friend class QDirPrivate;
public:
    enum Filter { Dirs        = 0x001,
                  Files       = 0x002,
                  Drives      = 0x004,
                  NoSymLinks  = 0x008,
                  TypeMask    = 0x00f,




                  Readable    = 0x010,
                  Writable    = 0x020,
                  Executable  = 0x040,
                  PermissionMask    = 0x070,




                  Modified    = 0x080,
                  Hidden      = 0x100,
                  System      = 0x200,
                  AccessMask  = 0x3F0,

                  AllDirs       = 0x400,
                  CaseSensitive = 0x800,

                  NoFilter = -1



    };
    typedef QFlags<Filter> Filters;




    enum SortFlag { Name        = 0x00,
                    Time        = 0x01,
                    Size        = 0x02,
                    Unsorted    = 0x03,
                    SortByMask  = 0x03,

                    DirsFirst   = 0x04,
                    Reversed    = 0x08,
                    IgnoreCase  = 0x10,
                    DirsLast    = 0x20,
                    LocaleAware = 0x40,
                    Type        = 0x80,
                    NoSort = -1



    };
    typedef QFlags<SortFlag> SortFlags;

    QDir(const QDir &);
    QDir(const QString &path = QString());
    QDir(const QString &path, const QString &nameFilter,
         SortFlags sort = SortFlags(Name | IgnoreCase), Filters filter = TypeMask);
    ~QDir();

    QDir &operator=(const QDir &);
    QDir &operator=(const QString &path);

    void setPath(const QString &path);
    QString path() const;
    QString absolutePath() const;
    QString canonicalPath() const;

    static void addResourceSearchPath(const QString &path);

    QString dirName() const;
    QString filePath(const QString &fileName) const;
    QString absoluteFilePath(const QString &fileName) const;
    QString relativeFilePath(const QString &fileName) const;

    static QString convertSeparators(const QString &pathName);

    bool cd(const QString &dirName);
    bool cdUp();

    QStringList nameFilters() const;
    void setNameFilters(const QStringList &nameFilters);

    Filters filter() const;
    void setFilter(Filters filter);
    SortFlags sorting() const;
    void setSorting(SortFlags sort);

    uint count() const;
    QString operator[](int) const;

    static QStringList nameFiltersFromString(const QString &nameFilter);

    QStringList entryList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
    QStringList entryList(const QStringList &nameFilters, Filters filters = NoFilter,
                          SortFlags sort = NoSort) const;

    QFileInfoList entryInfoList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
    QFileInfoList entryInfoList(const QStringList &nameFilters, Filters filters = NoFilter,
                                SortFlags sort = NoSort) const;

    bool mkdir(const QString &dirName) const;
    bool rmdir(const QString &dirName) const;
    bool mkpath(const QString &dirPath) const;
    bool rmpath(const QString &dirPath) const;

    bool isReadable() const;
    bool exists() const;
    bool isRoot() const;

    static bool isRelativePath(const QString &path);
    inline static bool isAbsolutePath(const QString &path) { return !isRelativePath(path); }
    bool isRelative() const;
    inline bool isAbsolute() const { return !isRelative(); }
    bool makeAbsolute();

    bool operator==(const QDir &dir) const;
    inline bool operator!=(const QDir &dir) const {  return !operator==(dir); }

    bool remove(const QString &fileName);
    bool rename(const QString &oldName, const QString &newName);
    bool exists(const QString &name) const;

    static QFileInfoList drives();

    static QChar separator();

    static bool setCurrent(const QString &path);
    static inline QDir current() { return QDir(currentPath()); }
    static QString currentPath();

    static inline QDir home() { return QDir(homePath()); }
    static QString homePath();
    static inline QDir root() { return QDir(rootPath()); }
    static QString rootPath();
    static inline QDir temp() { return QDir(tempPath()); }
    static QString tempPath();


    static bool match(const QStringList &filters, const QString &fileName);
    static bool match(const QString &filter, const QString &fileName);

    static QString cleanPath(const QString &path);
    void refresh() const;





































};

inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QDir::Filters::enum_type f2) { return QFlags<QDir::Filters::enum_type>(f1) | f2; } inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QFlags<QDir::Filters::enum_type> f2) { return f2 | f1; }
inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QDir::SortFlags::enum_type f2) { return QFlags<QDir::SortFlags::enum_type>(f1) | f2; } inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QFlags<QDir::SortFlags::enum_type> f2) { return f2 | f1; }









typedef QtValidLicenseForCoreModule QtCoreModule;

class QFileExtension;
class QFileExtensionResult;
class QVariant;

class QAbstractFileEngineIterator;
class QAbstractFileEnginePrivate;
class __declspec(dllimport) QAbstractFileEngine
{
public:
    enum FileFlag {

        ReadOwnerPerm = 0x4000, WriteOwnerPerm = 0x2000, ExeOwnerPerm = 0x1000,
        ReadUserPerm  = 0x0400, WriteUserPerm  = 0x0200, ExeUserPerm  = 0x0100,
        ReadGroupPerm = 0x0040, WriteGroupPerm = 0x0020, ExeGroupPerm = 0x0010,
        ReadOtherPerm = 0x0004, WriteOtherPerm = 0x0002, ExeOtherPerm = 0x0001,


        LinkType      = 0x10000,
        FileType      = 0x20000,
        DirectoryType = 0x40000,


        HiddenFlag     = 0x0100000,
        LocalDiskFlag  = 0x0200000,
        ExistsFlag     = 0x0400000,
        RootFlag       = 0x0800000,


        PermsMask  = 0x0000FFFF,
        TypesMask  = 0x000F0000,
        FlagsMask  = 0x0FF00000,
        FileInfoAll = FlagsMask | PermsMask | TypesMask
    };
    typedef QFlags<FileFlag> FileFlags;

    enum FileName {
        DefaultName,
        BaseName,
        PathName,
        AbsoluteName,
        AbsolutePathName,
        LinkName,
        CanonicalName,
        CanonicalPathName
    };
    enum FileOwner {
        OwnerUser,
        OwnerGroup
    };
    enum FileTime {
        CreationTime,
        ModificationTime,
        AccessTime
    };

    virtual ~QAbstractFileEngine();

    virtual bool open(QIODevice::OpenMode openMode);
    virtual bool close();
    virtual bool flush();
    virtual qint64 size() const;
    virtual qint64 pos() const;
    virtual bool seek(qint64 pos);
    virtual bool isSequential() const;
    virtual bool remove();
    virtual bool copy(const QString &newName);
    virtual bool rename(const QString &newName);
    virtual bool link(const QString &newName);
    virtual bool mkdir(const QString &dirName, bool createParentDirectories) const;
    virtual bool rmdir(const QString &dirName, bool recurseParentDirectories) const;
    virtual bool setSize(qint64 size);
    virtual bool caseSensitive() const;
    virtual bool isRelativePath() const;
    virtual QStringList entryList(QDir::Filters filters, const QStringList &filterNames) const;
    virtual FileFlags fileFlags(FileFlags type=FileInfoAll) const;
    virtual bool setPermissions(uint perms);
    virtual QString fileName(FileName file=DefaultName) const;
    virtual uint ownerId(FileOwner) const;
    virtual QString owner(FileOwner) const;
    virtual QDateTime fileTime(FileTime time) const;
    virtual void setFileName(const QString &file);
    virtual int handle() const;

    typedef QAbstractFileEngineIterator Iterator;
    virtual Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames);
    virtual Iterator *endEntryList();

    virtual qint64 read(char *data, qint64 maxlen);
    virtual qint64 readLine(char *data, qint64 maxlen);
    virtual qint64 write(const char *data, qint64 len);

    QFile::FileError error() const;
    QString errorString() const;

    enum Extension {
    };
    class ExtensionOption
    {};
    class ExtensionReturn
    {};
    virtual bool extension(Extension extension, const ExtensionOption *option = 0, ExtensionReturn *output = 0);
    virtual bool supportsExtension(Extension extension) const;


    static QAbstractFileEngine *create(const QString &fileName);

protected:
    void setError(QFile::FileError error, const QString &str);

    QAbstractFileEngine();
    QAbstractFileEngine(QAbstractFileEnginePrivate &);

    QAbstractFileEnginePrivate *d_ptr;
private:
    inline QAbstractFileEnginePrivate* d_func() { return reinterpret_cast<QAbstractFileEnginePrivate *>(d_ptr); } inline const QAbstractFileEnginePrivate* d_func() const { return reinterpret_cast<const QAbstractFileEnginePrivate *>(d_ptr); } friend class QAbstractFileEnginePrivate;
};

inline QFlags<QAbstractFileEngine::FileFlags::enum_type> operator|(QAbstractFileEngine::FileFlags::enum_type f1, QAbstractFileEngine::FileFlags::enum_type f2) { return QFlags<QAbstractFileEngine::FileFlags::enum_type>(f1) | f2; } inline QFlags<QAbstractFileEngine::FileFlags::enum_type> operator|(QAbstractFileEngine::FileFlags::enum_type f1, QFlags<QAbstractFileEngine::FileFlags::enum_type> f2) { return f2 | f1; }

class __declspec(dllimport) QAbstractFileEngineHandler
{
public:
    QAbstractFileEngineHandler();
    virtual ~QAbstractFileEngineHandler();
    virtual QAbstractFileEngine *create(const QString &fileName) const = 0;
};









































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QObject;
class QBufferPrivate;

class __declspec(dllimport) QBuffer : public QIODevice
{

    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:


public:

     explicit QBuffer(QObject *parent = 0);
     QBuffer(QByteArray *buf, QObject *parent = 0);




    ~QBuffer();

    QByteArray &buffer();
    const QByteArray &buffer() const;
    void setBuffer(QByteArray *a);

    void setData(const QByteArray &data);
    inline void setData(const char *data, int len);
    const QByteArray &data() const;

    bool open(OpenMode openMode);

    void close();
    qint64 size() const;
    qint64 pos() const;
    bool seek(qint64 off);
    bool atEnd() const;
    bool canReadLine() const;

protected:
    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);

private:
    inline QBufferPrivate* d_func() { return reinterpret_cast<QBufferPrivate *>(d_ptr); } inline const QBufferPrivate* d_func() const { return reinterpret_cast<const QBufferPrivate *>(d_ptr); } friend class QBufferPrivate;
    QBuffer(const QBuffer &); QBuffer &operator=(const QBuffer &);


};

inline void QBuffer::setData(const char *adata, int alen)
{ setData(QByteArray(adata, alen)); }



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#pragma once




#pragma once






#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable:4127)
namespace std {


template<class _Traits>
	class _Tree_nod
		: public _Traits
	{
protected:
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_type value_type;

	struct _Node;
	friend struct _Node;
	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Genptr;

	struct _Node
		{
		_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg,
			const value_type& _Val, char _Carg)
			: _Left(_Larg), _Parent(_Parg), _Right(_Rarg),
				_Myval(_Val), _Color(_Carg), _Isnil(false)
			{
			}

		_Genptr _Left;
		_Genptr _Parent;
		_Genptr _Right;
		value_type _Myval;
		char _Color;
		char _Isnil;
		};

	_Tree_nod(const key_compare& _Parg,
		allocator_type _Al)
		: _Traits(_Parg), _Alnod(_Al)
		{
		}

	typename allocator_type::template rebind<_Node>::other
		_Alnod;
	};


template<class _Traits>
	class _Tree_ptr
		: public _Tree_nod<_Traits>
	{
protected:
	typedef typename _Tree_nod<_Traits>::_Node _Node;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Nodeptr;

	_Tree_ptr(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{
		}

	typename allocator_type::template rebind<_Nodeptr>::other
		_Alptr;
	};


template<class _Traits>
	class _Tree_val
		: public _Tree_ptr<_Traits>
	{
protected:
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_val(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{
		}

	allocator_type _Alval;
	};


template<class _Traits>
	class _Tree
		: public _Tree_val<_Traits>
	{
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_val<_Traits> _Mybase;
	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_compare value_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::_ITptr _ITptr;
	typedef typename _Traits::_IReft _IReft;

protected:
	typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;
	typedef typename _Tree_nod<_Traits>::_Node _Node;

	enum _Redbl
		{
		_Red, _Black};
	typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
	typedef typename allocator_type::template rebind<_Nodeptr>::other::reference _Nodepref;
	typedef typename allocator_type::template rebind<key_type>::other::const_reference _Keyref;
	typedef typename allocator_type::template rebind<char>::other::reference _Charref;
	typedef typename allocator_type::template rebind<value_type>::other::reference _Vref;

	static _Charref _Color(_Nodeptr _Pnode)
		{
		return ((_Charref)(*_Pnode)._Color);
		}

	static _Charref _Isnil(_Nodeptr _Pnode)
		{
		return ((_Charref)(*_Pnode)._Isnil);
		}

	static _Keyref _Key(_Nodeptr _Pnode)
		{
		return (_Mybase::_Kfn(_Myval(_Pnode)));
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{
		return ((_Nodepref)(*_Pnode)._Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{
		return ((_Nodepref)(*_Pnode)._Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{
		return ((_Nodepref)(*_Pnode)._Right);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef typename allocator_type::size_type size_type;
	typedef typename allocator_type::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename allocator_type::template rebind<value_type>::other::pointer _Tptr;
	typedef typename allocator_type::template rebind<value_type>::other::const_pointer _Ctptr;
	typedef typename allocator_type::template rebind<value_type>::other::reference _Reft;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef _Reft reference;
	typedef typename allocator_type::template rebind<value_type>::other::const_reference
		const_reference;


	class const_iterator;
	friend class const_iterator;

	class const_iterator
		: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
	{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		const_iterator()
			: _Ptr(0)
			{
			}

		const_iterator(_Nodeptr _Pnode)
			: _Ptr(_Pnode)
			{
			}

		const_reference operator*() const
			{
			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{
			return (&**this);
			}

		const_iterator& operator++()
			{
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _Right) const
			{
			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const const_iterator& _Right) const
			{
			return (!(*this == _Right));
			}

		void _Dec()
			{
			if (_Isnil(_Ptr))
				_Ptr = _Right(_Ptr);
			else if (!_Isnil(_Left(_Ptr)))
				_Ptr = _Max(_Left(_Ptr));
			else
				{
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Left(_Pnode))
					_Ptr = _Pnode;
				if (!_Isnil(_Pnode))
					_Ptr = _Pnode;
				}
			}

		void _Inc()
			{
			if (_Isnil(_Ptr))
				;
			else if (!_Isnil(_Right(_Ptr)))
				_Ptr = _Min(_Right(_Ptr));
			else
				{
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Right(_Pnode))
					_Ptr = _Pnode;
				_Ptr = _Pnode;
				}
			}

		_Nodeptr _Mynode() const
			{
			return (_Ptr);
			}

	protected:
		_Nodeptr _Ptr;
		};


	class iterator;
	friend class iterator;

	class iterator
		: public const_iterator
	{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _ITptr pointer;
		typedef _IReft reference;

		iterator()
			: const_iterator(0)
			{
			}

		iterator(_Nodeptr _Pnode)
			: const_iterator(_Pnode)
			{
			}

		reference operator*() const
			{
			return (_Myval(_Ptr));
			}

		pointer operator->() const
			{
			return (&**this);
			}

		iterator& operator++()
			{
			_Inc();
			return (*this);
			}

		iterator operator++(int)
			{
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{
			_Dec();
			return (*this);
			}

		iterator operator--(int)
			{
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	explicit _Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{
		_Init();
		}

	_Tree(const value_type *_First, const value_type *_Last,
		const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{
		_Init();
		try {
		insert(_First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(const _Myt& _Right)
		: _Mybase(_Right.key_comp(), _Right.get_allocator())
		{
		_Init();
		try {
		_Copy(_Right);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	~_Tree()
		{
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{
		if (this != &_Right)
			{
			erase(begin(), end());
			this->comp = _Right.comp;
			_Copy(_Right);
			}
		return (*this);
		}

	iterator begin()
		{
		return (iterator(_Lmost()));
		}

	const_iterator begin() const
		{
		return (const_iterator(_Lmost()));
		}

	iterator end()
		{
		return (iterator(_Myhead));
		}

	const_iterator end() const
		{
		return (const_iterator(_Myhead));
		}

	reverse_iterator rbegin()
		{
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{
		return (const_reverse_iterator(begin()));
		}

	size_type size() const
		{
		return (_Mysize);
		}

	size_type max_size() const
		{
		return (this->_Alval.max_size());
		}

	bool empty() const
		{
		return (size() == 0);
		}

	allocator_type get_allocator() const
		{
		return (this->_Alval);
		}

	key_compare key_comp() const
		{
		return (this->comp);
		}

	value_compare value_comp() const
		{
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = _Myhead;
		bool _Addleft = true;
		while (!_Isnil(_Trynode))
			{
			_Wherenode = _Trynode;
			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
		else
			{
			iterator _Where = iterator(_Wherenode);
			if (!_Addleft)
				;
			else if (_Where == begin())
				return (_Pairib(_Insert(true, _Wherenode, _Val), true));
			else
				--_Where;

			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
			else
				return (_Pairib(_Where, false));
			}
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{
		iterator _Next;

		if (size() == 0)
			return (_Insert(true, _Myhead, _Val));
		else if (this->_Multi)
			{
			if (_Where == begin())
				{
				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{
				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
				&& !this->comp(this->_Kfn(_Val),
					_Key((--(_Next = _Where))._Mynode())))
				{
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
				&& (++(_Next = _Where) == end()
					|| !this->comp(_Key(_Next._Mynode()),
						this->_Kfn(_Val))))
				{
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
		else
			{
			if (_Where == begin())
				{
				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{
				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
					this->_Kfn(_Val)))
				{
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
				&& (++(_Next = _Where) == end()
					|| this->comp(this->_Kfn(_Val),
						_Key(_Next._Mynode()))))
				{
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}

		return (insert(_Val).first);
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator erase(iterator _Where)
		{
		if (_Isnil(_Where._Mynode()))
			throw out_of_range("invalid map/set<T> iterator");
		_Nodeptr _Fixnode;
		_Nodeptr _Fixnodeparent;
		_Nodeptr _Erasednode = _Where._Mynode();
		_Nodeptr _Pnode = _Erasednode;
		++_Where;

		if (_Isnil(_Left(_Pnode)))
			_Fixnode = _Right(_Pnode);
		else if (_Isnil(_Right(_Pnode)))
			_Fixnode = _Left(_Pnode);
		else
			{
			_Pnode = _Where._Mynode();
			_Fixnode = _Right(_Pnode);
			}

		if (_Pnode == _Erasednode)
			{
			_Fixnodeparent = _Parent(_Erasednode);
			if (!_Isnil(_Fixnode))
				_Parent(_Fixnode) = _Fixnodeparent;

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;
			else if (_Left(_Fixnodeparent) == _Erasednode)
				_Left(_Fixnodeparent) = _Fixnode;
			else
				_Right(_Fixnodeparent) = _Fixnode;

			if (_Lmost() == _Erasednode)
				_Lmost() = _Isnil(_Fixnode)
					? _Fixnodeparent
					: _Min(_Fixnode);

			if (_Rmost() == _Erasednode)
				_Rmost() = _Isnil(_Fixnode)
					? _Fixnodeparent
					: _Max(_Fixnode);
			}
		else
			{
			_Parent(_Left(_Erasednode)) = _Pnode;
			_Left(_Pnode) = _Left(_Erasednode);

			if (_Pnode == _Right(_Erasednode))
				_Fixnodeparent = _Pnode;
			else
				{
				_Fixnodeparent = _Parent(_Pnode);
				if (!_Isnil(_Fixnode))
					_Parent(_Fixnode) = _Fixnodeparent;
				_Left(_Fixnodeparent) = _Fixnode;
				_Right(_Pnode) = _Right(_Erasednode);
				_Parent(_Right(_Erasednode)) = _Pnode;
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;
			else if (_Left(_Parent(_Erasednode)) == _Erasednode)
				_Left(_Parent(_Erasednode)) = _Pnode;
			else
				_Right(_Parent(_Erasednode)) = _Pnode;

			_Parent(_Pnode) = _Parent(_Erasednode);
			std::swap(_Color(_Pnode), _Color(_Erasednode));
			}

		if (_Color(_Erasednode) == _Black)
			{
			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
				_Fixnodeparent = _Parent(_Fixnode))
				if (_Fixnode == _Left(_Fixnodeparent))
					{
					_Pnode = _Right(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = _Right(_Fixnodeparent);
						}

					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;
					else if (_Color(_Left(_Pnode)) == _Black
						&& _Color(_Right(_Pnode)) == _Black)
						{
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{
						if (_Color(_Right(_Pnode)) == _Black)
							{
							_Color(_Left(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Rrotate(_Pnode);
							_Pnode = _Right(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Right(_Pnode)) = _Black;
						_Lrotate(_Fixnodeparent);
						break;
						}
					}
				else
					{
					_Pnode = _Left(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = _Left(_Fixnodeparent);
						}
					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;
					else if (_Color(_Right(_Pnode)) == _Black
						&& _Color(_Left(_Pnode)) == _Black)
						{
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{
						if (_Color(_Left(_Pnode)) == _Black)
							{
							_Color(_Right(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Lrotate(_Pnode);
							_Pnode = _Left(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Left(_Pnode)) = _Black;
						_Rrotate(_Fixnodeparent);
						break;
						}
					}

			_Color(_Fixnode) = _Black;
			}

		this->_Alnod.destroy(_Erasednode);
		this->_Alnod.deallocate(_Erasednode, 1);

		if (0 < _Mysize)
			--_Mysize;

		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{
		if (_First == begin() && _Last == end())
			{
			clear();
			return (begin());
			}
		else
			{
			while (_First != _Last)
				erase(_First++);
			return (_First);
			}
		}

	size_type erase(const key_type& _Keyval)
		{
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void erase(const key_type *_First, const key_type *_Last)
		{
		while (_First != _Last)
			erase(*_First++);
		}

	void clear()
		{
		_Erase(_Root());
		_Root() = _Myhead, _Mysize = 0;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		}

	iterator find(const key_type& _Keyval)
		{
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
			? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
			? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{
		return (iterator(_Lbound(_Keyval)));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{
		return (const_iterator(_Lbound(_Keyval)));
		}

	iterator upper_bound(const key_type& _Keyval)
		{
		return (iterator(_Ubound(_Keyval)));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{
		return (const_iterator(_Ubound(_Keyval)));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{
		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{
		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	void swap(_Myt& _Right)
		{
		if (get_allocator() == _Right.get_allocator())
			{
			std::swap(this->comp, _Right.comp);
			std::swap(_Myhead, _Right._Myhead);
			std::swap(_Mysize, _Right._Mysize);
			}
		else
			{
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

protected:
	void _Copy(const _Myt& _Right)
		{
		_Root() = _Copy(_Right._Root(), _Myhead);
		_Mysize = _Right.size();
		if (!_Isnil(_Root()))
			{
			_Lmost() = _Min(_Root());
			_Rmost() = _Max(_Root());
			}
		else
			_Lmost() = _Myhead, _Rmost() = _Myhead;
		}

	_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
		{
		_Nodeptr _Newroot = _Myhead;

		if (!_Isnil(_Rootnode))
			{
			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
				_Myval(_Rootnode), _Color(_Rootnode));
			if (_Isnil(_Newroot))
				_Newroot = _Pnode;

			try {
			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);
			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);
			} catch (...) {
			_Erase(_Newroot);
			throw;
			}
			}

		return (_Newroot);
		}

	void _Erase(_Nodeptr _Rootnode)
		{
		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)
			{
			_Erase(_Right(_Pnode));
			_Pnode = _Left(_Pnode);
			this->_Alnod.destroy(_Rootnode);
			this->_Alnod.deallocate(_Rootnode, 1);
			}
		}

	void _Init()
		{
		_Myhead = _Buynode();
		_Isnil(_Myhead) = true;
		_Root() = _Myhead;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		_Mysize = 0;
		}

	iterator _Insert(bool _Addleft, _Nodeptr _Wherenode,
		const value_type& _Val)
		{
		if (max_size() - 1 <= _Mysize)
			throw length_error("map/set<T> too long");
		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
			_Val, _Red);

		++_Mysize;
		if (_Wherenode == _Myhead)
			{
			_Root() = _Newnode;
			_Lmost() = _Newnode, _Rmost() = _Newnode;
			}
		else if (_Addleft)
			{
			_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{
			_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )
			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))
				{
				_Wherenode = _Right(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{
					if (_Pnode == _Right(_Parent(_Pnode)))
						{
						_Pnode = _Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
					}
				}
			else
				{
				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{
					if (_Pnode == _Left(_Parent(_Pnode)))
						{
						_Pnode = _Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
					}
				}

		_Color(_Root()) = _Black;
		return (iterator(_Newnode));
		}

	_Nodeptr _Lbound(const key_type& _Keyval) const
		{
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;

		while (!_Isnil(_Pnode))
			if (this->comp(_Key(_Pnode), _Keyval))
				_Pnode = _Right(_Pnode);
			else
				{
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);
				}

		return (_Wherenode);
		}

	_Nodeptr& _Lmost()
		{
		return (_Left(_Myhead));
		}

	_Nodeptr& _Lmost() const
		{
		return (_Left(_Myhead));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{
		_Nodeptr _Pnode = _Right(_Wherenode);
		_Right(_Wherenode) = _Left(_Pnode);

		if (!_Isnil(_Left(_Pnode)))
			_Parent(_Left(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Left(_Parent(_Wherenode)))
			_Left(_Parent(_Wherenode)) = _Pnode;
		else
			_Right(_Parent(_Wherenode)) = _Pnode;

		_Left(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr& _Rmost()
		{
		return (_Right(_Myhead));
		}

	_Nodeptr& _Rmost() const
		{
		return (_Right(_Myhead));
		}

	_Nodeptr& _Root()
		{
		return (_Parent(_Myhead));
		}

	_Nodeptr& _Root() const
		{
		return (_Parent(_Myhead));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{
		_Nodeptr _Pnode = _Left(_Wherenode);
		_Left(_Wherenode) = _Right(_Pnode);

		if (!_Isnil(_Right(_Pnode)))
			_Parent(_Right(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Right(_Parent(_Wherenode)))
			_Right(_Parent(_Wherenode)) = _Pnode;
		else
			_Left(_Parent(_Wherenode)) = _Pnode;

		_Right(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr _Ubound(const key_type& _Keyval) const
		{
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;

		while (!_Isnil(_Pnode))
			if (this->comp(_Keyval, _Key(_Pnode)))
				{
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);
				}
			else
				_Pnode = _Right(_Pnode);

		return (_Wherenode);
		}

	_Nodeptr _Buynode()
		{
		_Nodeptr _Wherenode = this->_Alnod.allocate(1, (void *)0);
		int _Linkcnt = 0;

		try {
		this->_Alptr.construct(&_Left(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Parent(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Right(_Wherenode), 0);
		} catch (...) {
		if (1 < _Linkcnt)
			this->_Alptr.destroy(&_Parent(_Wherenode));
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Left(_Wherenode));
		this->_Alnod.deallocate(_Wherenode, 1);
		throw;
		}
		_Color(_Wherenode) = _Black;
		_Isnil(_Wherenode) = false;
		return (_Wherenode);
		}

	_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg, _Nodeptr _Rarg,
		const value_type& _Val, char _Carg)
		{
		_Nodeptr _Wherenode = this->_Alnod.allocate(1, (void *)0);
		try {
		new ((void *)_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);
		} catch (...) {
		this->_Alnod.deallocate(_Wherenode, 1);
		throw;
		}
		return (_Wherenode);
		}

	void _Tidy()
		{
		erase(begin(), end());
		this->_Alptr.destroy(&_Left(_Myhead));
		this->_Alptr.destroy(&_Parent(_Myhead));
		this->_Alptr.destroy(&_Right(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0, _Mysize = 0;
		}

	_Nodeptr _Myhead;
	size_type _Mysize;
	};


template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{
	return (!(_Left < _Right));
	}
}

  #pragma warning(default:4127)
#pragma warning(pop)
#pragma pack(pop)


























#pragma pack(push,8)
#pragma warning(push,3)
namespace std {


template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc,
	bool _Mfl>
	class _Tmap_traits
	{
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other
		allocator_type;
	typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
	typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
	enum
		{
		_Multi = _Mfl};

	_Tmap_traits()
		: comp()
		{
		}

	_Tmap_traits(_Pr _Parg)
		: comp(_Parg)
		{
		}

	class value_compare
		: public binary_function<value_type, value_type, bool>
		{
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{
			}

	protected:
		key_compare comp;
		};

	static const _Kty& _Kfn(const value_type& _Val)
		{
		return (_Val.first);
		}

	_Pr comp;
	};


template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	map()
		: _Mybase(key_compare(), allocator_type())
		{
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare& _Pred,
		const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	mapped_type& operator[](const key_type& _Keyval)
		{
		iterator _Where =
			insert(value_type(_Keyval, mapped_type())).first;
		return ((*_Where).second);
		}
	};


template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	multimap()
		: _Mybase(key_compare(), allocator_type())
		{
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		}
	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare& _Pred,
		const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator insert(const value_type& _Val)
		{
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
		for (; _First != _Last; ++_First)
			insert(*_First);
		}
	};
}
#pragma warning(pop)
#pragma pack(pop)












typedef QtValidLicenseForCoreModule QtCoreModule;

struct __declspec(dllimport) QMapData
{
    struct Node {
        Node *backward;
        Node *forward[1];
    };
    enum { LastLevel = 11, Sparseness = 3 };

    Node *backward;
    Node *forward[QMapData::LastLevel + 1];
    QBasicAtomic ref;
    int topLevel;
    int size;
    uint randomBits;
    uint insertInOrder : 1;
    uint sharable : 1;

    static QMapData *createData();
    void continueFreeData(int offset);
    Node *node_create(Node *update[], int offset);
    void node_delete(Node *update[], int offset, Node *node);





    static QMapData shared_null;
};












template <class Key> inline bool qMapLessThanKey(const Key &key1, const Key &key2)
{
    return key1 < key2;
}
















class QDataStream;
template <class Key, class T> class QMap;
template <class aKey, class aT>
QDataStream &operator>>(QDataStream &in, QMap<aKey, aT> &map);


template <class Key, class T>
class QMap
{
    struct Node {
        Key key;
        T value;
        QMapData::Node *backward;
        QMapData::Node *forward[1];
    };
    union {
        QMapData *d;
        QMapData::Node *e;
    };

    struct PayloadNode
    {
        Key key;
        T value;
        QMapData::Node *backward;
    };
    enum { Payload = sizeof(PayloadNode) - sizeof(QMapData::Node *) };

    static inline Node *concrete(QMapData::Node *node) {
        return reinterpret_cast<Node *>(reinterpret_cast<char *>(node) - Payload);
    }
public:
    inline QMap() : d(&QMapData::shared_null) { d->ref.ref(); }
    inline QMap(const QMap<Key, T> &other) : d(other.d)
    { d->ref.ref(); if (!d->sharable) detach(); }
    inline ~QMap() { if (!d) return; if (!d->ref.deref()) freeData(d); }

    QMap<Key, T> &operator=(const QMap<Key, T> &other);

    explicit QMap(const typename std::map<Key, T> &other);
    std::map<Key, T> toStdMap() const;


    bool operator==(const QMap<Key, T> &other) const;
    inline bool operator!=(const QMap<Key, T> &other) const { return !(*this == other); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    inline void detach() { if (d->ref != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref == 1; }
    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

    void clear();

    int remove(const Key &key);
    T take(const Key &key);

    bool contains(const Key &key) const;
    const Key key(const T &value) const;
    const T value(const Key &key) const;
    const T value(const Key &key, const T &defaultValue) const;
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;

    QList<Key> keys() const;
    QList<Key> keys(const T &value) const;
    QList<T> values() const;
    QList<T> values(const Key &key) const;
    int count(const Key &key) const;

    class const_iterator;

    class iterator
    {
        QMapData::Node *i;
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline operator QMapData::Node *() const { return i; }
        inline iterator() : i(0) { }
        inline iterator(QMapData::Node *node) : i(node) { }

        inline const Key &key() const { return concrete(i)->key; }
        inline T &value() const { return concrete(i)->value; }



        inline T &operator*() const { return concrete(i)->value; }
        inline T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == reinterpret_cast<const iterator &>(o).i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != reinterpret_cast<const iterator &>(o).i; }

        inline iterator &operator++() {
            i = i->forward[0];
            return *this;
        }
        inline iterator operator++(int) {
            iterator r = *this;
            i = i->forward[0];
            return r;
        }
        inline iterator &operator--() {
            i = i->backward;
            return *this;
        }
        inline iterator operator--(int) {
            iterator r = *this;
            i = i->backward;
            return r;
        }
        inline iterator operator+(int j) const
        { iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class iterator;

    class const_iterator
    {
        QMapData::Node *i;
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline operator QMapData::Node *() const { return i; }
        inline const_iterator() : i(0) { }
        inline const_iterator(QMapData::Node *node) : i(node) { }
        inline const_iterator(const iterator &o)
        { i = reinterpret_cast<const const_iterator &>(o).i; }

        inline const Key &key() const { return concrete(i)->key; }
        inline const T &value() const { return concrete(i)->value; }



        inline const T &operator*() const { return concrete(i)->value; }
        inline const T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }

        inline const_iterator &operator++() {
            i = i->forward[0];
            return *this;
        }
        inline const_iterator operator++(int) {
            const_iterator r = *this;
            i = i->forward[0];
            return r;
        }
        inline const_iterator &operator--() {
            i = i->backward;
            return *this;
        }
        inline const_iterator operator--(int) {
            const_iterator r = *this;
            i = i->backward;
            return r;
        }
        inline const_iterator operator+(int j) const
        { const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(e->forward[0]); }
    inline const_iterator begin() const { return const_iterator(e->forward[0]); }
    inline const_iterator constBegin() const { return const_iterator(e->forward[0]); }
    inline iterator end() {
        detach();
        return iterator(e);
    }
    inline const_iterator end() const { return const_iterator(e); }
    inline const_iterator constEnd() const { return const_iterator(e); }
    iterator erase(iterator it);






    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    iterator find(const Key &key);
    const_iterator find(const Key &key) const;
    iterator lowerBound(const Key &key);
    const_iterator lowerBound(const Key &key) const;
    iterator upperBound(const Key &key);
    const_iterator upperBound(const Key &key) const;
    iterator insert(const Key &key, const T &value);



    iterator insertMulti(const Key &key, const T &value);



    QMap<Key, T> &unite(const QMap<Key, T> &other);


    inline bool empty() const { return isEmpty(); }

private:
    void detach_helper();
    void freeData(QMapData *d);
    QMapData::Node *findNode(const Key &key) const;
    QMapData::Node *mutableFindNode(QMapData::Node *update[], const Key &key) const;
    QMapData::Node *node_create(QMapData *d, QMapData::Node *update[], const Key &key,
                                const T &value);






    template <class aKey, class aT>
    friend QDataStream &operator>> (QDataStream &in, QMap<aKey, aT> &map);



};

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::operator=(const QMap<Key, T> &other)
{
    if (d != other.d) {
        QMapData *x = other.d;
        x->ref.ref();
        x = qAtomicSetPtr(&d, x);
        if (!x->ref.deref())
            freeData(x);
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}

template <class Key, class T>
inline void QMap<Key, T>::clear()
{
    *this = QMap<Key, T>();
}

template <class Key, class T>
inline typename QMapData::Node *
QMap<Key, T>::node_create(QMapData *adt, QMapData::Node *aupdate[], const Key &akey, const T &avalue)
{
    QMapData::Node *abstractNode = adt->node_create(aupdate, Payload);
    Node *concreteNode = concrete(abstractNode);
    new (&concreteNode->key) Key(akey);
    new (&concreteNode->value) T(avalue);
    return abstractNode;
}

template <class Key, class T>
inline QMapData::Node *QMap<Key, T>::findNode(const Key &akey) const
{
    QMapData::Node *cur = e;
    QMapData::Node *next = e;

    for (int i = d->topLevel; i >= 0; i--) {
        while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
            cur = next;
    }

    if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
        return next;
    } else {
        return e;
    }
}

template <class Key, class T>
inline const T QMap<Key, T>::value(const Key &akey) const
{
    QMapData::Node *node = findNode(akey);
    if (node == e) {
        return T();
    } else {
        return concrete(node)->value;
    }
}

template <class Key, class T>
inline const T QMap<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
    QMapData::Node *node = findNode(akey);
    if (node == e) {
        return adefaultValue;
    } else {
        return concrete(node)->value;
    }
}

template <class Key, class T>
inline const T QMap<Key, T>::operator[](const Key &akey) const
{
    return value(akey);
}

template <class Key, class T>
inline T &QMap<Key, T>::operator[](const Key &akey)
{
    detach();

    QMapData::Node *update[QMapData::LastLevel + 1];
    QMapData::Node *node = mutableFindNode(update, akey);
    if (node == e)
        node = node_create(d, update, akey, T());
    return concrete(node)->value;
}

template <class Key, class T>
inline int QMap<Key, T>::count(const Key &akey) const
{
    int cnt = 0;
    QMapData::Node *node = findNode(akey);
    if (node != e) {
        do {
            ++cnt;
            node = node->forward[0];
        } while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key));
    }
    return cnt;
}

template <class Key, class T>
inline bool QMap<Key, T>::contains(const Key &akey) const
{
    return findNode(akey) != e;
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insert(const Key &akey,
                                                                       const T &avalue)
{
    detach();

    QMapData::Node *update[QMapData::LastLevel + 1];
    QMapData::Node *node = mutableFindNode(update, akey);
    if (node == e) {
        node = node_create(d, update, akey, avalue);
    } else {
        concrete(node)->value = avalue;
    }
    return iterator(node);
}





















template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insertMulti(const Key &akey,
                                                                            const T &avalue)
{
    detach();

    QMapData::Node *update[QMapData::LastLevel + 1];
    mutableFindNode(update, akey);
    return iterator(node_create(d, update, akey, avalue));
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::find(const Key &akey) const
{
    return const_iterator(findNode(akey));
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::find(const Key &akey)
{
    detach();
    return iterator(findNode(akey));
}

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::unite(const QMap<Key, T> &other)
{
    QMap<Key, T> copy(other);
    const_iterator it = copy.constEnd();
    while (it != copy.constBegin()) {
        --it;
        insertMulti(it.key(), it.value());
    }
    return *this;
}

template <class Key, class T>
inline void QMap<Key, T>::freeData(QMapData *x)
{
    if (QTypeInfo<Key>::isComplex || QTypeInfo<T>::isComplex) {
        QMapData::Node *y = reinterpret_cast<QMapData::Node *>(x);
        QMapData::Node *cur = y;
        QMapData::Node *next = cur->forward[0];
        while (next != y) {
            cur = next;
            next = cur->forward[0];
            Node *concreteNode = concrete(cur);
            concreteNode->key.~Key();
            concreteNode->value.~T();
        }
    }
    x->continueFreeData(Payload);
}

template <class Key, class T>
inline int QMap<Key, T>::remove(const Key &akey)
{
    detach();

    QMapData::Node *update[QMapData::LastLevel + 1];
    QMapData::Node *cur = e;
    QMapData::Node *next = e;
    int oldSize = d->size;

    for (int i = d->topLevel; i >= 0; i--) {
        while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
            cur = next;
        update[i] = cur;
    }

    if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
        bool deleteNext = true;
        do {
            cur = next;
            next = cur->forward[0];
            deleteNext = (next != e && !qMapLessThanKey<Key>(concrete(cur)->key, concrete(next)->key));
            concrete(cur)->key.~Key();
            concrete(cur)->value.~T();
            d->node_delete(update, Payload, cur);
        } while (deleteNext);
    }
    return oldSize - d->size;
}

template <class Key, class T>
inline T QMap<Key, T>::take(const Key &akey)
{
    detach();

    QMapData::Node *update[QMapData::LastLevel + 1];
    QMapData::Node *cur = e;
    QMapData::Node *next = e;

    for (int i = d->topLevel; i >= 0; i--) {
        while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
            cur = next;
        update[i] = cur;
    }

    if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
        T t = concrete(next)->value;
        concrete(next)->key.~Key();
        concrete(next)->value.~T();
        d->node_delete(update, Payload, next);
        return t;
    }
    return T();
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::erase(iterator it)
{
    QMapData::Node *update[QMapData::LastLevel + 1];
    QMapData::Node *cur = e;
    QMapData::Node *next = e;

    if (it == iterator(e))
        return it;

    for (int i = d->topLevel; i >= 0; i--) {
        while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, it.key()))
            cur = next;
        update[i] = cur;
    }

    while (next != e) {
        cur = next;
        next = cur->forward[0];
        if (cur == it) {
            concrete(cur)->key.~Key();
            concrete(cur)->value.~T();
            d->node_delete(update, Payload, cur);
            return iterator(next);
        }

        for (int i = 0; i <= d->topLevel; ++i) {
            if (update[i]->forward[i] != cur)
                break;
            update[i] = cur;
        }
    }
    return end();
}

template <class Key, class T>
inline void QMap<Key, T>::detach_helper()
{
    union { QMapData *d; QMapData::Node *e; } x;
    x.d = QMapData::createData();
    if (d->size) {
        x.d->insertInOrder = true;
        QMapData::Node *update[QMapData::LastLevel + 1];
        QMapData::Node *cur = e->forward[0];
        update[0] = x.e;
        while (cur != e) {
            Node *concreteNode = concrete(cur);
            node_create(x.d, update, concreteNode->key, concreteNode->value);
            cur = cur->forward[0];
        }
        x.d->insertInOrder = false;
    }
    x.d = qAtomicSetPtr(&d, x.d);
    if (!x.d->ref.deref())
        freeData(x.d);
}

template <class Key, class T>
inline QMapData::Node *QMap<Key, T>::mutableFindNode(QMapData::Node *aupdate[],
                                                                   const Key &akey) const
{
    QMapData::Node *cur = e;
    QMapData::Node *next = e;

    for (int i = d->topLevel; i >= 0; i--) {
        while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
            cur = next;
        aupdate[i] = cur;
    }
    if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
        return next;
    } else {
        return e;
    }
}

template <class Key, class T>
inline QList<Key> QMap<Key, T>::keys() const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<Key> QMap<Key, T>::keys(const T &avalue) const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline const Key QMap<Key, T>::key(const T &avalue) const
{
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            return i.key();
        ++i;
    }

    return Key();
}

template <class Key, class T>
inline QList<T> QMap<Key, T>::values() const
{
    QList<T> res;
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.value());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<T> QMap<Key, T>::values(const Key &akey) const
{
    QList<T> res;
    QMapData::Node *node = findNode(akey);
    if (node != e) {
        do {
            res.append(concrete(node)->value);
            node = node->forward[0];
        } while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key));
    }
    return res;
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator
QMap<Key, T>::lowerBound(const Key &akey) const
{
    QMapData::Node *update[QMapData::LastLevel + 1];
    mutableFindNode(update, akey);
    return const_iterator(update[0]->forward[0]);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::lowerBound(const Key &akey)
{
    detach();
    return static_cast<QMapData::Node *>(const_cast<const QMap *>(this)->lowerBound(akey));
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator
QMap<Key, T>::upperBound(const Key &akey) const
{
    QMapData::Node *update[QMapData::LastLevel + 1];
    mutableFindNode(update, akey);
    QMapData::Node *node = update[0]->forward[0];
    while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key))
        node = node->forward[0];
    return const_iterator(node);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::upperBound(const Key &akey)
{
    detach();
    return static_cast<QMapData::Node *>(const_cast<const QMap *>(this)->upperBound(akey));
}

template <class Key, class T>
inline bool QMap<Key, T>::operator==(const QMap<Key, T> &other) const
{
    if (size() != other.size())
        return false;
    if (d == other.d)
        return true;

    const_iterator it1 = begin();
    const_iterator it2 = other.begin();

    while (it1 != end()) {
        if (!(it1.value() == it2.value()) || qMapLessThanKey(it1.key(), it2.key()) || qMapLessThanKey(it2.key(), it1.key()))
            return false;
        ++it2;
        ++it1;
    }
    return true;
}


template <class Key, class T>
inline QMap<Key, T>::QMap(const std::map<Key, T> &other)
{
    d = QMapData::createData();
    d->insertInOrder = true;
    typename std::map<Key,T>::const_iterator it = other.end();
    while (it != other.begin()) {
        --it;
        insert((*it).first, (*it).second);
    }
    d->insertInOrder = false;
}

template <class Key, class T>
inline  std::map<Key, T> QMap<Key, T>::toStdMap() const
{
    std::map<Key, T> map;
    const_iterator it = end();
    while (it != begin()) {
        --it;
        map.insert(std::pair<Key, T>(it.key(), it.value()));
    }
    return map;
}



template <class Key, class T>
class QMultiMap : public QMap<Key, T>
{
public:
    QMultiMap() {}
    QMultiMap(const QMap<Key, T> &other) : QMap<Key, T>(other) {}

    inline typename QMap<Key, T>::iterator replace(const Key &key, const T &value);
    inline typename QMap<Key, T>::iterator insert(const Key &key, const T &value);

    inline QMultiMap &operator+=(const QMultiMap &other)
    { unite(other); return *this; }
    inline QMultiMap operator+(const QMultiMap &other) const
    { QMultiMap result = *this; result += other; return result; }

private:
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;
};

template <class Key, class T>
inline  QMap<Key, T>::iterator QMultiMap<Key, T>::replace(const Key &akey, const T &avalue)
{ return QMap<Key, T>::insert(akey, avalue); }

template <class Key, class T>
inline  QMap<Key, T>::iterator QMultiMap<Key, T>::insert(const Key &akey, const T &avalue)
{ return QMap<Key, T>::insertMulti(akey, avalue); }


template <class Key, class T> class QMapIterator { typedef typename QMap<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QMap<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QMapIterator(const QMap<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QMapIterator &operator=(const QMap<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qmap.h",835);} while (0); return *n; } inline const Key &key() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qmap.h",835);} while (0); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableMapIterator { typedef typename QMap<Key,T>::iterator iterator; typedef iterator Item; QMap<Key,T> *c; iterator i, n; inline bool item_exists() const { return n != c->constEnd(); } public: inline QMutableMapIterator(QMap<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableMapIterator() { c->setSharable(true); } inline QMutableMapIterator &operator=(QMap<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return i != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (n != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (n != c->constEnd()) *n = t; } inline T &value() { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qmap.h",836);} while (0); return *n; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qmap.h",836);} while (0); return *n; } inline const Key &key() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qmap.h",836);} while (0); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;
class __declspec(dllimport) QTextStream
{
    inline QTextStreamPrivate* d_func() { return reinterpret_cast<QTextStreamPrivate *>(d_ptr); } inline const QTextStreamPrivate* d_func() const { return reinterpret_cast<const QTextStreamPrivate *>(d_ptr); } friend class QTextStreamPrivate;

public:
    enum RealNumberNotation {
        SmartNotation,
        FixedNotation,
        ScientificNotation
    };
    enum FieldAlignment {
        AlignLeft,
        AlignRight,
        AlignCenter,
        AlignAccountingStyle
    };



    enum Status {
        Ok,
        ReadPastEnd,
        ReadCorruptData
    };
    enum NumberFlag {
        ShowBase = 0x1,
        ForcePoint = 0x2,
        ForceSign = 0x4,
        UppercaseBase = 0x8,
        UppercaseDigits = 0x10
    };
    typedef QFlags<NumberFlag> NumberFlags;

    QTextStream();
    explicit QTextStream(QIODevice *device);
    explicit QTextStream(FILE *fileHandle, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QByteArray *array, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(const QByteArray &array, QIODevice::OpenMode openMode = QIODevice::ReadOnly);
    virtual ~QTextStream();


    void setCodec(QTextCodec *codec);
    void setCodec(const char *codecName);
    QTextCodec *codec() const;
    void setAutoDetectUnicode(bool enabled);
    bool autoDetectUnicode() const;
    void setGenerateByteOrderMark(bool generate);
    bool generateByteOrderMark() const;


    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setString(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    QString *string() const;

    Status status() const;
    void setStatus(Status status);
    void resetStatus();

    bool atEnd() const;
    void reset();
    void flush();
    bool seek(qint64 pos);

    void skipWhiteSpace();

    QString readLine(qint64 maxlen = 0);
    QString readAll();

    void setFieldAlignment(FieldAlignment alignment);
    FieldAlignment fieldAlignment() const;

    void setPadChar(QChar ch);
    QChar padChar() const;

    void setFieldWidth(int width);
    int fieldWidth() const;

    void setNumberFlags(NumberFlags flags);
    NumberFlags numberFlags() const;

    void setIntegerBase(int base);
    int integerBase() const;

    void setRealNumberNotation(RealNumberNotation notation);
    RealNumberNotation realNumberNotation() const;

    void setRealNumberPrecision(int precision);
    int realNumberPrecision() const;

    QTextStream &operator>>(QChar &ch);
    QTextStream &operator>>(char &ch);
    QTextStream &operator>>(signed short &i);
    QTextStream &operator>>(unsigned short &i);
    QTextStream &operator>>(signed int &i);
    QTextStream &operator>>(unsigned int &i);
    QTextStream &operator>>(signed long &i);
    QTextStream &operator>>(unsigned long &i);
    QTextStream &operator>>(qlonglong &i);
    QTextStream &operator>>(qulonglong &i);
    QTextStream &operator>>(float &f);
    QTextStream &operator>>(double &f);
    QTextStream &operator>>(QString &s);
    QTextStream &operator>>(QByteArray &array);
    QTextStream &operator>>(char *c);

    QTextStream &operator<<(QChar ch);
    QTextStream &operator<<(char ch);
    QTextStream &operator<<(signed short i);
    QTextStream &operator<<(unsigned short i);
    QTextStream &operator<<(signed int i);
    QTextStream &operator<<(unsigned int i);
    QTextStream &operator<<(signed long i);
    QTextStream &operator<<(unsigned long i);
    QTextStream &operator<<(qlonglong i);
    QTextStream &operator<<(qulonglong i);
    QTextStream &operator<<(float f);
    QTextStream &operator<<(double f);
    QTextStream &operator<<(const QString &s);
    QTextStream &operator<<(const QByteArray &array);
    QTextStream &operator<<(const char *c);
    QTextStream &operator<<(const void *ptr);




















































private:





    QTextStream(const QTextStream &); QTextStream &operator=(const QTextStream &);

    QTextStreamPrivate *d_ptr;
};

inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QTextStream::NumberFlags::enum_type f2) { return QFlags<QTextStream::NumberFlags::enum_type>(f1) | f2; } inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QFlags<QTextStream::NumberFlags::enum_type> f2) { return f2 | f1; }





typedef QTextStream & (*QTextStreamFunction)(QTextStream &);
typedef void (QTextStream::*QTSMFI)(int);
typedef void (QTextStream::*QTSMFC)(QChar);

class __declspec(dllimport) QTextStreamManipulator
{
public:
    QTextStreamManipulator(QTSMFI m, int a) { mf = m; mc = 0; arg = a; }
    QTextStreamManipulator(QTSMFC m, QChar c) { mf = 0; mc = m; ch = c; }
    void exec(QTextStream &s) { if (mf) { (s.*mf)(arg); } else { (s.*mc)(ch); } }

private:
    QTSMFI mf;
    QTSMFC mc;
    int arg;
    QChar ch;
};

inline QTextStream &operator>>(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamManipulator m)
{ m.exec(s); return s; }

__declspec(dllimport) QTextStream &bin(QTextStream &s);
__declspec(dllimport) QTextStream &oct(QTextStream &s);
__declspec(dllimport) QTextStream &dec(QTextStream &s);
__declspec(dllimport) QTextStream &hex(QTextStream &s);

__declspec(dllimport) QTextStream &showbase(QTextStream &s);
__declspec(dllimport) QTextStream &forcesign(QTextStream &s);
__declspec(dllimport) QTextStream &forcepoint(QTextStream &s);
__declspec(dllimport) QTextStream &noshowbase(QTextStream &s);
__declspec(dllimport) QTextStream &noforcesign(QTextStream &s);
__declspec(dllimport) QTextStream &noforcepoint(QTextStream &s);

__declspec(dllimport) QTextStream &uppercasebase(QTextStream &s);
__declspec(dllimport) QTextStream &uppercasedigits(QTextStream &s);
__declspec(dllimport) QTextStream &lowercasebase(QTextStream &s);
__declspec(dllimport) QTextStream &lowercasedigits(QTextStream &s);

__declspec(dllimport) QTextStream &fixed(QTextStream &s);
__declspec(dllimport) QTextStream &scientific(QTextStream &s);

__declspec(dllimport) QTextStream &left(QTextStream &s);
__declspec(dllimport) QTextStream &right(QTextStream &s);
__declspec(dllimport) QTextStream &center(QTextStream &s);

__declspec(dllimport) QTextStream &endl(QTextStream &s);
__declspec(dllimport) QTextStream &flush(QTextStream &s);
__declspec(dllimport) QTextStream &reset(QTextStream &s);

__declspec(dllimport) QTextStream &bom(QTextStream &s);

__declspec(dllimport) QTextStream &ws(QTextStream &s);

inline QTextStreamManipulator qSetFieldWidth(int width)
{
    QTSMFI func = &QTextStream::setFieldWidth;
    return QTextStreamManipulator(func,width);
}

inline QTextStreamManipulator qSetPadChar(QChar ch)
{
    QTSMFC func = &QTextStream::setPadChar;
    return QTextStreamManipulator(func, ch);
}

inline QTextStreamManipulator qSetRealNumberPrecision(int precision)
{
    QTSMFI func = &QTextStream::setRealNumberPrecision;
    return QTextStreamManipulator(func, precision);
}









































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;


class __declspec(dllimport) QDebug
{
    struct Stream {
        Stream(QtMsgType t) : ts(&buffer, QIODevice::WriteOnly), ref(1), type(t), space(true){}
        QTextStream ts;
        QString buffer;
        int ref;
        QtMsgType type;
        bool space;
    } *stream;
public:
    inline QDebug(QtMsgType t) : stream(new Stream(t)) {}
    inline QDebug(const QDebug &o):stream(o.stream) { ++stream->ref; }
    inline ~QDebug()
        { if (!--stream->ref) { qt_message_output(stream->type, stream->buffer.toLocal8Bit().data()); delete stream; } }
    inline QDebug &space() { stream->space = true; stream->ts << " "; return *this; }
    inline QDebug &nospace() { stream->space = false; return *this; }
    inline QDebug &maybeSpace() { if (stream->space) stream->ts << " "; return *this; }

    inline QDebug &operator<<(QChar t) { stream->ts << "\'" << t << "\'"; return maybeSpace(); }
    inline QDebug &operator<<(bool t) { stream->ts << (t ? "true" : "false"); return maybeSpace(); }
    inline QDebug &operator<<(char t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed short t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned short t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed int t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned int t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed long t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned long t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(qint64 t)
        { stream->ts << QString::number(t); return maybeSpace(); }
    inline QDebug &operator<<(quint64 t)
        { stream->ts << QString::number(t); return maybeSpace(); }
    inline QDebug &operator<<(float t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(double t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(const char* t) { stream->ts  << t; return maybeSpace(); }
    inline QDebug &operator<<(const QString & t) { stream->ts << "\"" << t  << "\""; return maybeSpace(); }
    inline QDebug &operator<<(const QLatin1String &t) { stream->ts << "\""  << t.latin1() << "\""; return maybeSpace(); }
    inline QDebug &operator<<(const QByteArray & t) { stream->ts  << "\"" << t << "\""; return maybeSpace(); }
    inline QDebug &operator<<(const void * t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(QTextStreamFunction f) {
        stream->ts << f;
        return *this;
    }

    inline QDebug &operator<<(QTextStreamManipulator m)
    { stream->ts << m; return *this; }
};

template <class T>
inline QDebug operator<<(QDebug debug, const QList<T> &list)
{
    debug.nospace() << "(";
    for ( QList<T>::size_type i = 0; i < list.count(); ++i) {
        if (i)
            debug << ", ";
        debug << list.at(i);
    }
    debug << ")";
    return debug.space();
}

template <class aKey, class aT>
inline QDebug operator<<(QDebug debug, const QMap<aKey, aT> &map)
{
    debug.nospace() << "QMap(";
    for (typename QMap<aKey, aT>::const_iterator it = map.constBegin();
         it != map.constEnd(); ++it) {
        debug << "(" << it.key() << ", " << it.value() << ")";
    }
    debug << ")";
    return debug.space();
}

inline __declspec(dllimport) QDebug qDebug() { return QDebug(QtDebugMsg); }
inline __declspec(dllimport) QDebug qWarning() { return QDebug(QtWarningMsg); }
inline __declspec(dllimport) QDebug qCritical() { return QDebug(QtCriticalMsg); }










































































































































































































































































































































































































































































































































































































































































































































































class QFSFileEnginePrivate;
class __declspec(dllimport) QFSFileEngine : public QAbstractFileEngine
{
    inline QFSFileEnginePrivate* d_func() { return reinterpret_cast<QFSFileEnginePrivate *>(d_ptr); } inline const QFSFileEnginePrivate* d_func() const { return reinterpret_cast<const QFSFileEnginePrivate *>(d_ptr); } friend class QFSFileEnginePrivate;
public:
    QFSFileEngine();
    explicit QFSFileEngine(const QString &file);
    ~QFSFileEngine();

    bool open(QIODevice::OpenMode openMode);
    bool open(QIODevice::OpenMode flags, FILE *fh);
    bool close();
    bool flush();
    qint64 size() const;
    qint64 pos() const;
    bool seek(qint64);
    bool isSequential() const;
    bool remove();
    bool copy(const QString &newName);
    bool rename(const QString &newName);
    bool link(const QString &newName);
    bool mkdir(const QString &dirName, bool createParentDirectories) const;
    bool rmdir(const QString &dirName, bool recurseParentDirectories) const;
    bool setSize(qint64 size);
    bool caseSensitive() const;
    bool isRelativePath() const;
    QStringList entryList(QDir::Filters filters, const QStringList &filterNames) const;
    FileFlags fileFlags(FileFlags type) const;
    bool setPermissions(uint perms);
    QString fileName(QAbstractFileEngine::FileName file) const;
    uint ownerId(QAbstractFileEngine::FileOwner) const;
    QString owner(FileOwner) const;
    QDateTime fileTime(FileTime time) const;
    void setFileName(const QString &file);
    int handle() const;

    Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames);
    Iterator *endEntryList();

    qint64 read(char *data, qint64 maxlen);
    qint64 readLine(char *data, qint64 maxlen);
    qint64 write(const char *data, qint64 len);

    bool extension(Extension extension, const ExtensionOption *option = 0, ExtensionReturn *output = 0);
    bool supportsExtension(Extension extension) const;


    bool open(QIODevice::OpenMode flags, int fd);
    static bool setCurrentPath(const QString &path);
    static QString currentPath(const QString &path = QString());
    static QString homePath();
    static QString rootPath();
    static QString tempPath();
    static QFileInfoList drives();

protected:
    QFSFileEngine(QFSFileEnginePrivate &dd);
};




























































































































































































































































































































































































































































































































































































































































































typedef struct _PROCESS_INFORMATION* Q_PID;




typedef QtValidLicenseForCoreModule QtCoreModule;



class QProcessPrivate;

class __declspec(dllimport) QProcess : public QIODevice
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    enum ProcessError {
        FailedToStart,
        Crashed,
        Timedout,
        ReadError,
        WriteError,
        UnknownError
    };
    enum ProcessState {
        NotRunning,
        Starting,
        Running
    };
    enum ProcessChannel {
        StandardOutput,
        StandardError
    };
    enum ProcessChannelMode {
        SeparateChannels,
        MergedChannels,
        ForwardedChannels
    };

    explicit QProcess(QObject *parent = 0);
    virtual ~QProcess();

    void start(const QString &program, const QStringList &arguments, OpenMode mode = ReadWrite);
    void start(const QString &program, OpenMode mode = ReadWrite);

    ProcessChannelMode readChannelMode() const;
    void setReadChannelMode(ProcessChannelMode mode);

    ProcessChannel readChannel() const;
    void setReadChannel(ProcessChannel channel);

    void closeReadChannel(ProcessChannel channel);
    void closeWriteChannel();

    QString workingDirectory() const;
    void setWorkingDirectory(const QString &dir);

    void setEnvironment(const QStringList &environment);
    QStringList environment() const;

    QProcess::ProcessError error() const;
    QProcess::ProcessState state() const;

    Q_PID pid() const;

    bool waitForStarted(int msecs = 30000);
    bool waitForReadyRead(int msecs = 30000);
    bool waitForBytesWritten(int msecs = 30000);
    bool waitForFinished(int msecs = 30000);

    QByteArray readAllStandardOutput();
    QByteArray readAllStandardError();

    int exitCode() const;


    qint64 bytesAvailable() const;
    qint64 bytesToWrite() const;
    bool isSequential() const;
    bool canReadLine() const;
    void close();
    bool atEnd() const;

    static int execute(const QString &program, const QStringList &arguments);
    static int execute(const QString &program);

    static bool startDetached(const QString &program, const QStringList &arguments);
    static bool startDetached(const QString &program);

public :
    void terminate();
    void kill();

protected:
    void started();
    void finished(int exitCode);
    void error(QProcess::ProcessError error);
    void stateChanged(QProcess::ProcessState state);

    void readyReadStandardOutput();
    void readyReadStandardError();

protected:
    void setProcessState(ProcessState state);

    virtual void setupChildProcess();


    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);

private:
    inline QProcessPrivate* d_func() { return reinterpret_cast<QProcessPrivate *>(d_ptr); } inline const QProcessPrivate* d_func() const { return reinterpret_cast<const QProcessPrivate *>(d_ptr); } friend class QProcessPrivate;
    QProcess(const QProcess &); QProcess &operator=(const QProcess &);







    friend class QProcessManager;
};


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QMetaType {
public:
    enum Type {

        Void = 0, Bool = 1, Int = 2, UInt = 3, Double = 6, QChar = 7,
        QString = 10, QByteArray = 12,

        VoidStar = 128, Long, Short, Char, ULong,
        UShort, UChar, Float, QObjectStar, QWidgetStar,
        User = 256
    };

    typedef void (*Destructor)(void *);
    typedef void *(*Constructor)(const void *);


    typedef void (*SaveOperator)(QDataStream &, const void *);
    typedef void (*LoadOperator)(QDataStream &, void *);
    static void registerStreamOperators(const char *typeName, SaveOperator saveOp,
                                        LoadOperator loadOp);

    static int registerType(const char *typeName, Destructor destructor,
                            Constructor constructor);
    static int type(const char *typeName);
    static const char *typeName(int type);
    static bool isRegistered(int type);
    static void *construct(int type, const void *copy);
    static void destroy(int type, void *data);


    static bool save(QDataStream &stream, int type, const void *data);
    static bool load(QDataStream &stream, int type, void *data);

};

template <typename T>
void qMetaTypeDeleteHelper(T *t)
{
    delete t;
}

template <typename T>
void *qMetaTypeConstructHelper(const T *t)
{
    if (!t)
        return new T;
    return new T(*static_cast<const T*>(t));
}


template <typename T>
void qMetaTypeSaveHelper(QDataStream &stream, const T *t)
{
    stream << *t;
}

template <typename T>
void qMetaTypeLoadHelper(QDataStream &stream, T *t)
{
    stream >> *t;
}

template <typename T>
void qRegisterMetaTypeStreamOperators(const char *typeName, T * = 0)
{
    typedef void(*SavePtr)(QDataStream &, const T *);
    typedef void(*LoadPtr)(QDataStream &, T *);
    SavePtr sptr = qMetaTypeSaveHelper<T>;
    LoadPtr lptr = qMetaTypeLoadHelper<T>;

    QMetaType::registerStreamOperators(typeName, reinterpret_cast<QMetaType::SaveOperator>(sptr),
                                       reinterpret_cast<QMetaType::LoadOperator>(lptr));
}


template <typename T>
int qRegisterMetaType(const char *typeName, T * = 0)
{
    typedef void*(*ConstructPtr)(const T*);
    ConstructPtr cptr = qMetaTypeConstructHelper<T>;
    typedef void(*DeletePtr)(T*);
    DeletePtr dptr = qMetaTypeDeleteHelper<T>;

    return QMetaType::registerType(typeName, reinterpret_cast<QMetaType::Destructor>(dptr),
                                   reinterpret_cast<QMetaType::Constructor>(cptr));
}

template <typename T>
struct QMetaTypeId
{
    enum { Defined = 0 };
};













template<> struct QMetaTypeId<QString>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::QString; } };
template<> struct QMetaTypeId<int>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Int; } };
template<> struct QMetaTypeId<uint>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::UInt; } };
template<> struct QMetaTypeId<bool>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Bool; } };
template<> struct QMetaTypeId<double>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Double; } };
template<> struct QMetaTypeId<QByteArray>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::QByteArray; } };
template<> struct QMetaTypeId<QChar>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::QChar; } };
template<> struct QMetaTypeId<void>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Void; } };
template<> struct QMetaTypeId<long>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Long; } };
template<> struct QMetaTypeId<short>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Short; } };
template<> struct QMetaTypeId<char>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Char; } };
template<> struct QMetaTypeId<ulong>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::ULong; } };
template<> struct QMetaTypeId<ushort>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::UShort; } };
template<> struct QMetaTypeId<uchar>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::UChar; } };
template<> struct QMetaTypeId<float>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::Float; } };
class QObject;
template<> struct QMetaTypeId<QObject *>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::QObjectStar; } };
class QWidget;
template<> struct QMetaTypeId<QWidget *>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::QWidgetStar; } };
template<> struct QMetaTypeId<void *>
{ enum { Defined = 1 };
  static inline int qt_metatype_id() { return QMetaType::VoidStar; } };















































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QBitArray;
class QDataStream;
class QDate;
class QDateTime;
class QLine;
class QLineF;
class QLocale;
class QString;
class QStringList;
class QTime;
class QPoint;
class QPointF;
class QSize;
class QSizeF;
class QRect;
class QRectF;
class QTextFormat;
class QTextLength;
class QUrl;
class QVariant;
class QVariantComparisonHelper;



template <typename T>
inline QVariant qVariantFromValue(const T &);

template <typename T>
inline void qVariantSetValue(QVariant &, const T &);

template<typename T>
inline T qVariantValue(const QVariant &);

template<typename T>
inline bool qVariantCanConvert(const QVariant &);


class __declspec(dllimport) QVariant
{
 public:
    enum Type {
        Invalid = 0,

        Bool = 1,
        Int = 2,
        UInt = 3,
        LongLong = 4,
        ULongLong = 5,
        Double = 6,
        Char = 7,

        Map = 8,
        List = 9,
        String = 10,
        StringList = 11,
        ByteArray = 12,
        BitArray = 13,
        Date = 14,
        Time = 15,
        DateTime = 16,
        Url = 17,
        Locale = 18,

        Rect = 19,
        RectF = 20,
        Size = 21,
        SizeF = 22,
        Line = 23,
        LineF = 24,
        Point = 25,
        PointF = 26,




        Font = 64,
        Pixmap = 65,
        Brush = 66,
        Color = 67,
        Palette = 68,
        Icon = 69,
        Image = 70,
        Polygon = 71,
        Region = 72,
        Bitmap = 73,
        Cursor = 74,
        SizePolicy = 75,
        KeySequence = 76,
        Pen = 77,
        TextLength = 78,
        TextFormat = 79,
        UserType = 127,





        LastType = 0xffffffff
    };

    inline QVariant();
    ~QVariant();
    QVariant(Type type);
    QVariant(int typeOrUserType, const void *copy);
    QVariant(const QVariant &other);


    QVariant(QDataStream &s);


    QVariant(int i);
    QVariant(uint ui);
    QVariant(qlonglong ll);
    QVariant(qulonglong ull);
    QVariant(bool b);
    QVariant(double d);
    QVariant(const char *str);

    QVariant(const QByteArray &bytearray);
    QVariant(const QBitArray &bitarray);
    QVariant(const QString &string);
    QVariant(const QLatin1String &string);
    QVariant(const QStringList &stringlist);
    QVariant(const QChar &qchar);
    QVariant(const QDate &date);
    QVariant(const QTime &time);
    QVariant(const QDateTime &datetime);
    QVariant(const QList<QVariant> &list);
    QVariant(const QMap<QString,QVariant> &map);

    QVariant(const QSize &size);
    QVariant(const QSizeF &size);
    QVariant(const QPoint &pt);
    QVariant(const QPointF &pt);
    QVariant(const QLine &line);
    QVariant(const QLineF &line);
    QVariant(const QRect &rect);
    QVariant(const QRectF &rect);

    QVariant(const QUrl &url);
    QVariant(const QLocale &locale);

    QVariant& operator=(const QVariant &other);

    Type type() const;
    int userType() const;
    const char *typeName() const;

    bool canConvert(Type t) const;
    bool convert(Type t);








    inline bool isValid() const;
    bool isNull() const;

    void clear();

    void detach();
    inline bool isDetached() const;

    int toInt(bool *ok = 0) const;
    uint toUInt(bool *ok = 0) const;
    qlonglong toLongLong(bool *ok = 0) const;
    qulonglong toULongLong(bool *ok = 0) const;
    bool toBool() const;
    double toDouble(bool *ok = 0) const;
    QByteArray toByteArray() const;
    QBitArray toBitArray() const;
    QString toString() const;
    QStringList toStringList() const;
    QChar toChar() const;
    QDate toDate() const;
    QTime toTime() const;
    QDateTime toDateTime() const;
    QList<QVariant> toList() const;
    QMap<QString,QVariant> toMap() const;


    QPoint toPoint() const;
    QPointF toPointF() const;
    QRect toRect() const;
    QSize toSize() const;
    QSizeF toSizeF() const;
    QLine toLine() const;
    QLineF toLineF() const;
    QRectF toRectF() const;

    QUrl toUrl() const;
    QLocale toLocale() const;























    void load(QDataStream &ds);
    void save(QDataStream &ds) const;

    static const char *typeToName(Type type);
    static Type nameToType(const char *name);







    void *data();
    const void *constData() const;
    inline const void *data() const { return constData(); }


    template<typename T>
    inline void setValue(const T &value);

    template<typename T>
    inline T value() const
    { return qVariantValue<T>(*this); }

    template<typename T>
    static inline QVariant fromValue(const T &value)
    { return qVariantFromValue(value); }

    template<typename T>
    bool canConvert() const
    { return qVariantCanConvert<T>(*this); }


 public:

    struct PrivateShared
    {
        inline PrivateShared() : ref(1) { }
        inline PrivateShared(void *v) : ref(1) { ptr = v; }
        void *ptr;
        QAtomic ref;
    };
    struct Private
    {
        inline Private(): type(Invalid), is_shared(false), is_null(true) { data.ptr = 0; }
        inline Private(const Private &other)
            : data(other.data), type(other.type),
              is_shared(other.is_shared), is_null(other.is_null)
        {}
        union Data
        {
            int i;
            uint u;
            bool b;
            double d;
            qlonglong ll;
            qulonglong ull;
            void *ptr;
            PrivateShared *shared;
        } data;
        uint type : 30;
        uint is_shared : 1;
        uint is_null : 1;
    };
 public:
    typedef void (*f_construct)(Private *, const void *);
    typedef void (*f_clear)(Private *);
    typedef bool (*f_null)(const Private *);

    typedef void (*f_load)(Private *, QDataStream &);
    typedef void (*f_save)(const Private *, QDataStream &);

    typedef bool (*f_compare)(const Private *, const Private *);
    typedef bool (*f_convert)(const QVariant::Private *d, Type t, void *, bool *);
    typedef bool (*f_canConvert)(const QVariant::Private *d, Type t);
    typedef void (*f_debugStream)(QDebug, const QVariant &);
    struct Handler {
        f_construct construct;
        f_clear clear;
        f_null isNull;

        f_load load;
        f_save save;

        f_compare compare;
        f_convert convert;
        f_canConvert canConvert;
        f_debugStream debugStream;
    };


    inline bool operator==(const QVariant &v) const
    { return cmp(v); }
    inline bool operator!=(const QVariant &v) const
    { return !cmp(v); }

protected:
    friend inline bool qvariant_cast_helper(const QVariant &, QVariant::Type, void *);
    friend int qRegisterGuiVariant();
    friend inline bool operator==(const QVariant &,
                                  const QVariantComparisonHelper &);

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QVariant &);

    Private d;


    static const Handler *handler;


    void create(int type, const void *copy);



    bool cmp(const QVariant &other) const;
};


typedef QList<QVariant> QVariantList;
typedef QMap<QString, QVariant> QVariantMap;

inline bool qvariant_cast_helper(const QVariant &v, QVariant::Type tp, void *ptr)
{ return QVariant::handler->convert(&v.d, tp, ptr, 0); }

template <typename T>
inline int qt_variant_metatype_id(T *)
{ return QMetaTypeId<T>::qt_metatype_id(); }

template<>
inline int qt_variant_metatype_id(QVariantMap *) { return QVariant::Map; }
template<>
inline int qt_variant_metatype_id(QVariantList *) { return QVariant::List; }
template<>
inline int qt_variant_metatype_id(QStringList *) { return QVariant::StringList; }
class QFont;
template<>
inline int qt_variant_metatype_id(QFont *) { return QVariant::Font; }
class QPixmap;
template<>
inline int qt_variant_metatype_id(QPixmap *) { return QVariant::Pixmap; }
class QBrush;
template<>
inline int qt_variant_metatype_id(QBrush *) { return QVariant::Brush; }
template<>
inline int qt_variant_metatype_id(QRect *) { return QVariant::Rect; }
template<>
inline int qt_variant_metatype_id(QSize *) { return QVariant::Size; }
template<>
inline int qt_variant_metatype_id(QSizeF *) { return QVariant::SizeF; }
class QColor;
template<>
inline int qt_variant_metatype_id(QColor *) { return QVariant::Color; }
class QPalette;
template<>
inline int qt_variant_metatype_id(QPalette *) { return QVariant::Palette; }
class QIcon;
template<>
inline int qt_variant_metatype_id(QIcon *) { return QVariant::Icon; }
class QPoint;
template<>
inline int qt_variant_metatype_id(QPoint *) { return QVariant::Point; }
class QPointF;
template<>
inline int qt_variant_metatype_id(QPointF *) { return QVariant::PointF; }
class QImage;
template<>
inline int qt_variant_metatype_id(QImage*) { return QVariant::Image; }
class QPolygon;
template<>
inline int qt_variant_metatype_id(QPolygon *) { return QVariant::Polygon; }
class QRegion;
template<>
inline int qt_variant_metatype_id(QRegion *) { return QVariant::Region; }
class QBitmap;
template<>
inline int qt_variant_metatype_id(QBitmap *) { return QVariant::Bitmap; }
class QCursor;
template<>
inline int qt_variant_metatype_id(QCursor *) { return QVariant::Cursor; }
class QSizePolicy;
template<>
inline int qt_variant_metatype_id(QSizePolicy *) { return QVariant::SizePolicy; }
template<>
inline int qt_variant_metatype_id(QDate *) { return QVariant::Date; }
template<>
inline int qt_variant_metatype_id(QTime *) { return QVariant::Time; }
template<>
inline int qt_variant_metatype_id(QDateTime *) { return QVariant::DateTime; }
template<>
inline int qt_variant_metatype_id(QBitArray *) { return QVariant::BitArray; }
class QKeySequence;
template<>
inline int qt_variant_metatype_id(QKeySequence *) { return QVariant::KeySequence; }
class QPen;
template<>
inline int qt_variant_metatype_id(QPen *) { return QVariant::Pen; }
template<>
inline int qt_variant_metatype_id(qlonglong *) { return QVariant::LongLong; }
template<>
inline int qt_variant_metatype_id(qulonglong *) { return QVariant::ULongLong; }
template<>
inline int qt_variant_metatype_id(QUrl *) { return QVariant::Url; }
class QTextLength;
template<>
inline int qt_variant_metatype_id(QTextLength *) { return QVariant::TextLength; }
class QTextFormat;
template<>
inline int qt_variant_metatype_id(QTextFormat *) { return QVariant::TextFormat; }
template<>
inline int qt_variant_metatype_id(QLocale *) { return QVariant::Locale; }
template<>
inline int qt_variant_metatype_id(QLineF *) { return QVariant::LineF; }
template<>
inline int qt_variant_metatype_id(QLine *) { return QVariant::Line; }
template<>
inline int qt_variant_metatype_id(QRectF *) { return QVariant::RectF; }






template <typename T>
inline QVariant qVariantFromValue(const T &t)
{
    return QVariant(qt_variant_metatype_id<T>(reinterpret_cast<T *>(0)), &t);
}

template <>
inline QVariant qVariantFromValue(const QVariant &t) { return t; }

template <typename T>
inline void qVariantSetValue(QVariant &v, const T &t)
{
    v = QVariant(qt_variant_metatype_id<T>(reinterpret_cast<T *>(0)), &t);
}


inline QVariant::QVariant() {}
inline bool QVariant::isValid() const { return d.type != Invalid; }









































template<typename T>
inline void QVariant::setValue(const T &avalue)
{ qVariantSetValue(*this, avalue); }



__declspec(dllimport) QDataStream& operator>> (QDataStream& s, QVariant& p);
__declspec(dllimport) QDataStream& operator<< (QDataStream& s, const QVariant& p);
__declspec(dllimport) QDataStream& operator>> (QDataStream& s, QVariant::Type& p);
__declspec(dllimport) QDataStream& operator<< (QDataStream& s, const QVariant::Type p);


inline bool QVariant::isDetached() const
{ return !d.is_shared || d.data.shared->ref == 1; }










class QVariantComparisonHelper
{
public:
    inline QVariantComparisonHelper(const QVariant &var)
        : v(&var) {}
private:
    friend inline bool operator==(const QVariant &,
                                  const QVariantComparisonHelper &);
    const QVariant *v;
};

inline bool operator==(const QVariant &v1, const QVariantComparisonHelper &v2)
{
    return v1.cmp(*v2.v);
}

inline bool operator!=(const QVariant &v1, const QVariantComparisonHelper &v2)
{
    return !operator==(v1, v2);
}





























template<typename T> T qvariant_cast(const QVariant &v)
{
    const int vid = qt_variant_metatype_id<T>(static_cast<T *>(0));
    if (vid == v.userType())
        return *reinterpret_cast<const T *>(v.constData());
    if (vid < int(QVariant::UserType)) {
        T t;
        qvariant_cast_helper(v, QVariant::Type(vid), &t);
        return t;
    }
    return T();
}

template<typename T>
inline T qVariantValue(const QVariant &variant)
{ return qvariant_cast<T>(variant); }

template<typename T>
inline bool qVariantCanConvert(const QVariant &variant)
{
    return variant.canConvert(static_cast<QVariant::Type>(
                qt_variant_metatype_id<T>(static_cast<T *>(0))));
}


template <> inline bool qIsDetached<QVariant>(QVariant &t) { return t.isDetached(); }
template <> class QTypeInfo<QVariant> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QVariant)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QVariant"; } };


__declspec(dllimport) QDebug operator<<(QDebug, const QVariant &);
__declspec(dllimport) QDebug operator<<(QDebug, const QVariant::Type);
















































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;













class QIODevice;
class QSettingsPrivate;


class __declspec(dllimport) QSettings : public QObject



{

    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



    inline QSettingsPrivate* d_func() { return reinterpret_cast<QSettingsPrivate *>(d_ptr); } inline const QSettingsPrivate* d_func() const { return reinterpret_cast<const QSettingsPrivate *>(d_ptr); } friend class QSettingsPrivate;

public:
    enum Status {
        NoError = 0,
        AccessError,
        FormatError
    };

    enum Format {
        NativeFormat,
        IniFormat,

        InvalidFormat = 16,
        CustomFormat1,
        CustomFormat2,
        CustomFormat3,
        CustomFormat4,
        CustomFormat5,
        CustomFormat6,
        CustomFormat7,
        CustomFormat8,
        CustomFormat9,
        CustomFormat10,
        CustomFormat11,
        CustomFormat12,
        CustomFormat13,
        CustomFormat14,
        CustomFormat15,
        CustomFormat16
    };

    enum Scope {
        UserScope,
        SystemScope





    };


    explicit QSettings(const QString &organization,
                       const QString &application = QString(), QObject *parent = 0);
    QSettings(Scope scope, const QString &organization,
              const QString &application = QString(), QObject *parent = 0);
    QSettings(Format format, Scope scope, const QString &organization,
	      const QString &application = QString(), QObject *parent = 0);
    QSettings(const QString &fileName, Format format, QObject *parent = 0);
    explicit QSettings(QObject *parent = 0);









    ~QSettings();

    void clear();
    void sync();
    Status status() const;

    void beginGroup(const QString &prefix);
    void endGroup();
    QString group() const;

    int beginReadArray(const QString &prefix);
    void beginWriteArray(const QString &prefix, int size = -1);
    void endArray();
    void setArrayIndex(int i);

    QStringList allKeys() const;
    QStringList childKeys() const;
    QStringList childGroups() const;
    bool isWritable() const;

    void setValue(const QString &key, const QVariant &value);
    QVariant value(const QString &key, const QVariant &defaultValue = QVariant()) const;

    void remove(const QString &key);
    bool contains(const QString &key) const;

    void setFallbacksEnabled(bool b);
    bool fallbacksEnabled() const;

    QString fileName() const;

    static void setSystemIniPath(const QString &dir);
    static void setUserIniPath(const QString &dir);
    static void setPath(Format format, Scope scope, const QString &path);

    typedef QMap<QString, QVariant> SettingsMap;
    typedef bool (*ReadFunc)(QIODevice &device, SettingsMap &map);
    typedef bool (*WriteFunc)(QIODevice &device, const SettingsMap &map);

    static Format registerFormat(const QString &extension, ReadFunc readFunc, WriteFunc writeFunc,
                                 Qt::CaseSensitivity caseSensitivity = Qt::CaseSensitive);




































































































protected:

    bool event(QEvent *event);


private:
    QSettings(const QSettings &); QSettings &operator=(const QSettings &);
};


























































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QTemporaryFilePrivate;
class __declspec(dllimport) QTemporaryFile : public QFile
{

    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

    inline QTemporaryFilePrivate* d_func() { return reinterpret_cast<QTemporaryFilePrivate *>(d_ptr); } inline const QTemporaryFilePrivate* d_func() const { return reinterpret_cast<const QTemporaryFilePrivate *>(d_ptr); } friend class QTemporaryFilePrivate;

public:
    QTemporaryFile();
    explicit QTemporaryFile(const QString &templateName);

    explicit QTemporaryFile(QObject *parent);
    QTemporaryFile(const QString &templateName, QObject *parent);

    ~QTemporaryFile();

    bool autoRemove() const;
    void setAutoRemove(bool b);


    bool open() { return open(QIODevice::ReadWrite); }

    QString fileName() const;
    QString fileTemplate() const;
    void setFileTemplate(const QString &name);

    inline static QTemporaryFile *createLocalFile(const QString &fileName)
        { QFile file(fileName); return createLocalFile(file); }
    static QTemporaryFile *createLocalFile(QFile &file);

    virtual QAbstractFileEngine *fileEngine() const;

protected:
    bool open(OpenMode flags);

private:
    QTemporaryFile(const QTemporaryFile &); QTemporaryFile &operator=(const QTemporaryFile &);
};

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T1, class T2>
struct QPair
{
    typedef T1 first_type;
    typedef T2 second_type;

    QPair() : first(T1()), second(T2()) {}
    QPair(const T1 &t1, const T2 &t2) : first(t1), second(t2) {}

    QPair &operator=(const QPair &other)
    { first = other.first; second = other.second; return *this; }

    T1 first;
    T2 second;
};

template <class T1, class T2>
inline bool operator==(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return p1.first == p2.first && p1.second == p2.second; }

template <class T1, class T2>
inline bool operator!=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return !(p1 == p2); }

template <class T1, class T2>
inline bool operator<(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return p1.first < p2.first || (!(p2.first < p1.first) && p1.second < p2.second);
}

template <class T1, class T2>
inline bool operator>(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return p2 < p1;
}

template <class T1, class T2>
inline bool operator<=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return !(p2 < p1);
}

template <class T1, class T2>
inline bool operator>=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return !(p1 < p2);
}

template <class T1, class T2>
inline QPair<T1, T2> qMakePair(const T1 &x, const T2 &y)
{
    return QPair<T1, T2>(x, y);
}


template <class T1, class T2>
inline QDataStream& operator>>(QDataStream& s, QPair<T1, T2>& p)
{
    s >> p.first >> p.second;
    return s;
}

template <class T1, class T2>
inline QDataStream& operator<<(QDataStream& s, const QPair<T1, T2>& p)
{
    s << p.first << p.second;
    return s;
}















































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QUrlPrivate;
class QDataStream;

class __declspec(dllimport) QUrl
{
public:
    QUrl();
    QUrl(const QString &url);
    QUrl(const QUrl &copy);
    ~QUrl();


    enum FormattingOption {
        None = 0x0,
        RemoveScheme = 0x1,
        RemovePassword = 0x2,
        RemoveUserInfo = RemovePassword | 0x4,
        RemovePort = 0x8,
        RemoveAuthority = RemoveUserInfo | RemovePort | 0x10,
        RemovePath = 0x20,
        RemoveQuery = 0x40,
        RemoveFragment = 0x80,

        StripTrailingSlash = 0x10000
    };
    typedef QFlags<FormattingOption> FormattingOptions;

    void setUrl(const QString &url);
    void setEncodedUrl(const QByteArray &url);

    bool isValid() const;

    bool isEmpty() const;

    void clear();

    void setScheme(const QString &scheme);
    QString scheme() const;

    void setAuthority(const QString &authority);
    QString authority() const;

    void setUserInfo(const QString &userInfo);
    QString userInfo() const;

    void setUserName(const QString &userName);
    QString userName() const;

    void setPassword(const QString &password);
    QString password() const;

    void setHost(const QString &host);
    QString host() const;

    void setPort(int port);
    int port() const;

    void setPath(const QString &path);
    QString path() const;

    void setEncodedQuery(const QByteArray &query);
    QByteArray encodedQuery() const;

    void setQueryDelimiters(char valueDelimiter, char pairDelimiter);
    char queryValueDelimiter() const;
    char queryPairDelimiter() const;

    void setQueryItems(const QList<QPair<QString, QString> > &query);
    void addQueryItem(const QString &key, const QString &value);
    QList<QPair<QString, QString> > queryItems() const;
    bool hasQueryItem(const QString &key) const;
    QString queryItemValue(const QString &key) const;
    QStringList allQueryItemValues(const QString &key) const;
    void removeQueryItem(const QString &key);
    void removeAllQueryItems(const QString &key);


    void setFragment(const QString &fragment);
    QString fragment() const;

    QUrl resolved(const QUrl &relative) const;

    bool isRelative() const;
    bool isParentOf(const QUrl &url) const;

    static QUrl fromLocalFile(const QString &localfile);
    QString toLocalFile() const;

    QString toString(FormattingOptions options = None) const;

    QByteArray toEncoded(FormattingOptions options = None) const;
    static QUrl fromEncoded(const QByteArray &url);

    void detach();
    bool isDetached() const;

    bool operator <(const QUrl &url) const;
    bool operator ==(const QUrl &url) const;
    bool operator !=(const QUrl &url) const;
    QUrl &operator =(const QUrl &copy);

    static QString fromPercentEncoding(const QByteArray &);
    static QByteArray toPercentEncoding(const QString &,
                                        const QByteArray &exclude = QByteArray(),
                                        const QByteArray &include = QByteArray());
    static QString fromPunycode(const QByteArray &);
    static QByteArray toPunycode(const QString &);














































protected:




    QUrl(QUrlPrivate &d);

private:
    QUrlPrivate *d;
};

template <> class QTypeInfo<QUrl> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QUrl)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QUrl"; } };
template <> inline bool qIsDetached<QUrl>(QUrl &t) { return t.isDetached(); }
inline QFlags<QUrl::FormattingOptions::enum_type> operator|(QUrl::FormattingOptions::enum_type f1, QUrl::FormattingOptions::enum_type f2) { return QFlags<QUrl::FormattingOptions::enum_type>(f1) | f2; } inline QFlags<QUrl::FormattingOptions::enum_type> operator|(QUrl::FormattingOptions::enum_type f1, QFlags<QUrl::FormattingOptions::enum_type> f2) { return f2 | f1; }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QUrl &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QUrl &);



__declspec(dllimport) QDebug operator<<(QDebug, const QUrl &);














































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QEventLoopPrivate;

class __declspec(dllimport) QEventLoop : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QEventLoopPrivate* d_func() { return reinterpret_cast<QEventLoopPrivate *>(d_ptr); } inline const QEventLoopPrivate* d_func() const { return reinterpret_cast<const QEventLoopPrivate *>(d_ptr); } friend class QEventLoopPrivate;

public:
    explicit QEventLoop(QObject *parent = 0);
    ~QEventLoop();

    enum ProcessEventsFlag {
        AllEvents = 0x00,
        ExcludeUserInputEvents = 0x01,
        ExcludeSocketNotifiers = 0x02,
        WaitForMoreEvents = 0x04










    };
    typedef QFlags<ProcessEventsFlag> ProcessEventsFlags;

    bool processEvents(ProcessEventsFlags flags = AllEvents);
    void processEvents(ProcessEventsFlags flags, int maximumTime);

    int exec(ProcessEventsFlags flags = AllEvents);
    void exit(int returnCode = 0);
    bool isRunning() const;

    void wakeUp();

public :
    void quit();
};

inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QEventLoop::ProcessEventsFlags::enum_type f2) { return QFlags<QEventLoop::ProcessEventsFlags::enum_type>(f1) | f2; } inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QFlags<QEventLoop::ProcessEventsFlags::enum_type> f2) { return f2 | f1; }





typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractEventDispatcherPrivate;
class QSocketNotifier;
template <typename T1, typename T2> struct QPair;

class __declspec(dllimport) QAbstractEventDispatcher : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QAbstractEventDispatcherPrivate* d_func() { return reinterpret_cast<QAbstractEventDispatcherPrivate *>(d_ptr); } inline const QAbstractEventDispatcherPrivate* d_func() const { return reinterpret_cast<const QAbstractEventDispatcherPrivate *>(d_ptr); } friend class QAbstractEventDispatcherPrivate;

public:
    typedef QPair<int, int> TimerInfo;

    explicit QAbstractEventDispatcher(QObject *parent = 0);
    ~QAbstractEventDispatcher();

    static QAbstractEventDispatcher *instance(QThread *thread = 0);

    virtual bool processEvents(QEventLoop::ProcessEventsFlags flags) = 0;
    virtual bool hasPendingEvents() = 0;

    virtual void registerSocketNotifier(QSocketNotifier *notifier) = 0;
    virtual void unregisterSocketNotifier(QSocketNotifier *notifier) = 0;

    int registerTimer(int interval, QObject *object);
    virtual void registerTimer(int timerId, int interval, QObject *object) = 0;
    virtual bool unregisterTimer(int timerId) = 0;
    virtual bool unregisterTimers(QObject *object) = 0;
    virtual QList<TimerInfo> registeredTimers(QObject *object) const = 0;

    virtual void wakeUp() = 0;
    virtual void interrupt() = 0;
    virtual void flush() = 0;

    virtual void startingUp();
    virtual void closingDown();

    typedef bool(*EventFilter)(void *message);
    EventFilter setEventFilter(EventFilter filter);
    bool filterEvent(void *message);

protected:
    void aboutToBlock();
    void awake();

protected:
    QAbstractEventDispatcher(QAbstractEventDispatcherPrivate &,
                             QObject *parent);
};




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractItemModel;
class QPersistentModelIndex;

class __declspec(dllimport) QModelIndex
{
    friend class QAbstractItemModel;
public:
    inline QModelIndex() : r(-1), c(-1), p(0), m(0) {}
    inline QModelIndex(const QModelIndex &other)
        : r(other.r), c(other.c), p(other.p), m(other.m) {}
    inline ~QModelIndex() { p = 0; m = 0; }
    inline int row() const { return r; }
    inline int column() const { return c; }
    inline void *internalPointer() const { return p; }
    inline qint64 internalId() const { return reinterpret_cast<qint64>(p); }
    inline QModelIndex parent() const;
    inline QModelIndex sibling(int row, int column) const;
    inline QModelIndex child(int row, int column) const;
    inline const QAbstractItemModel *model() const { return m; }
    inline bool isValid() const { return (r >= 0) && (c >= 0) && (m != 0); }
    inline bool operator==(const QModelIndex &other) const
        { return (other.r == r && other.c == c && other.p == p && other.m == m); }
    inline bool operator!=(const QModelIndex &other) const
        { return !(*this == other); }
    inline bool operator<(const QModelIndex &other) const
        { if (r < other.r) return true;
          if (r == other.r && c < other.c) return true;
          if (r == other.r && c == other.c) return p < other.p;
          return false; }
private:
    inline QModelIndex(int row, int column, void *ptr, const QAbstractItemModel *model);
    int r, c;
    void *p;
    const QAbstractItemModel *m;
};
template <> class QTypeInfo<QModelIndex> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QModelIndex)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QModelIndex"; } };

inline QModelIndex::QModelIndex(int arow, int acolumn, void *adata,
				const QAbstractItemModel *amodel)
    : r(arow), c(acolumn), p(adata), m(amodel) {}


__declspec(dllimport) QDebug operator<<(QDebug, const QModelIndex &);


class QPersistentModelIndexData;

class __declspec(dllimport) QPersistentModelIndex
{
public:
    QPersistentModelIndex();
    QPersistentModelIndex(const QModelIndex &index);
    QPersistentModelIndex(const QPersistentModelIndex &other);
    ~QPersistentModelIndex();
    bool operator<(const QPersistentModelIndex &other) const;
    bool operator==(const QPersistentModelIndex &other) const;
    QPersistentModelIndex &operator=(const QPersistentModelIndex &other);
    bool operator==(const QModelIndex &other) const;
    bool operator!=(const QModelIndex &other) const;
    QPersistentModelIndex &operator=(const QModelIndex &other);
    operator const QModelIndex&() const;
    int row() const;
    int column() const;
    void *internalPointer() const;
    qint64 internalId() const;
    QModelIndex parent() const;
    QModelIndex sibling(int row, int column) const;
    QModelIndex child(int row, int column) const;
    const QAbstractItemModel *model() const;
    bool isValid() const;
private:
    QPersistentModelIndexData *d;

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QPersistentModelIndex &);

};
template <> class QTypeInfo<QPersistentModelIndex> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPersistentModelIndex)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPersistentModelIndex"; } };


__declspec(dllimport) QDebug operator<<(QDebug, const QPersistentModelIndex &);


template<typename T> class QList;
typedef QList<QModelIndex> QModelIndexList;

class QMimeData;
class QAbstractItemModelPrivate;
template <class Key, class T> class QMap;


class __declspec(dllimport) QAbstractItemModel : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

    friend class QPersistentModelIndexData;
public:

    explicit QAbstractItemModel(QObject *parent = 0);
    virtual ~QAbstractItemModel();

    bool hasIndex(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    virtual QModelIndex index(int row, int column,
                              const QModelIndex &parent = QModelIndex()) const = 0;
    virtual QModelIndex parent(const QModelIndex &child) const = 0;

    inline QModelIndex sibling(int row, int column, const QModelIndex &idx) const
        { return index(row, column, parent(idx)); }

    virtual int rowCount(const QModelIndex &parent = QModelIndex()) const = 0;
    virtual int columnCount(const QModelIndex &parent = QModelIndex()) const = 0;
    virtual bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const = 0;
    virtual bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    virtual QVariant headerData(int section, Qt::Orientation orientation,
                                int role = Qt::DisplayRole) const;
    virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
                               int role = Qt::EditRole);

    virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
    virtual bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);

    virtual QStringList mimeTypes() const;
    virtual QMimeData *mimeData(const QModelIndexList &indexes) const;
    virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                              int row, int column, const QModelIndex &parent);
    virtual Qt::DropActions supportedDropActions() const;

    virtual bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    virtual bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    virtual bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    virtual bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

    inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
    inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());
    inline bool removeRow(int row, const QModelIndex &parent = QModelIndex());
    inline bool removeColumn(int column, const QModelIndex &parent = QModelIndex());

    virtual void fetchMore(const QModelIndex &parent);
    virtual bool canFetchMore(const QModelIndex &parent) const;
    virtual Qt::ItemFlags flags(const QModelIndex &index) const;
    virtual void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
    virtual QModelIndex buddy(const QModelIndex &index) const;
    virtual QModelIndexList match(const QModelIndex &start, int role,
                                  const QVariant &value, int hits = 1,
                                  Qt::MatchFlags flags =
                                  Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
    virtual QSize span(const QModelIndex &index) const;

protected:
    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void headerDataChanged(Qt::Orientation orientation, int first, int last);
    void layoutChanged();


private:

    void rowsAboutToBeInserted(const QModelIndex &parent, int first, int last);
    void rowsInserted(const QModelIndex &parent, int first, int last);

    void rowsAboutToBeRemoved(const QModelIndex &parent, int first, int last);
    void rowsRemoved(const QModelIndex &parent, int first, int last);

    void columnsAboutToBeInserted(const QModelIndex &parent, int first, int last);
    void columnsInserted(const QModelIndex &parent, int first, int last);

    void columnsAboutToBeRemoved(const QModelIndex &parent, int first, int last);
    void columnsRemoved(const QModelIndex &parent, int first, int last);

    void modelReset();

public :
    virtual bool submit();
    virtual void revert();

protected:
    QAbstractItemModel(QAbstractItemModelPrivate &dd, QObject *parent = 0);

    inline QModelIndex createIndex(int row, int column, void *data = 0) const;
    inline QModelIndex createIndex(int row, int column, int id) const;

    void encodeData(const QModelIndexList &indexes, QDataStream &stream) const;
    bool decodeData(int row, int column, const QModelIndex &parent, QDataStream &stream);

    void beginInsertRows(const QModelIndex &parent, int first, int last);
    void endInsertRows();

    void beginRemoveRows(const QModelIndex &parent, int first, int last);
    void endRemoveRows();

    void beginInsertColumns(const QModelIndex &parent, int first, int last);
    void endInsertColumns();

    void beginRemoveColumns(const QModelIndex &parent, int first, int last);
    void endRemoveColumns();

    void reset();

    void changePersistentIndex(const QModelIndex &from, const QModelIndex &to);

private:
    inline QAbstractItemModelPrivate* d_func() { return reinterpret_cast<QAbstractItemModelPrivate *>(d_ptr); } inline const QAbstractItemModelPrivate* d_func() const { return reinterpret_cast<const QAbstractItemModelPrivate *>(d_ptr); } friend class QAbstractItemModelPrivate;
    QAbstractItemModel(const QAbstractItemModel &); QAbstractItemModel &operator=(const QAbstractItemModel &);
};

inline bool QAbstractItemModel::insertRow(int arow, const QModelIndex &aparent)
{ return insertRows(arow, 1, aparent); }
inline bool QAbstractItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
{ return insertColumns(acolumn, 1, aparent); }
inline bool QAbstractItemModel::removeRow(int arow, const QModelIndex &aparent)
{ return removeRows(arow, 1, aparent); }
inline bool QAbstractItemModel::removeColumn(int acolumn, const QModelIndex &aparent)
{ return removeColumns(acolumn, 1, aparent); }

inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, void *adata) const
{ return QModelIndex(arow, acolumn, adata, this); }
inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, int aid) const
{ return QModelIndex(arow, acolumn, reinterpret_cast<void*>(aid), this); }

class __declspec(dllimport) QAbstractTableModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QAbstractTableModel(QObject *parent = 0);
    ~QAbstractTableModel();

    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;

protected:
    QAbstractTableModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
    QAbstractTableModel(const QAbstractTableModel &); QAbstractTableModel &operator=(const QAbstractTableModel &);
    QModelIndex parent(const QModelIndex &child) const;
    bool hasChildren(const QModelIndex &parent) const;
};

class __declspec(dllimport) QAbstractListModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QAbstractListModel(QObject *parent = 0);
    ~QAbstractListModel();

    QModelIndex index(int row, int column = 0, const QModelIndex &parent = QModelIndex()) const;

protected:
    QAbstractListModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
    QAbstractListModel(const QAbstractListModel &); QAbstractListModel &operator=(const QAbstractListModel &);
    QModelIndex parent(const QModelIndex &child) const;
    int columnCount(const QModelIndex &parent) const;
    bool hasChildren(const QModelIndex &parent) const;
};



inline QModelIndex QModelIndex::parent() const
{ return m ? m->parent(*this) : QModelIndex(); }

inline QModelIndex QModelIndex::sibling(int arow, int acolumn) const
{ return m ? m->index(arow, acolumn, m->parent(*this)) : QModelIndex(); }

inline QModelIndex QModelIndex::child(int arow, int acolumn) const
{ return m ? m->index(arow, acolumn, *this) : QModelIndex(); }































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QObject;

class __declspec(dllimport) QBasicTimer
{
    int id;
public:
    inline QBasicTimer() : id(0) {}
    inline ~QBasicTimer() { if (id) stop(); }

    inline bool isActive() const { return id != 0; }
    inline int timerId() const { return id; }

    void start(int msec, QObject *obj);
    void stop();
};
template <> class QTypeInfo<QBasicTimer> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBasicTimer)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBasicTimer"; } };




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QEventPrivate;
class __declspec(dllimport) QEvent
{

public:
    enum Type {






        None = 0,
        Timer = 1,
        MouseButtonPress = 2,
        MouseButtonRelease = 3,
        MouseButtonDblClick = 4,
        MouseMove = 5,
        KeyPress = 6,
        KeyRelease = 7,
        FocusIn = 8,
        FocusOut = 9,
        Enter = 10,
        Leave = 11,
        Paint = 12,
        Move = 13,
        Resize = 14,
        Create = 15,
        Destroy = 16,
        Show = 17,
        Hide = 18,
        Close = 19,
        Quit = 20,
        ParentChange = 21,
        ParentAboutToChange = 131,



        ThreadChange = 22,
        WindowActivate = 24,
        WindowDeactivate = 25,
        ShowToParent = 26,
        HideToParent = 27,
        Wheel = 31,
        WindowTitleChange = 33,
        WindowIconChange = 34,
        ApplicationWindowIconChange = 35,
        ApplicationFontChange = 36,
        ApplicationLayoutDirectionChange = 37,
        ApplicationPaletteChange = 38,
        PaletteChange = 39,
        Clipboard = 40,
        Speech = 42,
        MetaCall =  43,
        SockAct = 50,
        WinEventAct = 132,
        DeferredDelete = 52,
        DragEnter = 60,
        DragMove = 61,
        DragLeave = 62,
        Drop = 63,
        DragResponse = 64,
        ChildAdded = 68,
        ChildPolished = 69,




        ChildRemoved = 71,
        ShowWindowRequest = 73,
        PolishRequest = 74,
        Polish = 75,
        LayoutRequest = 76,
        UpdateRequest = 77,



        EmbeddingControl = 79,
        ActivateControl = 80,
        DeactivateControl = 81,
        ContextMenu = 82,
        InputMethod = 83,
        AccessibilityPrepare = 86,
        TabletMove = 87,
        LocaleChange = 88,
        LanguageChange = 89,
        LayoutDirectionChange = 90,
        Style = 91,
        TabletPress = 92,
        TabletRelease = 93,
        OkRequest = 94,
        HelpRequest = 95,

        IconDrag = 96,

        FontChange = 97,
        EnabledChange = 98,
        ActivationChange = 99,
        StyleChange = 100,
        IconTextChange = 101,
        ModifiedChange = 102,
        MouseTrackingChange = 109,

        WindowBlocked = 103,
        WindowUnblocked = 104,
        WindowStateChange = 105,

        ToolTip = 110,
        WhatsThis = 111,
        StatusTip = 112,

        ActionChanged = 113,
        ActionAdded = 114,
        ActionRemoved = 115,

        FileOpen = 116,

        Shortcut = 117,
        ShortcutOverride = 51,







        WhatsThisClicked = 118,





        ToolBarChange = 120,

        ApplicationActivated = 121,
        ApplicationDeactivated = 122,

        QueryWhatsThis = 123,
        EnterWhatsThisMode = 124,
        LeaveWhatsThisMode = 125,

        ZOrderChange = 126,

        HoverEnter = 127,
        HoverLeave = 128,
        HoverMove = 129,

        AccessibilityHelp = 119,
        AccessibilityDescription = 130,







        AcceptDropsChange = 152,

        User = 1000,
        MaxUser = 65535
    };

    QEvent(Type type);
    virtual ~QEvent();
    inline Type type() const { return static_cast<Type>(t); }
    inline bool spontaneous() const { return spont; }

    inline void setAccepted(bool accepted) { m_accept = accepted; }
    inline bool isAccepted() const { return m_accept; }

    inline void accept() { m_accept = true; }
    inline void ignore() { m_accept = false; }

protected:
    QEventPrivate *d;
    ushort t;

private:
    ushort posted : 1;
    ushort spont : 1;
    ushort m_accept : 1;
    ushort reserved : 13;

    friend class QCoreApplication;
    friend class QCoreApplicationPrivate;
    friend class QThreadData;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class Q3AccelManager;
    friend class QShortcutMap;
    friend class QETWidget;
};

class __declspec(dllimport) QTimerEvent : public QEvent
{
public:
    QTimerEvent( int timerId );
    ~QTimerEvent();
    int timerId() const { return id; }
protected:
    int id;
};

class QObject;

class __declspec(dllimport) QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child );
    ~QChildEvent();
    QObject *child() const { return c; }
    bool added() const { return type() == ChildAdded; }



    bool polished() const { return type() == ChildPolished; }
    bool removed() const { return type() == ChildRemoved; }
protected:
    QObject *c;
};

























































































typedef QtValidLicenseForCoreModule QtCoreModule;


typedef struct tagMSG MSG;


class QCoreApplicationPrivate;
class QTextCodec;
class QTranslator;
class QPostEventList;
class QStringList;

class __declspec(dllimport) QCoreApplication : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




    inline QCoreApplicationPrivate* d_func() { return reinterpret_cast<QCoreApplicationPrivate *>(d_ptr); } inline const QCoreApplicationPrivate* d_func() const { return reinterpret_cast<const QCoreApplicationPrivate *>(d_ptr); } friend class QCoreApplicationPrivate;
public:
    QCoreApplication(int &argc, char **argv);
    ~QCoreApplication();

    static int argc();
    static char **argv();

    static void setOrganizationDomain(const QString &orgDomain);
    static QString organizationDomain();
    static void setOrganizationName(const QString &orgName);
    static QString organizationName();
    static void setApplicationName(const QString &application);
    static QString applicationName();

    static QCoreApplication *instance() { return self; }

    static int exec();
    static void processEvents(QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEvents);
    static void processEvents(QEventLoop::ProcessEventsFlags flags, int maxtime);
    static void exit(int retcode=0);

    static bool sendEvent(QObject *receiver, QEvent *event);
    static void postEvent(QObject *receiver, QEvent *event);
    static void sendPostedEvents(QObject *receiver, int event_type);
    static void sendPostedEvents();
    static void removePostedEvents(QObject *receiver);
    static bool hasPendingEvents();

    virtual bool notify(QObject *, QEvent *);

    static bool startingUp();
    static bool closingDown();

    static QString applicationDirPath();
    static QString applicationFilePath();


    static void setLibraryPaths(const QStringList &);
    static QStringList libraryPaths();
    static void addLibraryPath(const QString &);
    static void removeLibraryPath(const QString &);



    static void installTranslator(QTranslator *);
    static void removeTranslator(QTranslator *);

    enum Encoding { DefaultCodec, UnicodeUTF8 };
    static QString translate(const char * context,
                             const char * key,
                             const char * comment = 0,
                             Encoding encoding = DefaultCodec);

    static void flush();















    virtual bool winEventFilter(MSG *message, long *result);






    typedef bool (*EventFilter)(void *message, long *result);
    EventFilter setEventFilter(EventFilter filter);
    bool filterEvent(void *message, long *result);

public :
    static void quit();

protected:
    void aboutToQuit();
    void unixSignal(int);

protected:
    bool event(QEvent *);

    virtual bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);

protected:
    QCoreApplication(QCoreApplicationPrivate &p);

private:
    static bool sendSpontaneousEvent(QObject *receiver, QEvent *event);

    void init();

    static QCoreApplication *self;

    friend class QEventDispatcherUNIXPrivate;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QETWidget;
    friend class Q3AccelManager;
    friend class QShortcutMap;
    friend class QWidget;
    friend class QWidgetPrivate;
    friend bool qt_sendSpontaneousEvent(QObject*, QEvent*);
};

inline bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
{  if (event) event->spont = false; return self ? self->notify(receiver, event) : false; }

inline bool QCoreApplication::sendSpontaneousEvent(QObject *receiver, QEvent *event)
{ if (event) event->spont = true; return self ? self->notify(receiver, event) : false; }

inline void QCoreApplication::sendPostedEvents() { sendPostedEvents(0, 0); }
















typedef void (*QtCleanUpFunction)();

__declspec(dllimport) void qAddPostRoutine(QtCleanUpFunction);
__declspec(dllimport) void qRemovePostRoutine(QtCleanUpFunction);
__declspec(dllimport) QString qAppName();


__declspec(dllimport) QString decodeMSG(const MSG &);
__declspec(dllimport) QDebug operator<<(QDebug, const MSG &);















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T> class QList;

class __declspec(dllimport) QMetaMethod
{
public:
    inline QMetaMethod() : mobj(0),handle(0) {}

    const char *signature() const;
    const char *typeName() const;
    QList<QByteArray> parameterTypes() const;
    QList<QByteArray> parameterNames() const;
    const char *tag() const;
    enum Access { Private, Protected, Public };
    Access access() const;
    enum MethodType { Method, Signal, Slot };
    MethodType methodType() const;
    enum Attributes { Compatibility = 0x1, Cloned = 0x2, Scriptable = 0x4 };
    int attributes() const;

private:
    const QMetaObject *mobj;
    uint handle;
    friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaMethod> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaMethod)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaMethod"; } };

class __declspec(dllimport) QMetaEnum
{
public:
    inline QMetaEnum() : mobj(0),handle(0) {}

    const char *name() const;
    bool isFlag() const;

    int keyCount() const;
    const char *key(int index) const;
    int value(int index) const;

    const char *scope() const;

    int keyToValue(const char *key) const;
    const char* valueToKey(int value) const;
    int keysToValue(const char * keys) const;
    QByteArray valueToKeys(int value) const;


    inline bool isValid() const { return name() != 0; }
private:
    const QMetaObject *mobj;
    uint handle;
    friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaEnum> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaEnum)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaEnum"; } };

class __declspec(dllimport) QMetaProperty
{
public:
    QMetaProperty();

    const char *name() const;
    const char *typeName() const;
    QVariant::Type type() const;

    bool isReadable() const;
    bool isWritable() const;
    bool isDesignable(const QObject *obj = 0) const;
    bool isScriptable(const QObject *obj = 0) const;
    bool isStored(const QObject *obj = 0) const;
    bool isEditable(const QObject *obj = 0) const;

    bool isFlagType() const;
    bool isEnumType() const;
    QMetaEnum enumerator() const;

    QVariant read(const QObject *obj) const;
    bool write(QObject *obj, const QVariant &value) const;
    bool reset(QObject *obj) const;

    bool hasStdCppSet() const;
    inline bool isValid() const { return isReadable(); }

private:
    const QMetaObject *mobj;
    uint handle;
    int idx;
    QMetaEnum menum;
    friend struct QMetaObject;
};

class __declspec(dllimport) QMetaClassInfo
{
public:
    inline QMetaClassInfo() : mobj(0),handle(0) {}
    const char *name() const;
    const char *value() const;
private:
    const QMetaObject *mobj;
    uint handle;
    friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaClassInfo> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaClassInfo)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaClassInfo"; } };








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QUrl;
class QMimeDataPrivate;

class __declspec(dllimport) QMimeData : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QMimeData();
    ~QMimeData();

    QList<QUrl> urls() const;
    void setUrls(const QList<QUrl> &urls);
    bool hasUrls() const;

    QString text() const;
    void setText(const QString &text);
    bool hasText() const;

    QString html() const;
    void setHtml(const QString &html);
    bool hasHtml() const;

    QVariant imageData() const;
    void setImageData(const QVariant &image);
    bool hasImage() const;

    QVariant colorData() const;
    void setColorData(const QVariant &color);
    bool hasColor() const;

    QByteArray data(const QString &mimetype) const;
    void setData(const QString &mimetype, const QByteArray &data);

    virtual bool hasFormat(const QString &mimetype) const;
    virtual QStringList formats() const;

    void clear();
protected:
    virtual QVariant retrieveData(const QString &mimetype,
                                      QVariant::Type preferredType) const;
private:
    QMimeData(const QMimeData &); QMimeData &operator=(const QMimeData &);
    inline QMimeDataPrivate* d_func() { return reinterpret_cast<QMimeDataPrivate *>(d_ptr); } inline const QMimeDataPrivate* d_func() const { return reinterpret_cast<const QMimeDataPrivate *>(d_ptr); } friend class QMimeDataPrivate;
};




























































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QObjectCleanupHandler : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QObjectCleanupHandler();
    ~QObjectCleanupHandler();

    QObject* add(QObject* object);
    void remove(QObject *object);
    bool isEmpty() const;
    void clear();

private:

    QObjectList cleanupObjects;

private :
    void objectDestroyed(QObject *);
};


































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;


class QSignalMapperPrivate;

class __declspec(dllimport) QSignalMapper : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QSignalMapperPrivate* d_func() { return reinterpret_cast<QSignalMapperPrivate *>(d_ptr); } inline const QSignalMapperPrivate* d_func() const { return reinterpret_cast<const QSignalMapperPrivate *>(d_ptr); } friend class QSignalMapperPrivate;
public:
    explicit QSignalMapper(QObject *parent = 0);
    ~QSignalMapper();

    void setMapping(QObject *sender, int id);
    void setMapping(QObject *sender, const QString &text);
    void setMapping(QObject *sender, QWidget *widget);
    void setMapping(QObject *sender, QObject *object);
    void removeMappings(QObject *sender);

    QObject *mapping(int id) const;
    QObject *mapping(const QString &text) const;
    QObject *mapping(QWidget *widget) const;
    QObject *mapping(QObject *object) const;

protected:
    void mapped(int);
    void mapped(const QString &);
    void mapped(QWidget *);
    void mapped(QObject *);

public :
    void map();
    void map(QObject *sender);

private:
    QSignalMapper(const QSignalMapper &); QSignalMapper &operator=(const QSignalMapper &);






};










































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QSocketNotifier : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    enum Type { Read, Write, Exception };

    QSocketNotifier(int socket, Type, QObject *parent = 0);



    ~QSocketNotifier();

    inline int socket() const { return sockfd; }
    inline Type type() const { return sntype; }

    inline bool isEnabled() const { return snenabled; }

public :
    void setEnabled(bool);

protected:
    void activated(int socket);

protected:
    bool event(QEvent *);

private:
    QSocketNotifier(const QSocketNotifier &); QSocketNotifier &operator=(const QSocketNotifier &);

    int sockfd;
    Type sntype;
    bool snenabled;
};





















































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QTimer : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:


public:
    explicit QTimer(QObject *parent = 0);



    ~QTimer();

    inline bool isActive() const { return id >= 0; }
    int timerId() const { return id; }

    void setInterval(int msec);
    int interval() const { return inter; }

    inline void setSingleShot(bool singleShot);
    inline bool isSingleShot() const { return single; }

    static void singleShot(int msec, QObject *receiver, const char *member);

public :
    void start(int msec);

    void start();
    void stop();






protected:
    void timeout();

protected:
    void timerEvent(QTimerEvent *);

private:
    QTimer(const QTimer &); QTimer &operator=(const QTimer &);

    inline int startTimer(int){ return -1;}
    inline void killTimer(int){}

    int id, inter, del;
    uint single : 1;
    uint nulltimer : 1;
};

inline void QTimer::setSingleShot(bool asingleShot) { single = asingleShot; }



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;



class QTranslatorPrivate;

class __declspec(dllimport) QTranslator : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QTranslator(QObject *parent = 0);



    ~QTranslator();

    virtual QString translate(const char *context, const char *sourceText, const char *comment = 0) const;
    virtual bool isEmpty() const;

    bool load(const QString & filename,
              const QString & directory = QString(),
              const QString & search_delimiters = QString(),
              const QString & suffix = QString());
    bool load(const uchar *data, int len);






private:
    QTranslator(const QTranslator &); QTranslator &operator=(const QTranslator &);
    inline QTranslatorPrivate* d_func() { return reinterpret_cast<QTranslatorPrivate *>(d_ptr); } inline const QTranslatorPrivate* d_func() const { return reinterpret_cast<const QTranslatorPrivate *>(d_ptr); } friend class QTranslatorPrivate;
};








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;



class QLibraryPrivate;

class __declspec(dllimport) QLibrary : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QLibrary(QObject *parent = 0);
    explicit QLibrary(const QString& fileName, QObject *parent = 0);
    ~QLibrary();

    void *resolve(const char *symbol);
    static void *resolve(const QString &fileName, const char *symbol);

    bool load();
    bool unload();
    bool isLoaded() const;

    static bool isLibrary(const QString &fileName);

    void setFileName(const QString &fileName);
    QString fileName() const;





private:
    QLibraryPrivate *d;
    bool did_load;
};


















































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QLibraryPrivate;

class __declspec(dllimport) QPluginLoader : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QPluginLoader(QObject *parent = 0);
    explicit QPluginLoader(const QString &fileName, QObject *parent = 0);
    ~QPluginLoader();

    QObject *instance();

    static QObjectList staticInstances();

    bool load();
    bool unload();
    bool isLoaded() const;

    void setFileName(const QString &fileName);
    QString fileName() const;
private:
    QLibraryPrivate *d;
    bool did_load;
};

































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;




typedef struct _GUID
{
    ulong   Data1;
    ushort  Data2;
    ushort  Data3;
    uchar   Data4[8];
} GUID, *REFGUID, *LPGUID;



struct __declspec(dllimport) QUuid
{
    enum Variant {
        VarUnknown        =-1,
        NCS                = 0,
        DCE                = 2,
        Microsoft        = 6,
        Reserved        = 7
    };

    enum Version {
        VerUnknown        =-1,
        Time                = 1,
        EmbeddedPOSIX        = 2,
        Name                = 3,
        Random                = 4
    };

    QUuid()
    {
        data1 = 0;
        data2 = 0;
        data3 = 0;
        for(int i = 0; i < 8; i++)
            data4[i] = 0;
    }
    QUuid(uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8)
    {
        data1 = l;
        data2 = w1;
        data3 = w2;
        data4[0] = b1;
        data4[1] = b2;
        data4[2] = b3;
        data4[3] = b4;
        data4[4] = b5;
        data4[5] = b6;
        data4[6] = b7;
        data4[7] = b8;
    }

    QUuid(const QString &);
    QUuid(const char *);
    QString toString() const;
    operator QString() const { return toString(); }

    bool isNull() const;

    bool operator==(const QUuid &orig) const
    {
        uint i;
        if (data1 != orig.data1 || data2 != orig.data2 ||
             data3 != orig.data3)
            return false;

        for(i = 0; i < 8; i++)
            if (data4[i] != orig.data4[i])
                return false;

        return true;
    }

    bool operator!=(const QUuid &orig) const
    {
        return !(*this == orig);
    }

    bool operator<(const QUuid &other) const;
    bool operator>(const QUuid &other) const;




    QUuid(const GUID &guid)
    {
        data1 = guid.Data1;
        data2 = guid.Data2;
        data3 = guid.Data3;
        for(int i = 0; i < 8; i++)
            data4[i] = guid.Data4[i];
    }

    QUuid &operator=(const GUID &guid)
    {
        *this = QUuid(guid);
        return *this;
    }

    operator GUID() const
    {
        GUID guid = { data1, data2, data3, { data4[0], data4[1], data4[2], data4[3], data4[4], data4[5], data4[6], data4[7] } };
        return guid;
    }

    bool operator==(const GUID &guid) const
    {
        return *this == QUuid(guid);
    }

    bool operator!=(const GUID &guid) const
    {
        return !(*this == guid);
    }

    static QUuid createUuid();
    QUuid::Variant variant() const;
    QUuid::Version version() const;

    uint    data1;
    ushort  data2;
    ushort  data3;
    uchar   data4[8];
};


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QUuid &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QUuid &);




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;



class QMutexPrivate;

class __declspec(dllimport) QMutex
{
    friend class QWaitCondition;
    friend class QWaitConditionPrivate;

public:
    enum RecursionMode { NonRecursive, Recursive };

    explicit QMutex(RecursionMode mode = NonRecursive);
    ~QMutex();

    void lock();
    bool tryLock();
    void unlock();















private:
    QMutex(const QMutex &); QMutex &operator=(const QMutex &);

    QMutexPrivate *d;
};

class __declspec(dllimport) QMutexLocker
{
public:
    inline explicit QMutexLocker(QMutex *m) : mtx(m) { relock(); }
    inline ~QMutexLocker() { unlock(); }

    inline void unlock() { if (mtx) mtx->unlock(); }

    inline void relock() { if (mtx) mtx->lock(); }

    inline QMutex *mutex() const { return mtx; }

private:
    QMutexLocker(const QMutexLocker &); QMutexLocker &operator=(const QMutexLocker &);

    QMutex *mtx;
};







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

struct QReadWriteLockPrivate;

class __declspec(dllimport) QReadWriteLock
{
public:
    QReadWriteLock();
    ~QReadWriteLock();

    void lockForRead();
    bool tryLockForRead();

    void lockForWrite();
    bool tryLockForWrite();

    void unlock();

private:
    QReadWriteLock(const QReadWriteLock &); QReadWriteLock &operator=(const QReadWriteLock &);
    QReadWriteLockPrivate *d;
};

class __declspec(dllimport) QReadLocker
{
public:
    inline QReadLocker(QReadWriteLock *readWriteLock);

    inline ~QReadLocker()
    { unlock(); }

    inline void unlock()
    { if (q_lock) q_lock->unlock(); }

    inline void relock()
    { if (q_lock) q_lock->lockForRead(); }

    inline QReadWriteLock *readWriteLock() const
    { return q_lock; }

private:
    QReadLocker(const QReadLocker &); QReadLocker &operator=(const QReadLocker &);
    QReadWriteLock *q_lock;
};

inline QReadLocker::QReadLocker(QReadWriteLock *areadWriteLock)
    : q_lock(areadWriteLock)
{ relock(); }

class __declspec(dllimport) QWriteLocker
{
public:
    inline QWriteLocker(QReadWriteLock *readWriteLock);

    inline ~QWriteLocker()
    { unlock(); }

    inline void unlock()
    { if (q_lock) q_lock->unlock(); }

    inline void relock()
    { if (q_lock) q_lock->lockForWrite(); }

    inline QReadWriteLock *readWriteLock() const
    { return q_lock; }

private:
    QWriteLocker(const QWriteLocker &); QWriteLocker &operator=(const QWriteLocker &);
    QReadWriteLock *q_lock;
};

inline QWriteLocker::QWriteLocker(QReadWriteLock *areadWriteLock)
    : q_lock(areadWriteLock)
{ relock(); }
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QSemaphorePrivate;

class __declspec(dllimport) QSemaphore
{
public:
    explicit QSemaphore(int n = 0);
    ~QSemaphore();

    void acquire(int n = 1);
    bool tryAcquire(int n = 1);

    void release(int n = 1);

    int available() const;

private:
    QSemaphore(const QSemaphore &); QSemaphore &operator=(const QSemaphore &);

    QSemaphorePrivate *d;
};












































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QThreadData;
class QThreadPrivate;


class __declspec(dllimport) QThread : public QObject
{
public:
    static Qt::HANDLE currentThreadId();
    static QThread *currentThread();

    explicit QThread(QObject *parent = 0);
    ~QThread();

    enum Priority {
        IdlePriority,

        LowestPriority,
        LowPriority,
        NormalPriority,
        HighPriority,
        HighestPriority,

        TimeCriticalPriority,

        InheritPriority
    };

    void setPriority(Priority priority);
    Priority priority() const;

    bool isFinished() const;
    bool isRunning() const;

    void setStackSize(uint stackSize);
    uint stackSize() const;

    void exit(int retcode = 0);

public :
    void start(QThread::Priority = InheritPriority);
    void terminate();
    void quit();

public:

    bool wait(unsigned long time = 0xffffffffUL);

protected:
    void started();
    void finished();
    void terminated();

protected:
    virtual void run() = 0;
    int exec();

    static void setTerminationEnabled(bool enabled = true);

    static void sleep(unsigned long);
    static void msleep(unsigned long);
    static void usleep(unsigned long);







private:
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QThreadPrivate* d_func() { return reinterpret_cast<QThreadPrivate *>(d_ptr); } inline const QThreadPrivate* d_func() const { return reinterpret_cast<const QThreadPrivate *>(d_ptr); } friend class QThreadPrivate;

    static void initialize();
    static void cleanup();

    friend class QCoreApplication;
    friend class QThreadData;
};




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QThreadStorageData
{
public:
    explicit QThreadStorageData(void (*func)(void *));
    ~QThreadStorageData();

    void** get() const;
    void** set(void* p);

    static void finish(void**);
    int id;
};





template <typename T>
inline
T *&qThreadStorage_localData(QThreadStorageData &d, T **)
{
    void **v = d.get();
    if (!v) v = d.set(0);
    return *(reinterpret_cast<T**>(v));
}

template <typename T>
inline
T *qThreadStorage_localData_const(const QThreadStorageData &d, T **)
{
    void **v = d.get();
    return v ? *(reinterpret_cast<T**>(v)) : 0;
}

template <typename T>
inline
void qThreadStorage_setLocalData(QThreadStorageData &d, T **t)
{ (void) d.set(*t); }































template <class T>
class QThreadStorage
{
private:
    QThreadStorageData d;

    QThreadStorage(const QThreadStorage &); QThreadStorage &operator=(const QThreadStorage &);

    static inline void deleteData(void *x)
    { delete reinterpret_cast<T&>(x); }

public:
    inline QThreadStorage() : d(deleteData) { }
    inline ~QThreadStorage() { }

    inline bool hasLocalData() const
    { return d.get() != 0; }

    inline T& localData()
    { return qThreadStorage_localData(d, reinterpret_cast<T*>(0)); }
    inline T localData() const
    { return qThreadStorage_localData_const(d, reinterpret_cast<T*>(0)); }

    inline void setLocalData(T t)
    { qThreadStorage_setLocalData(d, &t); }
};


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QWaitConditionPrivate;
class QMutex;


class __declspec(dllimport) QWaitCondition
{
public:
    QWaitCondition();
    ~QWaitCondition();

    bool wait(QMutex *mutex, unsigned long time = 0xffffffffUL);

    void wakeOne();
    void wakeAll();

private:
    QWaitCondition(const QWaitCondition &); QWaitCondition &operator=(const QWaitCondition &);

    QWaitConditionPrivate * d;
};




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QBitRef;
class __declspec(dllimport) QBitArray
{
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBitArray &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QBitArray &);
    QByteArray d;

public:
    inline QBitArray() {}
    explicit QBitArray(int size, bool val = false);
    QBitArray(const QBitArray &other) : d(other.d) {}
    inline QBitArray &operator=(const QBitArray &other) { d = other.d; return *this; }

    inline int size() const { return (d.size() << 3) - *d.constData(); }
    inline int count() const { return (d.size() << 3) - *d.constData(); }

    inline bool isEmpty() const { return d.isEmpty(); }
    inline bool isNull() const { return d.isNull(); }

    void resize(int size);

    inline void detach() { d.detach(); }
    inline bool isDetached() const { return d.isDetached(); }
    inline void clear() { d.clear(); }

    bool testBit(int i) const;
    void setBit(int i);
    void setBit(int i, bool val);
    void clearBit(int i);
    bool toggleBit(int i);

    bool at(int i) const;
    QBitRef operator[](int i);
    bool operator[](int i) const;
    QBitRef operator[](uint i);
    bool operator[](uint i) const;

    QBitArray& operator&=(const QBitArray &);
    QBitArray& operator|=(const QBitArray &);
    QBitArray& operator^=(const QBitArray &);
    QBitArray  operator~() const;

    inline bool operator==(const QBitArray& a) const { return d == a.d; }
    inline bool operator!=(const QBitArray& a) const { return d != a.d; }

    inline bool fill(bool val, int size = -1);
    void fill(bool val, int first, int last);

    inline void truncate(int pos) { if (pos < size()) resize(pos); }
};

inline bool QBitArray::fill(bool aval, int asize)
{ *this = QBitArray((asize < 0 ? this->size() : asize), aval); return true; }

__declspec(dllimport) QBitArray operator&(const QBitArray &, const QBitArray &);
__declspec(dllimport) QBitArray operator|(const QBitArray &, const QBitArray &);
__declspec(dllimport) QBitArray operator^(const QBitArray &, const QBitArray &);

inline bool QBitArray::testBit(int i) const
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbitarray.h",80);} while (0);
 return (*(reinterpret_cast<const uchar*>(d.constData())+1+(i>>3)) & (1 << (i & 7))) != 0; }

inline void QBitArray::setBit(int i)
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbitarray.h",84);} while (0);
 *(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) |= (1 << (i & 7)); }

inline void QBitArray::clearBit(int i)
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbitarray.h",88);} while (0);
 *(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) &= ~(1 << (i & 7)); }

inline void QBitArray::setBit(int i, bool val)
{ if (val) setBit(i); else clearBit(i); }

inline bool QBitArray::toggleBit(int i)
{ do {if(!(i >= 0 && i < size()))qt_assert("i >= 0 && i < size()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbitarray.h",95);} while (0);
 uchar b = 1<< (i&7); uchar* p = reinterpret_cast<uchar*>(d.data())+1+(i>>3);
 uchar c = *p&b; *p^=b; return c!=0; }

inline bool QBitArray::operator[](int i) const { return testBit(i); }
inline bool QBitArray::operator[](uint i) const { return testBit(i); }
inline bool QBitArray::at(int i) const { return testBit(i); }

class __declspec(dllimport) QBitRef
{
private:
    QBitArray& a;
    int i;
    inline QBitRef(QBitArray& array, int idx) : a(array), i(idx) {}
    friend class QBitArray;
public:
    inline operator bool() const { return a.testBit(i); }
    inline bool operator!() const { return !a.testBit(i); }
    QBitRef& operator=(const QBitRef& val) { a.setBit(i, val); return *this; }
    QBitRef& operator=(bool val) { a.setBit(i, val); return *this; }
};

inline QBitRef QBitArray::operator[](int i)
{ do {if(!(i >= 0))qt_assert("i >= 0","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qbitarray.h",118);} while (0); return QBitRef(*this, i); }
inline QBitRef QBitArray::operator[](uint i)
{ return QBitRef(*this, i); }



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBitArray &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QBitArray &);


template <> class QTypeInfo<QBitArray> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBitArray)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBitArray"; } };
template <> inline bool qIsDetached<QBitArray>(QBitArray &t) { return t.isDetached(); }







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArrayMatcherPrivate;

class __declspec(dllimport) QByteArrayMatcher
{
public:
    QByteArrayMatcher();
    explicit QByteArrayMatcher(const QByteArray &pattern);
    QByteArrayMatcher(const QByteArrayMatcher &other);
    ~QByteArrayMatcher();

    QByteArrayMatcher &operator=(const QByteArrayMatcher &other);

    void setPattern(const QByteArray &pattern);

    int indexIn(const QByteArray &ba, int from = 0) const;
    inline QByteArray pattern() const { return q_pattern; }

private:
    QByteArrayMatcherPrivate *d;
    QByteArray q_pattern;
    uint q_skiptable[256];
};

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QString;

inline uint qHash(char key) { return uint(key); }
inline uint qHash(uchar key) { return uint(key); }
inline uint qHash(signed char key) { return uint(key); }
inline uint qHash(ushort key) { return uint(key); }
inline uint qHash(short key) { return uint(key); }
inline uint qHash(uint key) { return key; }
inline uint qHash(int key) { return uint(key); }
inline uint qHash(ulong key)
{
    if (sizeof(ulong) > sizeof(uint)) {
        return uint((key >> (8 * sizeof(uint) - 1)) ^ key);
    } else {
        return uint(key);
    }
}
inline uint qHash(long key) { return qHash(ulong(key)); }
inline uint qHash(quint64 key)
{
    if (sizeof(quint64) > sizeof(uint)) {
        return uint((key >> (8 * sizeof(uint) - 1)) ^ key);
    } else {
        return uint(key);
    }
}
inline uint qHash(qint64 key) { return qHash(quint64(key)); }
inline uint qHash(QChar key) { return qHash(key.unicode()); }
__declspec(dllimport) uint qHash(const QByteArray &key);
__declspec(dllimport) uint qHash(const QString &key);

template <class T> inline uint qHash(const T *key)
{
    if (sizeof(const T *) > sizeof(uint))
        return qHash(reinterpret_cast<quint64>(key));
    else
        return uint(reinterpret_cast<ulong>(key));
}

struct __declspec(dllimport) QHashData
{
    struct Node {
        Node *next;
        uint h;
    };

    Node *fakeNext;
    Node **buckets;
    QBasicAtomic ref;
    int size;
    int nodeSize;
    short userNumBits;
    short numBits;
    int numBuckets;
    uint sharable : 1;

    void *allocateNode();
    void freeNode(void *node);
    QHashData *detach_helper(void (*node_duplicate)(Node *, void *), int nodeSize);
    void mightGrow();
    void hasShrunk();
    void rehash(int hint);
    void destroyAndFree();
    Node *firstNode();
    static Node *nextNode(Node *node);
    static Node *previousNode(Node *node);

    static QHashData shared_null;
};

inline void QHashData::mightGrow()
{
    if (size >= numBuckets)
        rehash(numBits + 1);
}

inline void QHashData::hasShrunk()
{
    if (size <= (numBuckets >> 3) && numBits > userNumBits)
        rehash(qMax(int(numBits) - 2, int(userNumBits)));
}

inline QHashData::Node *QHashData::firstNode()
{
    Node *e = reinterpret_cast<Node *>(this);
    Node **bucket = buckets;
    int n = numBuckets;
    while (n--) {
        if (*bucket != e)
            return *bucket;
        ++bucket;
    }
    return e;
}

struct QHashDummyValue
{
};

inline bool operator==(const QHashDummyValue & , const QHashDummyValue & )
{
    return true;
}

template <> class QTypeInfo<QHashDummyValue> { public: enum { isComplex = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QHashDummyValue)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QHashDummyValue"; } };

template <class Key, class T>
struct QHashDummyNode
{
    QHashDummyNode *next;
    uint h;
    Key key;

    inline QHashDummyNode(const Key &key0) : key(key0) {}
};

template <class Key, class T>
struct QHashNode
{
    QHashNode *next;
    uint h;
    Key key;
    T value;

    inline QHashNode(const Key &key0) : key(key0) {}
    inline QHashNode(const Key &key0, const T &value0) : key(key0), value(value0) {}
    inline bool same_key(uint h0, const Key &key0) { return h0 == h && key0 == key; }
};































template <class Key, class T>
class QHash
{
    typedef QHashDummyNode<Key, T> DummyNode;
    typedef QHashNode<Key, T> Node;

    union {
        QHashData *d;
        QHashNode<Key, T> *e;
    };

    static inline Node *concrete(QHashData::Node *node) {
        return reinterpret_cast<Node *>(node);
    }

public:
    inline QHash() : d(&QHashData::shared_null) { d->ref.ref(); }
    inline QHash(const QHash<Key, T> &other) : d(other.d) { d->ref.ref(); if (!d->sharable) detach(); }
    inline ~QHash() { if (!d->ref.deref()) freeData(d); }

    QHash<Key, T> &operator=(const QHash<Key, T> &other);

    bool operator==(const QHash<Key, T> &other) const;
    inline bool operator!=(const QHash<Key, T> &other) const { return !(*this == other); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    inline int capacity() const { return d->numBuckets; }
    void reserve(int size);
    inline void squeeze() { reserve(1); }

    inline void detach() { if (d->ref != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref == 1; }
    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

    void clear();

    int remove(const Key &key);
    T take(const Key &key);

    bool contains(const Key &key) const;
    const Key key(const T &value) const;
    const T value(const Key &key) const;
    const T value(const Key &key, const T &defaultValue) const;
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;

    QList<Key> keys() const;
    QList<Key> keys(const T &value) const;
    QList<T> values() const;
    QList<T> values(const Key &key) const;
    int count(const Key &key) const;

    class const_iterator;

    class iterator
    {
        QHashData::Node *i;
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline operator Node *() const { return concrete(i); }
        inline iterator() : i(0) { }
        explicit inline iterator(void *node) : i(reinterpret_cast<QHashData::Node *>(node)) { }

        inline const Key &key() const { return concrete(i)->key; }
        inline T &value() const { return concrete(i)->value; }
        inline T &operator*() const { return concrete(i)->value; }
        inline T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == reinterpret_cast<const iterator &>(o).i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != reinterpret_cast<const iterator &>(o).i; }

        inline iterator &operator++() {
            i = QHashData::nextNode(i);
            return *this;
        }
        inline iterator operator++(int) {
            iterator r = *this;
            i = QHashData::nextNode(i);
            return r;
        }
        inline iterator &operator--() {
            i = QHashData::previousNode(i);
            return *this;
        }
        inline iterator operator--(int) {
            iterator r = *this;
            i = QHashData::previousNode(i);
            return r;
        }
        inline iterator operator+(int j) const
        { iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class iterator;

    class const_iterator
    {
        QHashData::Node *i;
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline operator Node *() const { return concrete(i); }
        inline const_iterator() : i(0) { }
        explicit inline const_iterator(void *node)
            : i(reinterpret_cast<QHashData::Node *>(node)) { }
        inline const_iterator(const iterator &o)
        { i = reinterpret_cast<const const_iterator &>(o).i; }

        inline const Key &key() const { return concrete(i)->key; }
        inline const T &value() const { return concrete(i)->value; }
        inline const T &operator*() const { return concrete(i)->value; }
        inline const T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }

        inline const_iterator &operator++() {
            i = QHashData::nextNode(i);
            return *this;
        }
        inline const_iterator operator++(int) {
            const_iterator r = *this;
            i = QHashData::nextNode(i);
            return r;
        }
        inline const_iterator &operator--() {
            i = QHashData::previousNode(i);
            return *this;
        }
        inline const_iterator operator--(int) {
            const_iterator r = *this;
            i = QHashData::previousNode(i);
            return r;
        }
        inline const_iterator operator+(int j) const
        { const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(d->firstNode()); }
    inline const_iterator begin() const { return const_iterator(d->firstNode()); }
    inline const_iterator constBegin() const { return const_iterator(d->firstNode()); }
    inline iterator end() { detach(); return iterator(e); }
    inline const_iterator end() const { return const_iterator(e); }
    inline const_iterator constEnd() const { return const_iterator(e); }
    iterator erase(iterator it);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    iterator find(const Key &key);
    const_iterator find(const Key &key) const;
    iterator insert(const Key &key, const T &value);
    iterator insertMulti(const Key &key, const T &value);
    QHash<Key, T> &unite(const QHash<Key, T> &other);


    inline bool empty() const { return isEmpty(); }

private:
    void detach_helper();
    void freeData(QHashData *d);
    Node **findNode(const Key &key, uint *hp = 0) const;
    Node *createNode(uint h, const Key &key, const T &value, Node **nextNode);
    void deleteNode(Node *node);

    static void duplicateNode(QHashData::Node *originalNode, void *newNode);
};

template <class Key, class T>
inline void QHash<Key, T>::deleteNode(Node *node)
{



    node->~QHashNode();



    d->freeNode(node);
}

template <class Key, class T>
inline void QHash<Key, T>::duplicateNode(QHashData::Node *node, void *newNode)
{
    Node *concreteNode = concrete(node);
    if (QTypeInfo<T>::isDummy) {
        (void) new (newNode) DummyNode(concreteNode->key);
    } else {
        (void) new (newNode) Node(concreteNode->key, concreteNode->value);
    }
}

template <class Key, class T>
inline typename QHash<Key, T>::Node *
QHash<Key, T>::createNode(uint ah, const Key &akey, const T &avalue, Node **anextNode)
{
    Node *node;

    if (QTypeInfo<T>::isDummy) {
        node = reinterpret_cast<Node *>(new (d->allocateNode()) DummyNode(akey));
    } else {
        node = new (d->allocateNode()) Node(akey, avalue);
    }

    node->h = ah;
    node->next = *anextNode;
    *anextNode = node;
    ++d->size;
    return node;
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::unite(const QHash<Key, T> &other)
{
    QHash<Key, T> copy(other);
    const_iterator it = copy.constEnd();
    while (it != copy.constBegin()) {
        --it;
        insertMulti(it.key(), it.value());
    }
    return *this;
}

template <class Key, class T>
inline void QHash<Key, T>::freeData(QHashData *x)
{
    Node *e_for_x = reinterpret_cast<Node *>(x);
    Node **bucket = reinterpret_cast<Node **>(x->buckets);
    int n = x->numBuckets;
    while (n--) {
        Node *cur = *bucket++;
        while (cur != e_for_x) {
            Node *next = cur->next;
            deleteNode(cur);
            cur = next;
        }
    }
    x->destroyAndFree();
}

template <class Key, class T>
inline void QHash<Key, T>::clear()
{
    *this = QHash<Key,T>();
}

template <class Key, class T>
inline void QHash<Key, T>::detach_helper()
{
    size_t asize;
    if (QTypeInfo<T>::isDummy) {
        asize = reinterpret_cast<char *>(&reinterpret_cast<Node *>(&QHashData::shared_null)->value)
               - reinterpret_cast<char *>(&QHashData::shared_null);
    } else {
        asize = sizeof(Node);
    }

    QHashData *x = d->detach_helper(duplicateNode, int(asize));
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        freeData(x);
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::operator=(const QHash<Key, T> &other)
{
    if (d != other.d) {
        QHashData *x = other.d;
        x->ref.ref();
        x = qAtomicSetPtr(&d, x);
        if (!x->ref.deref())
            freeData(x);
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey) const
{
    Node *node = *findNode(akey);
    if (node == e) {
        return T();
    } else {
        return node->value;
    }
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
    Node *node = *findNode(akey);
    if (node == e) {
        return adefaultValue;
    } else {
        return node->value;
    }
}

template <class Key, class T>
inline QList<Key> QHash<Key, T>::keys() const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<Key> QHash<Key, T>::keys(const T &avalue) const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline const Key QHash<Key, T>::key(const T &avalue) const
{
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            return i.key();
        ++i;
    }

    return Key();
}

template <class Key, class T>
inline QList<T> QHash<Key, T>::values() const
{
    QList<T> res;
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.value());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<T> QHash<Key, T>::values(const Key &akey) const
{
    QList<T> res;
    Node *node = *findNode(akey);
    if (node != e) {
        do {
            res.append(node->value);
        } while ((node = node->next) != e && node->key == akey);
    }
    return res;
}

template <class Key, class T>
inline int QHash<Key, T>::count(const Key &akey) const
{
    int cnt = 0;
    Node *node = *findNode(akey);
    if (node != e) {
        do {
            ++cnt;
        } while ((node = node->next) != e && node->key == akey);
    }
    return cnt;
}

template <class Key, class T>
inline const T QHash<Key, T>::operator[](const Key &akey) const
{
    return value(akey);
}

template <class Key, class T>
inline T &QHash<Key, T>::operator[](const Key &akey)
{
    detach();
    d->mightGrow();

    uint h;
    Node **node = findNode(akey, &h);
    if (*node == e)
        return createNode(h, akey, T(), node)->value;
    return (*node)->value;
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insert(const Key &akey,
                                                                         const T &avalue)
{
    detach();
    d->mightGrow();

    uint h;
    Node **node = findNode(akey, &h);
    if (*node == e)
        return iterator(createNode(h, akey, avalue, node));

    if (!QTypeInfo<T>::isDummy)
        (*node)->value = avalue;
    return iterator(*node);
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insertMulti(const Key &akey,
                                                                              const T &avalue)
{
    detach();
    d->mightGrow();

    uint h;
    Node **nextNode = findNode(akey, &h);
    return iterator(createNode(h, akey, avalue, nextNode));
}

template <class Key, class T>
inline int QHash<Key, T>::remove(const Key &akey)
{
    detach();

    int oldSize = d->size;
    Node **node = findNode(akey);
    if (*node != e) {
        bool deleteNext = true;
        do {
            Node *next = (*node)->next;
            deleteNext = (next != e && next->key == (*node)->key);
            deleteNode(*node);
            *node = next;
            --d->size;
        } while (deleteNext);
        d->hasShrunk();
    }
    return oldSize - d->size;
}

template <class Key, class T>
inline T QHash<Key, T>::take(const Key &akey)
{
    detach();

    Node **node = findNode(akey);
    if (*node != e) {
        T t = (*node)->value;
        Node *next = (*node)->next;
        deleteNode(*node);
        *node = next;
        --d->size;
        d->hasShrunk();
        return t;
    }
    return T();
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::erase(iterator it)
{
    if (it == iterator(e))
        return it;

    iterator ret = it;
    ++ret;

    Node *node = it;
    Node **node_ptr = reinterpret_cast<Node **>(&d->buckets[node->h % d->numBuckets]);
    while (*node_ptr != node)
        node_ptr = &(*node_ptr)->next;
    *node_ptr = node->next;
    deleteNode(node);
    --d->size;
    return ret;
}

template <class Key, class T>
inline void QHash<Key, T>::reserve(int asize)
{
    detach();
    d->rehash(-qMax(asize, 1));
}

template <class Key, class T>
inline typename QHash<Key, T>::const_iterator QHash<Key, T>::find(const Key &akey) const
{
    return const_iterator(*findNode(akey));
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::find(const Key &akey)
{
    detach();
    return iterator(*findNode(akey));
}

template <class Key, class T>
inline bool QHash<Key, T>::contains(const Key &akey) const
{
    return *findNode(akey) != e;
}

template <class Key, class T>
inline typename QHash<Key, T>::Node **QHash<Key, T>::findNode(const Key &akey,
                                                                            uint *ahp) const
{
    Node **node;
    uint h = qHash(akey);

    if (d->numBuckets) {
        node = reinterpret_cast<Node **>(&d->buckets[h % d->numBuckets]);
        while (*node != e && !(*node)->same_key(h, akey))
            node = &(*node)->next;
    } else {
        node = const_cast<Node **>(reinterpret_cast<const Node * const *>(&e));
    }
    if (ahp)
        *ahp = h;
    return node;
}

template <class Key, class T>
inline bool QHash<Key, T>::operator==(const QHash<Key, T> &other) const
{
    if (size() != other.size())
        return false;
    if (d == other.d)
        return true;

    const_iterator it1 = begin();
    const_iterator it2 = other.begin();

    while (it1 != end()) {
        if (!(it1.key() == it2.key()))
            return false;
        if (!QTypeInfo<T>::isDummy && !(it1.value() == it2.value()))
            return false;
        ++it2;
        ++it1;
    }
    return true;
}

template <class Key, class T>
class QMultiHash : public QHash<Key, T>
{
public:
    QMultiHash() {}
    QMultiHash(const QHash<Key, T> &other) : QHash<Key, T>(other) {}

    inline typename QHash<Key, T>::iterator replace(const Key &key, const T &value);
    inline typename QHash<Key, T>::iterator insert(const Key &key, const T &value);

    inline QMultiHash &operator+=(const QMultiHash &other)
    { unite(other); return *this; }
    inline QMultiHash operator+(const QMultiHash &other) const
    { QMultiHash result = *this; result += other; return result; }

private:
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;
};

template <class Key, class T>
inline  QHash<Key, T>::iterator QMultiHash<Key, T>::replace(const Key &akey, const T &avalue)
{ return QHash<Key, T>::insert(akey, avalue); }

template <class Key, class T>
inline  QHash<Key, T>::iterator QMultiHash<Key, T>::insert(const Key &akey, const T &avalue)
{ return QHash<Key, T>::insertMulti(akey, avalue); }


template <class Key, class T> class QHashIterator { typedef typename QHash<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QHash<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QHashIterator(const QHash<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QHashIterator &operator=(const QHash<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qhash.h",784);} while (0); return *n; } inline const Key &key() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qhash.h",784);} while (0); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableHashIterator { typedef typename QHash<Key,T>::iterator iterator; typedef iterator Item; QHash<Key,T> *c; iterator i, n; inline bool item_exists() const { return n != c->constEnd(); } public: inline QMutableHashIterator(QHash<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableHashIterator() { c->setSharable(true); } inline QMutableHashIterator &operator=(QHash<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return i != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (n != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (n != c->constEnd()) *n = t; } inline T &value() { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qhash.h",785);} while (0); return *n; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qhash.h",785);} while (0); return *n; } inline const Key &key() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qhash.h",785);} while (0); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };





typedef QtValidLicenseForCoreModule QtCoreModule;

template <class Key, class T>
class QCache
{
    struct Node {
        inline Node() {}
        inline Node(const Key &key, T *data, int cost)
            : k(key), t(data), c(cost), p(0), n(0) {}
        Key k; T *t; int c; Node *p,*n;
    };
    Node *f, *l;
    QHash<Key, Node> hash;
    QHash<int, Node> serial;
    int mx, total;
    inline void unlink(Node &n) {
        if (n.p) n.p->n = n.n;
        if (n.n) n.n->p = n.p;
        if (l == &n) l = n.p;
        if (f == &n) f = n.n;
        total -= n.c;
        delete n.t;
        hash.remove(Key(n.k));
    }
    inline T *&relink(const Key &key) {
        Node &n = hash[key];
        if (f != &n) {
            if (n.p) n.p->n = n.n;
            if (n.n) n.n->p = n.p;
            if (l == &n) l = n.p;
            n.p = 0;
            n.n = f;
            f->p = &n;
            f = &n;
        }
        return n.t;
    }

    QCache(const QCache &); QCache &operator=(const QCache &);

public:
    inline explicit QCache(int maxCost = 100);




    inline ~QCache() { clear(); }

    inline int maxCost() const { return mx; }
    void setMaxCost(int m);
    inline int totalCost() const { return total; }

    inline int size() const { return hash.size(); }
    inline int count() const { return hash.size(); }
    inline bool isEmpty() const { return hash.isEmpty(); }
    inline QList<Key> keys() const { return hash.keys(); }

    void clear();

    bool insert(const Key &key, T *object, int cost = 1);
    T *object(const Key &key) const;
    inline bool contains(const Key &key) const { return hash.contains(key); }
    T *operator[](const Key &key) const;

    bool remove(const Key &key);
    T *take(const Key &key);

private:
    void trim(int m);





};

template <class Key, class T>
inline QCache<Key, T>::QCache(int amaxCost)
    : f(0), l(0), mx(amaxCost), total(0) {}

template <class Key, class T>
inline void QCache<Key,T>::clear()
{ while (f) { delete f->t; f = f->n; }
 hash.clear(); l = 0; total = 0; }

template <class Key, class T>
inline void QCache<Key,T>::setMaxCost(int m)
{ mx = m; trim(mx); }

template <class Key, class T>
inline T *QCache<Key,T>::object(const Key &key) const
{ if (!hash.contains(key)) return 0;
 return const_cast<QCache<Key,T>*>(this)->relink(key); }

template <class Key, class T>
inline T *QCache<Key,T>::operator[](const Key &key) const
{ return object(key); }

template <class Key, class T>
inline bool QCache<Key,T>::remove(const Key &key)
{ if (hash.contains(key)) { unlink(hash[key]); return true; } return false; }

template <class Key, class T>
inline T *QCache<Key,T>::take(const Key &key)
{ if (!hash.contains(key)) return 0;
 Node &n = hash[key]; T *t = n.t; n.t = 0; unlink(n); return t; }

template <class Key, class T>
bool QCache<Key,T>::insert(const Key &akey, T *aobject, int acost)
{
    remove(akey);
    if (acost > mx) {
        delete aobject;
        return false;
    }
    trim(mx - acost);
    Node sn(akey, aobject, acost);
    hash.insert(akey, sn);
    total += acost;
    Node *n = &hash[akey];
    if (f) f->p = n;
    n->n = f;
    f = n;
    if (!l) l = f;
    return true;
}

template <class Key, class T>
void QCache<Key,T>::trim(int m)
{
    Node *n = l;
    while (n && total > m) {
        Node *u = n;
        n = n->p;
        if (qIsDetached(*u->t))
            unlink(*u);
    }
}


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QDate
{
public:
    QDate() { jd = 0; }
    QDate(int y, int m, int d);

    bool isNull() const { return jd == 0; }
    bool isValid() const;

    int year() const;
    int month() const;
    int day() const;
    int dayOfWeek() const;
    int dayOfYear() const;
    int daysInMonth() const;
    int daysInYear() const;
    int weekNumber(int *yearNum = 0) const;






    static QString shortMonthName(int month);
    static QString shortDayName(int weekday);
    static QString longMonthName(int month);
    static QString longDayName(int weekday);


    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;

    bool setYMD(int y, int m, int d);

    QDate addDays(int days) const;
    QDate addMonths(int months) const;
    QDate addYears(int years) const;
    int daysTo(const QDate &) const;

    bool operator==(const QDate &other) const { return jd == other.jd; }
    bool operator!=(const QDate &other) const { return jd != other.jd; }
    bool operator<(const QDate &other) const { return jd < other.jd; }
    bool operator<=(const QDate &other) const { return jd <= other.jd; }
    bool operator>(const QDate &other) const { return jd > other.jd; }
    bool operator>=(const QDate &other) const { return jd >= other.jd; }

    static QDate currentDate();

    static QDate fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);

    static QDate fromString(const QString &s, const QString &format);
    static bool isValid(int y, int m, int d);
    static bool isLeapYear(int year);




    static uint gregorianToJulian(int y, int m, int d);
    static void julianToGregorian(uint jd, int &y, int &m, int &d);





    static inline QDate fromJulianDay(int jd) { QDate d; d.jd = jd; return d; }
    inline int toJulianDay() const { return jd; }

private:
    uint jd;

    friend class QDateTime;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDate &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QDate &);

};
template <> class QTypeInfo<QDate> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDate)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QDate"; } };

class __declspec(dllimport) QTime
{
public:
    QTime(): mds(NullTime) {}
    QTime(int h, int m, int s = 0, int ms = 0);

    bool isNull() const { return mds == NullTime; }
    bool isValid() const;

    int hour() const;
    int minute() const;
    int second() const;
    int msec() const;

    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;

    bool setHMS(int h, int m, int s, int ms = 0);

    QTime addSecs(int secs) const;
    int secsTo(const QTime &) const;
    QTime addMSecs(int ms) const;
    int msecsTo(const QTime &) const;

    bool operator==(const QTime &other) const { return mds == other.mds; }
    bool operator!=(const QTime &other) const { return mds != other.mds; }
    bool operator<(const QTime &other) const { return mds < other.mds; }
    bool operator<=(const QTime &other) const { return mds <= other.mds; }
    bool operator>(const QTime &other) const { return mds > other.mds; }
    bool operator>=(const QTime &other) const { return mds >= other.mds; }

    static QTime currentTime();

    static QTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);

    static QTime fromString(const QString &s, const QString &format);
    static bool isValid(int h, int m, int s, int ms = 0);






    void start();
    int restart();
    int elapsed() const;

private:
    enum { NullTime = -1 };
    inline int ds() const { return mds == -1 ? 0 : mds; }
    int mds;

    friend class QDateTime;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTime &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTime &);

};
template <> class QTypeInfo<QTime> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTime)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTime"; } };

class QDateTimePrivate;

class __declspec(dllimport) QDateTime
{
public:
    QDateTime();
    explicit QDateTime(const QDate &);
    QDateTime(const QDate &, const QTime &, Qt::TimeSpec spec = Qt::LocalTime);
    QDateTime(const QDateTime &other);
    ~QDateTime();

    QDateTime &operator=(const QDateTime &other);

    bool isNull() const;
    bool isValid() const;

    QDate date() const;
    QTime time() const;
    Qt::TimeSpec timeSpec() const;
    uint toTime_t() const;
    void setDate(const QDate &date);
    void setTime(const QTime &time);
    void setTimeSpec(Qt::TimeSpec spec);
    void setTime_t(uint secsSince1Jan1970UTC);

    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;

    QDateTime addDays(int days) const;
    QDateTime addMonths(int months) const;
    QDateTime addYears(int years) const;
    QDateTime addSecs(int secs) const;
    QDateTime toTimeSpec(Qt::TimeSpec spec) const;
    inline QDateTime toLocalTime() const { return toTimeSpec(Qt::LocalTime); }
    inline QDateTime toUTC() const { return toTimeSpec(Qt::UTC); }
    int daysTo(const QDateTime &) const;
    int secsTo(const QDateTime &) const;

    bool operator==(const QDateTime &other) const;
    inline bool operator!=(const QDateTime &other) const { return !(*this == other); }
    bool operator<(const QDateTime &other) const;
    inline bool operator<=(const QDateTime &other) const { return !(other < *this); }
    inline bool operator>(const QDateTime &other) const { return other < *this; }
    inline bool operator>=(const QDateTime &other) const { return !(*this < other); }

    static QDateTime currentDateTime();

    static QDateTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);

    static QDateTime fromString(const QString &s, const QString &format);















private:
    void detach();
    QDateTimePrivate *d;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDateTime &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QDateTime &);

};
template <> class QTypeInfo<QDateTime> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDateTime)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QDateTime"; } };




















__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDate &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QDate &);
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTime &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTime &);
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDateTime &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QDateTime &);



__declspec(dllimport) QDebug operator<<(QDebug, const QDate &);
__declspec(dllimport) QDebug operator<<(QDebug, const QTime &);
__declspec(dllimport) QDebug operator<<(QDebug, const QDateTime &);







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QPoint
{
public:
    QPoint();
    QPoint(int xpos, int ypos);

    bool isNull() const;

    int x() const;
    int y() const;
    void setX(int x);
    void setY(int y);

    int manhattanLength() const;

    int &rx();
    int &ry();

    QPoint &operator+=(const QPoint &p);
    QPoint &operator-=(const QPoint &p);
    QPoint &operator*=(qreal c);
    QPoint &operator/=(qreal c);

    friend inline bool operator==(const QPoint &, const QPoint &);
    friend inline bool operator!=(const QPoint &, const QPoint &);
    friend inline const QPoint operator+(const QPoint &, const QPoint &);
    friend inline const QPoint operator-(const QPoint &, const QPoint &);
    friend inline const QPoint operator*(const QPoint &, qreal);
    friend inline const QPoint operator*(qreal, const QPoint &);
    friend inline const QPoint operator-(const QPoint &);
    friend inline const QPoint operator/(const QPoint &, qreal);

private:





    int xp;
    int yp;

};

template <> class QTypeInfo<QPoint> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPoint)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPoint"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPoint &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPoint &);






inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint(int xpos, int ypos)
{ xp = xpos; yp = ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX(int xpos)
{ xp = xpos; }

inline void QPoint::setY(int ypos)
{ yp = ypos; }

inline int &QPoint::rx()
{ return xp; }

inline int &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=(const QPoint &p)
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=(const QPoint &p)
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=(qreal c)
{ xp = qRound(xp*c); yp = qRound(yp*c); return *this; }

inline bool operator==(const QPoint &p1, const QPoint &p2)
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=(const QPoint &p1, const QPoint &p2)
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline const QPoint operator+(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline const QPoint operator-(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline const QPoint operator*(const QPoint &p, qreal c)
{ return QPoint(qRound(p.xp*c), qRound(p.yp*c)); }

inline const QPoint operator*(qreal c, const QPoint &p)
{ return QPoint(qRound(p.xp*c), qRound(p.yp*c)); }

inline const QPoint operator-(const QPoint &p)
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=(qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qpoint.h",137);} while (0);
    xp = qRound(xp/c);
    yp = qRound(yp/c);
    return *this;
}

inline const QPoint operator/(const QPoint &p, qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qpoint.h",145);} while (0);
    return QPoint(qRound(p.xp/c), qRound(p.yp/c));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QPoint &);






class __declspec(dllimport) QPointF
{
public:
    QPointF();
    QPointF(const QPoint &p);
    QPointF(qreal xpos, qreal ypos);

    bool isNull() const;

    qreal x() const;
    qreal y() const;
    void setX(qreal x);
    void setY(qreal y);

    qreal &rx();
    qreal &ry();

    QPointF &operator+=(const QPointF &p);
    QPointF &operator-=(const QPointF &p);
    QPointF &operator*=(qreal c);
    QPointF &operator/=(qreal c);

    friend inline bool operator==(const QPointF &, const QPointF &);
    friend inline bool operator!=(const QPointF &, const QPointF &);
    friend inline const QPointF operator+(const QPointF &, const QPointF &);
    friend inline const QPointF operator-(const QPointF &, const QPointF &);
    friend inline const QPointF operator*(qreal, const QPointF &);
    friend inline const QPointF operator*(const QPointF &, qreal);
    friend inline const QPointF operator-(const QPointF &);
    friend inline const QPointF operator/(const QPointF &, qreal);

    QPoint toPoint() const;

private:
    friend class QMatrix;

    qreal xp;
    qreal yp;
};

template <> class QTypeInfo<QPointF> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPointF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPointF"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPointF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPointF &);






inline QPointF::QPointF() : xp(0), yp(0) { }

inline QPointF::QPointF(qreal xpos, qreal ypos) : xp(xpos), yp(ypos) { }

inline QPointF::QPointF(const QPoint &p) : xp(p.x()), yp(p.y()) { }

inline bool QPointF::isNull() const
{
    return qFuzzyCompare(xp, 0) && qFuzzyCompare(yp, 0);
}

inline qreal QPointF::x() const
{
    return xp;
}

inline qreal QPointF::y() const
{
    return yp;
}

inline void QPointF::setX(qreal xpos)
{
    xp = xpos;
}

inline void QPointF::setY(qreal ypos)
{
    yp = ypos;
}

inline qreal &QPointF::rx()
{
    return xp;
}

inline qreal &QPointF::ry()
{
    return yp;
}

inline QPointF &QPointF::operator+=(const QPointF &p)
{
    xp+=p.xp;
    yp+=p.yp;
    return *this;
}

inline QPointF &QPointF::operator-=(const QPointF &p)
{
    xp-=p.xp; yp-=p.yp; return *this;
}

inline QPointF &QPointF::operator*=(qreal c)
{
    xp*=c; yp*=c; return *this;
}

inline bool operator==(const QPointF &p1, const QPointF &p2)
{
    return qFuzzyCompare(p1.xp, p2.xp) && qFuzzyCompare(p1.yp, p2.yp);
}

inline bool operator!=(const QPointF &p1, const QPointF &p2)
{
    return !qFuzzyCompare(p1.xp, p2.xp) || !qFuzzyCompare(p1.yp, p2.yp);
}

inline const QPointF operator+(const QPointF &p1, const QPointF &p2)
{
    return QPointF(p1.xp+p2.xp, p1.yp+p2.yp);
}

inline const QPointF operator-(const QPointF &p1, const QPointF &p2)
{
    return QPointF(p1.xp-p2.xp, p1.yp-p2.yp);
}

inline const QPointF operator*(const QPointF &p, qreal c)
{
    return QPointF(p.xp*c, p.yp*c);
}

inline const QPointF operator*(qreal c, const QPointF &p)
{
    return QPointF(p.xp*c, p.yp*c);
}

inline const QPointF operator-(const QPointF &p)
{
    return QPointF(-p.xp, -p.yp);
}

inline QPointF &QPointF::operator/=(qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qpoint.h",306);} while (0);
    xp/=c;
    yp/=c;
    return *this;
}

inline const QPointF operator/(const QPointF &p, qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qpoint.h",314);} while (0);
    return QPointF(p.xp/c, p.yp/c);
}

inline QPoint QPointF::toPoint() const
{
    return QPoint(qRound(xp), qRound(yp));
}


__declspec(dllimport) QDebug operator<<(QDebug d, const QPointF &p);






typedef QtValidLicenseForCoreModule QtCoreModule;





class __declspec(dllimport) QLine
{
public:
    inline QLine();
    inline QLine(const QPoint &pt1, const QPoint &pt2);
    inline QLine(int x1, int y1, int x2, int y2);

    inline bool isNull() const;

    inline QPoint p1() const;
    inline QPoint p2() const;

    inline int x1() const;
    inline int y1() const;

    inline int x2() const;
    inline int y2() const;

    inline int dx() const;
    inline int dy() const;

    inline void translate(const QPoint &p);
    inline void translate(int dx, int dy);

    inline bool operator==(const QLine &d) const;
    inline bool operator!=(const QLine &d) const { return !(*this == d); }

private:
    QPoint pt1, pt2;
};
template <> class QTypeInfo<QLine> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLine)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLine"; } };





inline QLine::QLine() { }

inline QLine::QLine(const QPoint &pt1_, const QPoint &pt2_) : pt1(pt1_), pt2(pt2_) { }

inline QLine::QLine(int x1pos, int y1pos, int x2pos, int y2pos) : pt1(QPoint(x1pos, y1pos)), pt2(QPoint(x2pos, y2pos)) { }

inline bool QLine::isNull() const
{
    return pt1 == pt2;
}

inline int QLine::x1() const
{
    return pt1.x();
}

inline int QLine::y1() const
{
    return pt1.y();
}

inline int QLine::x2() const
{
    return pt2.x();
}

inline int QLine::y2() const
{
    return pt2.y();
}

inline QPoint QLine::p1() const
{
    return pt1;
}

inline QPoint QLine::p2() const
{
    return pt2;
}

inline int QLine::dx() const
{
    return pt2.x() - pt1.x();
}

inline int QLine::dy() const
{
    return pt2.y() - pt1.y();
}

inline void QLine::translate(const QPoint &point)
{
    pt1 += point;
    pt2 += point;
}

inline void QLine::translate(int adx, int ady)
{
    this->translate(QPoint(adx, ady));
}

inline bool QLine::operator==(const QLine &d) const
{
    return pt1 == d.pt1 && pt2 == d.pt2;
}


__declspec(dllimport) QDebug operator<<(QDebug d, const QLine &p);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLine &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLine &);





class __declspec(dllimport) QLineF {
public:

    enum IntersectType { NoIntersection, BoundedIntersection, UnboundedIntersection };

    inline QLineF();
    inline QLineF(const QPointF &pt1, const QPointF &pt2);
    inline QLineF(qreal x1, qreal y1, qreal x2, qreal y2);
    inline QLineF(const QLine &line) : pt1(line.p1()), pt2(line.p2()) { }

    bool isNull() const;

    inline QPointF p1() const;
    inline QPointF p2() const;

    inline qreal x1() const;
    inline qreal y1() const;

    inline qreal x2() const;
    inline qreal y2() const;

    inline qreal dx() const;
    inline qreal dy() const;

    qreal length() const;
    void setLength(qreal len);

    QLineF unitVector() const;
    QLineF normalVector() const;

    IntersectType intersect(const QLineF &l, QPointF *intersectionPoint) const;

    qreal angle(const QLineF &l) const;

    QPointF pointAt(qreal t) const;
    inline void translate(const QPointF &p);
    inline void translate(qreal dx, qreal dy);

    inline bool operator==(const QLineF &d) const;
    inline bool operator!=(const QLineF &d) const { return !(*this == d); }

    QLine toLine() const;

private:
    QPointF pt1, pt2;
};
template <> class QTypeInfo<QLineF> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLineF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLineF"; } };





inline QLineF::QLineF()
{
}

inline QLineF::QLineF(const QPointF &apt1, const QPointF &apt2)
    : pt1(apt1), pt2(apt2)
{
}

inline QLineF::QLineF(qreal x1pos, qreal y1pos, qreal x2pos, qreal y2pos)
    : pt1(x1pos, y1pos), pt2(x2pos, y2pos)
{
}

inline qreal QLineF::x1() const
{
    return pt1.x();
}

inline qreal QLineF::y1() const
{
    return pt1.y();
}

inline qreal QLineF::x2() const
{
    return pt2.x();
}

inline qreal QLineF::y2() const
{
    return pt2.y();
}

inline QPointF QLineF::p1() const
{
    return pt1;
}

inline QPointF QLineF::p2() const
{
    return pt2;
}

inline qreal QLineF::dx() const
{
    return pt2.x() - pt1.x();
}

inline qreal QLineF::dy() const
{
    return pt2.y() - pt1.y();
}

inline QLineF QLineF::normalVector() const
{
    return QLineF(p1(), p1() + QPointF(dy(), -dx()));
}

inline void QLineF::translate(const QPointF &point)
{
    pt1 += point;
    pt2 += point;
}

inline void QLineF::translate(qreal adx, qreal ady)
{
    this->translate(QPointF(adx, ady));
}

inline void QLineF::setLength(qreal len)
{
    if (isNull())
        return;
    QLineF v = unitVector();
    pt2 = QPointF(pt1.x() + v.dx() * len, pt1.y() + v.dy() * len);
}

inline QPointF QLineF::pointAt(qreal t) const
{
    qreal vx = pt2.x() - pt1.x();
    qreal vy = pt2.y() - pt1.y();
    return QPointF(pt1.x() + vx * t, pt1.y() + vy * t);
}

inline QLine QLineF::toLine() const
{
    return QLine(pt1.toPoint(), pt2.toPoint());
}

inline bool QLineF::operator==(const QLineF &d) const
{
    return pt1 == d.pt1 && pt2 == d.pt2;
}


__declspec(dllimport) QDebug operator<<(QDebug d, const QLineF &p);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLineF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLineF &);

























































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

struct __declspec(dllimport) QLinkedListData
{
    QLinkedListData *n, *p;
    QBasicAtomic ref;
    int size;
    uint sharable : 1;

    static QLinkedListData shared_null;
};

template <typename T>
struct QLinkedListNode
{
    inline QLinkedListNode(const T &arg): t(arg) { }
    QLinkedListNode *n, *p;
    T t;
};

template <class T>
class QLinkedList
{
    typedef QLinkedListNode<T> Node;
    union { QLinkedListData *d; QLinkedListNode<T> *e; };

public:
    inline QLinkedList() : d(&QLinkedListData::shared_null) { d->ref.ref(); }
    inline QLinkedList(const QLinkedList &l) : d(l.d) { d->ref.ref(); if (!d->sharable) detach(); }
    ~QLinkedList();
    QLinkedList<T> &operator=(const QLinkedList &);
    bool operator==(const QLinkedList &l) const;
    inline bool operator!=(const QLinkedList &l) const { return !(*this == l); }

    inline int size() const { return d->size; }
    inline void detach()
    { if (d->ref != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref == 1; }
    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

    inline bool isEmpty() const { return d->size == 0; }

    void clear();

    void append(const T &);
    void prepend(const T &);
    T takeFirst();
    T takeLast();
    int removeAll(const T &t);
    bool contains(const T &t) const;
    int count(const T &t) const;

    class const_iterator;

    class iterator
    {
    public:
        typedef std::bidirectional_iterator_tag  iterator_category;
        typedef ptrdiff_t  difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;
        Node *i;
        inline iterator() : i(0) {}
        inline iterator(Node *n) : i(n) {}
        inline iterator(const iterator &o) : i(o.i) {}
        inline iterator &operator=(const iterator &o) { i = o.i; return *this; }
        inline T &operator*() const { return i->t; }
        inline T *operator->() const { return &i->t; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == reinterpret_cast<const iterator &>(o).i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != reinterpret_cast<const iterator &>(o).i; }
        inline iterator &operator++() { i = i->n; return *this; }
        inline iterator operator++(int) { Node *n = i; i = i->n; return n; }
        inline iterator &operator--() { i = i->p; return *this; }
        inline iterator operator--(int) { Node *n = i; i = i->p; return n; }
        inline iterator operator+(int j) const
        { Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class iterator;

    class const_iterator
    {
    public:
        typedef std::bidirectional_iterator_tag  iterator_category;
        typedef ptrdiff_t  difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;
        Node *i;
        inline const_iterator() : i(0) {}
        inline const_iterator(Node *n) : i(n) {}
        inline const_iterator(const const_iterator &o) : i(o.i){}
        inline const_iterator(iterator ci) : i(ci.i){}
	inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
        inline const T &operator*() const { return i->t; }
        inline const T *operator->() const { return &i->t; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline const_iterator &operator++() { i = i->n; return *this; }
        inline const_iterator operator++(int) { Node *n = i; i = i->n; return n; }
        inline const_iterator &operator--() { i = i->p; return *this; }
        inline const_iterator operator--(int) { Node *n = i; i = i->p; return n; }
        inline const_iterator operator+(int j) const
        { Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return e->n; }
    inline const_iterator begin() const { return e->n; }
    inline const_iterator constBegin() const { return e->n; }
    inline iterator end() { detach(); return e; }
    inline const_iterator end() const { return e; }
    inline const_iterator constEnd() const { return e; }
    iterator insert(iterator before, const T &t);
    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    inline T& first() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",152);} while (0); return *begin(); }
    inline const T& first() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",153);} while (0); return *begin(); }
    T& last() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",154);} while (0); return *(--end()); }
    const T& last() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",155);} while (0); return *(--end()); }
    inline void removeFirst() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",156);} while (0); erase(begin()); }
    inline void removeLast() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",157);} while (0); erase(--end()); }


    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    inline T& front() { return first(); }
    inline const T& front() const { return first(); }
    inline T& back() { return last(); }
    inline const T& back() const { return last(); }
    inline void pop_front() { removeFirst(); }
    inline void pop_back() { removeLast(); }
    inline bool empty() const { return isEmpty(); }
    typedef int size_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;

















    QLinkedList &operator+=(const QLinkedList &l);
    QLinkedList operator+(const QLinkedList &l) const;
    inline QLinkedList &operator+=(const T &t) { append(t); return *this; }
    inline QLinkedList &operator<< (const T &t) { append(t); return *this; }
    inline QLinkedList &operator<<(const QLinkedList &l) { *this += l; return *this; }

private:
    void detach_helper();
    void free(QLinkedListData*);
};

template <typename T>
inline QLinkedList<T>::~QLinkedList()
{
    if (!d)
        return;
    if (!d->ref.deref())
        free(d);
}

template <typename T>
void QLinkedList<T>::detach_helper()
{
    union { QLinkedListData *d; Node *e; } x;
    x.d = new QLinkedListData;
    x.d->ref.init(1);
    x.d->size = d->size;
    x.d->sharable = true;
    Node *i = e->n, *j = x.e;
    while (i != e) {
        j->n = new Node(i->t);
        j->n->p = j;
        i = i->n;
        j = j->n;
    }
    j->n = x.e;
    x.e->p = j;
    x.d = qAtomicSetPtr(&d, x.d);
    if (!x.d->ref.deref())
        free(x.d);
}

template <typename T>
void QLinkedList<T>::free(QLinkedListData *x)
{
    Node *y = reinterpret_cast<Node*>(x);
    Node *i = y->n;
    if (x->ref == 0) {
        while(i != y) {
            Node *n = i;
            i = i->n;
            delete n;
        }
        delete x;
    }
}

template <typename T>
void QLinkedList<T>::clear()
{
    *this = QLinkedList<T>();
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator=(const QLinkedList<T> &l)
{
    if (d != l.d) {
        QLinkedListData *x = l.d;
        x->ref.ref();
        x = qAtomicSetPtr(&d, x);
        if (!x->ref.deref())
            free(x);
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}

template <typename T>
bool QLinkedList<T>::operator== (const QLinkedList<T> &l) const
{
    if (d->size != l.d->size)
        return false;
    if (e == l.e)
        return true;
    Node *i = e->n;
    Node *il = l.e->n;
    while (i != e) {
        if (! (i->t == il->t))
            return false;
        i = i->n;
        il = il->n;
    }
    return true;
}

template <typename T>
void QLinkedList<T>::append(const T &t)
{
    detach();
    Node *i = new Node(t);
    i->n = e;
    i->p = e->p;
    i->p->n = i;
    e->p = i;
    d->size++;
}

template <typename T>
void QLinkedList<T>::prepend(const T &t)
{
    detach();
    Node *i = new Node(t);
    i->n = e->n;
    i->p = e;
    i->n->p = i;
    e->n = i;
    d->size++;
}

template <typename T>
int QLinkedList<T>::removeAll(const T &_t)
{
    detach();
    const T t = _t;
    Node *i = e->n;
    int c = 0;
    while (i != e) {
        if (i->t == t) {
            Node *n = i;
            i->n->p = i->p;
            i->p->n = i->n;
            i = i->n;
            delete n;
            c++;
        } else {
            i = i->n;
        }
    }
    d->size-=c;
    return c;
}

template <typename T>
inline T QLinkedList<T>::takeFirst()
{
    T t = first();
    removeFirst();
    return t;
}

template <typename T>
inline T QLinkedList<T>::takeLast()
{
    T t = last();
    removeLast();
    return t;
}

template <typename T>
bool QLinkedList<T>::contains(const T &t) const
{
    Node *i = e;
    while ((i = i->n) != e)
        if (i->t == t)
            return true;
    return false;
}

template <typename T>
int QLinkedList<T>::count(const T &t) const
{
    Node *i = e;
    int c = 0;
    while ((i = i->n) != e)
        if (i->t == t)
            c++;
    return c;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::insert(iterator before, const T &t)
{
    Node *i = before.i;
    Node *m = new Node(t);
    m->n = i;
    m->p = i->p;
    m->p->n = m;
    i->p = m;
    d->size++;
    return m;
}

template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(typename QLinkedList<T>::iterator afirst,
                                                         typename QLinkedList<T>::iterator alast)
{
    while (afirst != alast)
        erase(afirst++);
    return alast;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(iterator pos)
{
    detach();
    Node *i = pos.i;
    if (i != e) {
        Node *n = i;
        i->n->p = i->p;
        i->p->n = i->n;
        i = i->n;
        delete n;
        d->size--;
    }
    return i;
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator+=(const QLinkedList<T> &l)
{
    detach();
    int n = l.d->size;
    d->size += n;
    Node *o = l.e->n;
    while (n--) {
        Node *i = new Node(o->t);
        o = o->n;
        i->n = e;
        i->p = e->p;
        i->p->n = i;
        e->p = i;
    }
    return *this;
}

template <typename T>
QLinkedList<T> QLinkedList<T>::operator+(const QLinkedList<T> &l) const
{
    QLinkedList<T> n = *this;
    n += l;
    return n;
}

template <class T> class QLinkedListIterator { typedef typename QLinkedList<T>::const_iterator const_iterator; QLinkedList<T> c; const_iterator i; public: inline QLinkedListIterator(const QLinkedList<T> &container) : c(container), i(c.constBegin()) {} inline QLinkedListIterator &operator=(const QLinkedList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableLinkedListIterator { typedef typename QLinkedList<T>::iterator iterator; QLinkedList<T> *c; iterator i, n; inline bool item_exists() const { return n != c->constEnd(); } public: inline QMutableLinkedListIterator(QLinkedList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableLinkedListIterator() { c->setSharable(true); } inline QMutableLinkedListIterator &operator=(QLinkedList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != i; } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != i; } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != n) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != n) *n = t; } inline T &value() { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",439);} while (0); return *n; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qlinkedlist.h",439);} while (0); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != (n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != i) if (*(n = --i) == t) return true; n = c->end(); return false; } };






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class QDataStream;
class QDate;
class QTime;
struct QLocalePrivate;

class __declspec(dllimport) QLocale
{
    friend class QString;
    friend class QByteArray;

public:
    enum Language {
        C = 1,
        Abkhazian = 2,
        Afan = 3,
        Afar = 4,
        Afrikaans = 5,
        Albanian = 6,
        Amharic = 7,
        Arabic = 8,
        Armenian = 9,
        Assamese = 10,
        Aymara = 11,
        Azerbaijani = 12,
        Bashkir = 13,
        Basque = 14,
        Bengali = 15,
        Bhutani = 16,
        Bihari = 17,
        Bislama = 18,
        Breton = 19,
        Bulgarian = 20,
        Burmese = 21,
        Byelorussian = 22,
        Cambodian = 23,
        Catalan = 24,
        Chinese = 25,
        Corsican = 26,
        Croatian = 27,
        Czech = 28,
        Danish = 29,
        Dutch = 30,
        English = 31,
        Esperanto = 32,
        Estonian = 33,
        Faroese = 34,
        FijiLanguage = 35,
        Finnish = 36,
        French = 37,
        Frisian = 38,
        Gaelic = 39,
        Galician = 40,
        Georgian = 41,
        German = 42,
        Greek = 43,
        Greenlandic = 44,
        Guarani = 45,
        Gujarati = 46,
        Hausa = 47,
        Hebrew = 48,
        Hindi = 49,
        Hungarian = 50,
        Icelandic = 51,
        Indonesian = 52,
        Interlingua = 53,
        Interlingue = 54,
        Inuktitut = 55,
        Inupiak = 56,
        Irish = 57,
        Italian = 58,
        Japanese = 59,
        Javanese = 60,
        Kannada = 61,
        Kashmiri = 62,
        Kazakh = 63,
        Kinyarwanda = 64,
        Kirghiz = 65,
        Korean = 66,
        Kurdish = 67,
        Kurundi = 68,
        Laothian = 69,
        Latin = 70,
        Latvian = 71,
        Lingala = 72,
        Lithuanian = 73,
        Macedonian = 74,
        Malagasy = 75,
        Malay = 76,
        Malayalam = 77,
        Maltese = 78,
        Maori = 79,
        Marathi = 80,
        Moldavian = 81,
        Mongolian = 82,
        NauruLanguage = 83,
        Nepali = 84,
        Norwegian = 85,
        Occitan = 86,
        Oriya = 87,
        Pashto = 88,
        Persian = 89,
        Polish = 90,
        Portuguese = 91,
        Punjabi = 92,
        Quechua = 93,
        RhaetoRomance = 94,
        Romanian = 95,
        Russian = 96,
        Samoan = 97,
        Sangho = 98,
        Sanskrit = 99,
        Serbian = 100,
        SerboCroatian = 101,
        Sesotho = 102,
        Setswana = 103,
        Shona = 104,
        Sindhi = 105,
        Singhalese = 106,
        Siswati = 107,
        Slovak = 108,
        Slovenian = 109,
        Somali = 110,
        Spanish = 111,
        Sundanese = 112,
        Swahili = 113,
        Swedish = 114,
        Tagalog = 115,
        Tajik = 116,
        Tamil = 117,
        Tatar = 118,
        Telugu = 119,
        Thai = 120,
        Tibetan = 121,
        Tigrinya = 122,
        TongaLanguage = 123,
        Tsonga = 124,
        Turkish = 125,
        Turkmen = 126,
        Twi = 127,
        Uigur = 128,
        Ukrainian = 129,
        Urdu = 130,
        Uzbek = 131,
        Vietnamese = 132,
        Volapuk = 133,
        Welsh = 134,
        Wolof = 135,
        Xhosa = 136,
        Yiddish = 137,
        Yoruba = 138,
        Zhuang = 139,
        Zulu = 140,
        Nynorsk = 141,
        Bosnian = 142,
        Divehi = 143,
        Manx = 144,
        Cornish = 145,
        LastLanguage = Cornish
    };

    enum Country {
        AnyCountry = 0,
        Afghanistan = 1,
        Albania = 2,
        Algeria = 3,
        AmericanSamoa = 4,
        Andorra = 5,
        Angola = 6,
        Anguilla = 7,
        Antarctica = 8,
        AntiguaAndBarbuda = 9,
        Argentina = 10,
        Armenia = 11,
        Aruba = 12,
        Australia = 13,
        Austria = 14,
        Azerbaijan = 15,
        Bahamas = 16,
        Bahrain = 17,
        Bangladesh = 18,
        Barbados = 19,
        Belarus = 20,
        Belgium = 21,
        Belize = 22,
        Benin = 23,
        Bermuda = 24,
        Bhutan = 25,
        Bolivia = 26,
        BosniaAndHerzegowina = 27,
        Botswana = 28,
        BouvetIsland = 29,
        Brazil = 30,
        BritishIndianOceanTerritory = 31,
        BruneiDarussalam = 32,
        Bulgaria = 33,
        BurkinaFaso = 34,
        Burundi = 35,
        Cambodia = 36,
        Cameroon = 37,
        Canada = 38,
        CapeVerde = 39,
        CaymanIslands = 40,
        CentralAfricanRepublic = 41,
        Chad = 42,
        Chile = 43,
        China = 44,
        ChristmasIsland = 45,
        CocosIslands = 46,
        Colombia = 47,
        Comoros = 48,
        DemocraticRepublicOfCongo = 49,
        PeoplesRepublicOfCongo = 50,
        CookIslands = 51,
        CostaRica = 52,
        IvoryCoast = 53,
        Croatia = 54,
        Cuba = 55,
        Cyprus = 56,
        CzechRepublic = 57,
        Denmark = 58,
        Djibouti = 59,
        Dominica = 60,
        DominicanRepublic = 61,
        EastTimor = 62,
        Ecuador = 63,
        Egypt = 64,
        ElSalvador = 65,
        EquatorialGuinea = 66,
        Eritrea = 67,
        Estonia = 68,
        Ethiopia = 69,
        FalklandIslands = 70,
        FaroeIslands = 71,
        FijiCountry = 72,
        Finland = 73,
        France = 74,
        MetropolitanFrance = 75,
        FrenchGuiana = 76,
        FrenchPolynesia = 77,
        FrenchSouthernTerritories = 78,
        Gabon = 79,
        Gambia = 80,
        Georgia = 81,
        Germany = 82,
        Ghana = 83,
        Gibraltar = 84,
        Greece = 85,
        Greenland = 86,
        Grenada = 87,
        Guadeloupe = 88,
        Guam = 89,
        Guatemala = 90,
        Guinea = 91,
        GuineaBissau = 92,
        Guyana = 93,
        Haiti = 94,
        HeardAndMcDonaldIslands = 95,
        Honduras = 96,
        HongKong = 97,
        Hungary = 98,
        Iceland = 99,
        India = 100,
        Indonesia = 101,
        Iran = 102,
        Iraq = 103,
        Ireland = 104,
        Israel = 105,
        Italy = 106,
        Jamaica = 107,
        Japan = 108,
        Jordan = 109,
        Kazakhstan = 110,
        Kenya = 111,
        Kiribati = 112,
        DemocraticRepublicOfKorea = 113,
        RepublicOfKorea = 114,
        Kuwait = 115,
        Kyrgyzstan = 116,
        Lao = 117,
        Latvia = 118,
        Lebanon = 119,
        Lesotho = 120,
        Liberia = 121,
        LibyanArabJamahiriya = 122,
        Liechtenstein = 123,
        Lithuania = 124,
        Luxembourg = 125,
        Macau = 126,
        Macedonia = 127,
        Madagascar = 128,
        Malawi = 129,
        Malaysia = 130,
        Maldives = 131,
        Mali = 132,
        Malta = 133,
        MarshallIslands = 134,
        Martinique = 135,
        Mauritania = 136,
        Mauritius = 137,
        Mayotte = 138,
        Mexico = 139,
        Micronesia = 140,
        Moldova = 141,
        Monaco = 142,
        Mongolia = 143,
        Montserrat = 144,
        Morocco = 145,
        Mozambique = 146,
        Myanmar = 147,
        Namibia = 148,
        NauruCountry = 149,
        Nepal = 150,
        Netherlands = 151,
        NetherlandsAntilles = 152,
        NewCaledonia = 153,
        NewZealand = 154,
        Nicaragua = 155,
        Niger = 156,
        Nigeria = 157,
        Niue = 158,
        NorfolkIsland = 159,
        NorthernMarianaIslands = 160,
        Norway = 161,
        Oman = 162,
        Pakistan = 163,
        Palau = 164,
        PalestinianTerritory = 165,
        Panama = 166,
        PapuaNewGuinea = 167,
        Paraguay = 168,
        Peru = 169,
        Philippines = 170,
        Pitcairn = 171,
        Poland = 172,
        Portugal = 173,
        PuertoRico = 174,
        Qatar = 175,
        Reunion = 176,
        Romania = 177,
        RussianFederation = 178,
        Rwanda = 179,
        SaintKittsAndNevis = 180,
        StLucia = 181,
        StVincentAndTheGrenadines = 182,
        Samoa = 183,
        SanMarino = 184,
        SaoTomeAndPrincipe = 185,
        SaudiArabia = 186,
        Senegal = 187,
        Seychelles = 188,
        SierraLeone = 189,
        Singapore = 190,
        Slovakia = 191,
        Slovenia = 192,
        SolomonIslands = 193,
        Somalia = 194,
        SouthAfrica = 195,
        SouthGeorgiaAndTheSouthSandwichIslands = 196,
        Spain = 197,
        SriLanka = 198,
        StHelena = 199,
        StPierreAndMiquelon = 200,
        Sudan = 201,
        Suriname = 202,
        SvalbardAndJanMayenIslands = 203,
        Swaziland = 204,
        Sweden = 205,
        Switzerland = 206,
        SyrianArabRepublic = 207,
        Taiwan = 208,
        Tajikistan = 209,
        Tanzania = 210,
        Thailand = 211,
        Togo = 212,
        Tokelau = 213,
        TongaCountry = 214,
        TrinidadAndTobago = 215,
        Tunisia = 216,
        Turkey = 217,
        Turkmenistan = 218,
        TurksAndCaicosIslands = 219,
        Tuvalu = 220,
        Uganda = 221,
        Ukraine = 222,
        UnitedArabEmirates = 223,
        UnitedKingdom = 224,
        UnitedStates = 225,
        UnitedStatesMinorOutlyingIslands = 226,
        Uruguay = 227,
        Uzbekistan = 228,
        Vanuatu = 229,
        VaticanCityState = 230,
        Venezuela = 231,
        VietNam = 232,
        BritishVirginIslands = 233,
        USVirginIslands = 234,
        WallisAndFutunaIslands = 235,
        WesternSahara = 236,
        Yemen = 237,
        Yugoslavia = 238,
        Zambia = 239,
        Zimbabwe = 240,
        SerbiaAndMontenegro = 241,
        LastCountry = SerbiaAndMontenegro
    };

    enum FormatType { LongFormat, ShortFormat };

    QLocale();
    QLocale(const QString &name);
    QLocale(Language language, Country country = AnyCountry);
    QLocale(const QLocale &other);

    QLocale &operator=(const QLocale &other);

    Language language() const;
    Country country() const;
    QString name() const;

    short toShort(const QString &s, bool *ok = 0, int base = 0) const;
    ushort toUShort(const QString &s, bool *ok = 0, int base = 0) const;
    int toInt(const QString &s, bool *ok = 0, int base = 0) const;
    uint toUInt(const QString &s, bool *ok = 0, int base = 0) const;
    qlonglong toLongLong(const QString &s, bool *ok = 0, int base = 0) const;
    qlonglong toULongLong(const QString &s, bool *ok = 0, int base = 0) const;
    float toFloat(const QString &s, bool *ok = 0) const;
    double toDouble(const QString &s, bool *ok = 0) const;

    QString toString(qlonglong i) const;
    QString toString(qulonglong i) const;
    inline QString toString(short i) const;
    inline QString toString(ushort i) const;
    inline QString toString(int i) const;
    inline QString toString(uint i) const;
    QString toString(double i, char f = 'g', int prec = 6) const;
    inline QString toString(float i, char f = 'g', int prec = 6) const;
    QString toString(const QDate &date, const QString &formatStr) const;
    QString toString(const QDate &date, FormatType format = LongFormat) const;
    QString toString(const QTime &time, const QString &formatStr) const;
    QString toString(const QTime &time, FormatType format = LongFormat) const;

    QString dateFormat(FormatType format = LongFormat) const;
    QString timeFormat(FormatType format = LongFormat) const;

    inline bool operator==(const QLocale &other) const;
    inline bool operator!=(const QLocale &other) const;

    static QString languageToString(Language language);
    static QString countryToString(Country country);
    static void setDefault(const QLocale &locale);

    static QLocale c() { return QLocale(C); }
    static QLocale system();

private:
    const QLocalePrivate *d;
    static const QLocalePrivate *default_d;
};
template <> class QTypeInfo<QLocale> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLocale)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLocale"; } };

inline QString QLocale::toString(short i) const
    { return toString(qlonglong(i)); }
inline QString QLocale::toString(ushort i) const
    { return toString(qulonglong(i)); }
inline QString QLocale::toString(int i) const
    { return toString(qlonglong(i)); }
inline QString QLocale::toString(uint i) const
    { return toString(qulonglong(i)); }
inline QString QLocale::toString(float i, char f, int prec) const
    { return toString(double(i), f, prec); }
inline bool QLocale::operator==(const QLocale &other) const
    { return d == other.d; }
inline bool QLocale::operator!=(const QLocale &other) const
    { return d != other.d; }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLocale &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLocale &);


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QQueue : public QList<T>
{
public:
    inline QQueue() {}
    inline ~QQueue() {}
    inline void enqueue(const T &t) { QList<T>::append(t); }
    inline T dequeue() { return QList<T>::takeFirst(); }
    inline T &head() { return QList<T>::first(); }
    inline const T &head() const { return QList<T>::first(); }
};










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QSize
{
public:
    QSize();
    QSize(int w, int h);

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;

    int width() const;
    int height() const;
    void setWidth(int w);
    void setHeight(int h);
    void transpose();

    void scale(int w, int h, Qt::AspectRatioMode mode);
    void scale(const QSize &s, Qt::AspectRatioMode mode);

    QSize expandedTo(const QSize &) const;
    QSize boundedTo(const QSize &) const;

    int &rwidth();
    int &rheight();

    QSize &operator+=(const QSize &);
    QSize &operator-=(const QSize &);
    QSize &operator*=(qreal c);
    QSize &operator/=(qreal c);

    friend inline bool operator==(const QSize &, const QSize &);
    friend inline bool operator!=(const QSize &, const QSize &);
    friend inline const QSize operator+(const QSize &, const QSize &);
    friend inline const QSize operator-(const QSize &, const QSize &);
    friend inline const QSize operator*(const QSize &, qreal);
    friend inline const QSize operator*(qreal, const QSize &);
    friend inline const QSize operator/(const QSize &, qreal);

private:
    int wd;
    int ht;
};
template <> class QTypeInfo<QSize> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSize)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QSize"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSize &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QSize &);






inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize(int w, int h)
{ wd = w; ht = h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth(int w)
{ wd = w; }

inline void QSize::setHeight(int h)
{ ht = h; }

inline void QSize::scale(int w, int h, Qt::AspectRatioMode mode)
{ scale(QSize(w, h), mode); }

inline int &QSize::rwidth()
{ return wd; }

inline int &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=(const QSize &s)
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=(const QSize &s)
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=(qreal c)
{ wd = qRound(wd*c); ht = qRound(ht*c); return *this; }

inline bool operator==(const QSize &s1, const QSize &s2)
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=(const QSize &s1, const QSize &s2)
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline const QSize operator+(const QSize & s1, const QSize & s2)
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSize operator-(const QSize &s1, const QSize &s2)
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSize operator*(const QSize &s, qreal c)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

inline const QSize operator*(qreal c, const QSize &s)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

inline QSize &QSize::operator/=(qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qsize.h",142);} while (0);
    wd = qRound(wd/c); ht = qRound(ht/c);
    return *this;
}

inline const QSize operator/(const QSize &s, qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qsize.h",149);} while (0);
    return QSize(qRound(s.wd/c), qRound(s.ht/c));
}

inline QSize QSize::expandedTo(const QSize & otherSize) const
{
    return QSize(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

inline QSize QSize::boundedTo(const QSize & otherSize) const
{
    return QSize(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QSize &);



class __declspec(dllimport) QSizeF
{
public:
    QSizeF();
    QSizeF(const QSize &sz);
    QSizeF(qreal w, qreal h);

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;

    qreal width() const;
    qreal height() const;
    void setWidth(qreal w);
    void setHeight(qreal h);
    void transpose();

    void scale(qreal w, qreal h, Qt::AspectRatioMode mode);
    void scale(const QSizeF &s, Qt::AspectRatioMode mode);

    QSizeF expandedTo(const QSizeF &) const;
    QSizeF boundedTo(const QSizeF &) const;

    qreal &rwidth();
    qreal &rheight();

    QSizeF &operator+=(const QSizeF &);
    QSizeF &operator-=(const QSizeF &);
    QSizeF &operator*=(qreal c);
    QSizeF &operator/=(qreal c);

    friend inline bool operator==(const QSizeF &, const QSizeF &);
    friend inline bool operator!=(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator+(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator-(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator*(const QSizeF &, qreal);
    friend inline const QSizeF operator*(qreal, const QSizeF &);
    friend inline const QSizeF operator/(const QSizeF &, qreal);

    inline QSize toSize() const;

private:
    qreal wd;
    qreal ht;
};
template <> class QTypeInfo<QSizeF> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSizeF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QSizeF"; } };






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSizeF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QSizeF &);






inline QSizeF::QSizeF()
{ wd = ht = -1.; }

inline QSizeF::QSizeF(const QSize &sz)
    : wd(sz.width()), ht(sz.height())
{
}

inline QSizeF::QSizeF(qreal w, qreal h)
{ wd = w; ht = h; }

inline bool QSizeF::isNull() const
{ return qFuzzyCompare(wd, 0) && qFuzzyCompare(ht, 0); }

inline bool QSizeF::isEmpty() const
{ return wd <= 0. || ht <= 0.; }

inline bool QSizeF::isValid() const
{ return wd >= 0. && ht >= 0.; }

inline qreal QSizeF::width() const
{ return wd; }

inline qreal QSizeF::height() const
{ return ht; }

inline void QSizeF::setWidth(qreal w)
{ wd = w; }

inline void QSizeF::setHeight(qreal h)
{ ht = h; }

inline void QSizeF::scale(qreal w, qreal h, Qt::AspectRatioMode mode)
{ scale(QSizeF(w, h), mode); }

inline qreal &QSizeF::rwidth()
{ return wd; }

inline qreal &QSizeF::rheight()
{ return ht; }

inline QSizeF &QSizeF::operator+=(const QSizeF &s)
{ wd += s.wd; ht += s.ht; return *this; }

inline QSizeF &QSizeF::operator-=(const QSizeF &s)
{ wd -= s.wd; ht -= s.ht; return *this; }

inline QSizeF &QSizeF::operator*=(qreal c)
{ wd *= c; ht *= c; return *this; }

inline bool operator==(const QSizeF &s1, const QSizeF &s2)
{ return qFuzzyCompare(s1.wd, s2.wd) && qFuzzyCompare(s1.ht, s2.ht); }

inline bool operator!=(const QSizeF &s1, const QSizeF &s2)
{ return !qFuzzyCompare(s1.wd, s2.wd) || !qFuzzyCompare(s1.ht, s2.ht); }

inline const QSizeF operator+(const QSizeF & s1, const QSizeF & s2)
{ return QSizeF(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSizeF operator-(const QSizeF &s1, const QSizeF &s2)
{ return QSizeF(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSizeF operator*(const QSizeF &s, qreal c)
{ return QSizeF(s.wd*c, s.ht*c); }

inline const QSizeF operator*(qreal c, const QSizeF &s)
{ return QSizeF(s.wd*c, s.ht*c); }

inline QSizeF &QSizeF::operator/=(qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qsize.h",298);} while (0);
    wd = wd/c; ht = ht/c;
    return *this;
}

inline const QSizeF operator/(const QSizeF &s, qreal c)
{
    do {if(!(!qFuzzyCompare(c, 0)))qt_assert("!qFuzzyCompare(c, 0)","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qsize.h",305);} while (0);
    return QSizeF(s.wd/c, s.ht/c);
}

inline QSizeF QSizeF::expandedTo(const QSizeF & otherSize) const
{
    return QSizeF(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

inline QSizeF QSizeF::boundedTo(const QSizeF & otherSize) const
{
    return QSizeF(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}

inline QSize QSizeF::toSize() const
{
    return QSize(qRound(wd), qRound(ht));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QSizeF &);





















































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

class __declspec(dllimport) QRect
{
public:
    QRect() { x1 = y1 = 0; x2 = y2 = -1; }
    QRect(const QPoint &topleft, const QPoint &bottomright);
    QRect(const QPoint &topleft, const QSize &size);
    QRect(int left, int top, int width, int height);

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;

    int left() const;
    int top() const;
    int right() const;
    int bottom() const;
    QRect normalized() const;










    int x() const;
    int y() const;
    void setLeft(int pos);
    void setTop(int pos);
    void setRight(int pos);
    void setBottom(int pos);
    void setX(int x);
    void setY(int y);

    void setTopLeft(const QPoint &p);
    void setBottomRight(const QPoint &p);
    void setTopRight(const QPoint &p);
    void setBottomLeft(const QPoint &p);

    QPoint topLeft() const;
    QPoint bottomRight() const;
    QPoint topRight() const;
    QPoint bottomLeft() const;
    QPoint center() const;

    void moveLeft(int pos);
    void moveTop(int pos);
    void moveRight(int pos);
    void moveBottom(int pos);
    void moveTopLeft(const QPoint &p);
    void moveBottomRight(const QPoint &p);
    void moveTopRight(const QPoint &p);
    void moveBottomLeft(const QPoint &p);
    void moveCenter(const QPoint &p);

    inline void translate(int dx, int dy);
    inline void translate(const QPoint &p);
    inline QRect translated(int dx, int dy) const;
    inline QRect translated(const QPoint &p) const;

    void moveTo(int x, int t);
    void moveTo(const QPoint &p);






    void setRect(int x, int y, int w, int h);
    inline void getRect(int *x, int *y, int *w, int *h) const;

    void setCoords(int x1, int y1, int x2, int y2);



    inline void getCoords(int *x1, int *y1, int *x2, int *y2) const;

    inline void adjust(int x1, int y1, int x2, int y2);
    inline QRect adjusted(int x1, int y1, int x2, int y2) const;

    QSize size() const;
    int width() const;
    int height() const;
    void setWidth(int w);
    void setHeight(int h);
    void setSize(const QSize &s);

    QRect operator|(const QRect &r) const;
    QRect operator&(const QRect &r) const;
    QRect& operator|=(const QRect &r);
    QRect& operator&=(const QRect &r);

    bool contains(const QPoint &p, bool proper=false) const;
    bool contains(int x, int y) const;
    bool contains(int x, int y, bool proper) const;
    bool contains(const QRect &r, bool proper=false) const;
    QRect unite(const QRect &r) const;
    QRect intersect(const QRect &r) const;
    bool intersects(const QRect &r) const;

    friend __declspec(dllimport) inline bool operator==(const QRect &, const QRect &);
    friend __declspec(dllimport) inline bool operator!=(const QRect &, const QRect &);







private:









    int x1;
    int y1;
    int x2;
    int y2;


};
template <> class QTypeInfo<QRect> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRect)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRect"; } };

__declspec(dllimport) inline bool operator==(const QRect &, const QRect &);
__declspec(dllimport) inline bool operator!=(const QRect &, const QRect &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRect &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRect &);






inline QRect::QRect(int aleft, int atop, int awidth, int aheight)
{
    x1 = aleft;
    y1 = atop;
    x2 = (aleft + awidth - 1);
    y2 = (atop + aheight - 1);
}

inline QRect::QRect(const QPoint &atopLeft, const QPoint &abottomRight)
{
    x1 = atopLeft.x();
    y1 = atopLeft.y();
    x2 = abottomRight.x();
    y2 = abottomRight.y();
}

inline QRect::QRect(const QPoint &atopLeft, const QSize &asize)
{
    x1 = atopLeft.x();
    y1 = atopLeft.y();
    x2 = (x1+asize.width() - 1);
    y2 = (y1+asize.height() - 1);
}

inline bool QRect::isNull() const
{ return x2 == x1 - 1 && y2 == y1 - 1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft(int pos)
{ x1 = pos; }

inline void QRect::setTop(int pos)
{ y1 = pos; }

inline void QRect::setRight(int pos)
{ x2 = pos; }

inline void QRect::setBottom(int pos)
{ y2 = pos; }

inline void QRect::setTopLeft(const QPoint &p)
{ x1 = p.x(); y1 = p.y(); }

inline void QRect::setBottomRight(const QPoint &p)
{ x2 = p.x(); y2 = p.y(); }

inline void QRect::setTopRight(const QPoint &p)
{ x2 = p.x(); y1 = p.y(); }

inline void QRect::setBottomLeft(const QPoint &p)
{ x1 = p.x(); y2 = p.y(); }

inline void QRect::setX(int ax)
{ x1 = ax; }

inline void QRect::setY(int ay)
{ y1 = ay; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return  x2 - x1 + 1; }

inline int QRect::height() const
{ return  y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(width(), height()); }

inline void QRect::translate(int dx, int dy)
{
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;
}

inline void QRect::translate(const QPoint &p)
{
    x1 += p.x();
    y1 += p.y();
    x2 += p.x();
    y2 += p.y();
}

inline QRect QRect::translated(int dx, int dy) const
{ return QRect(QPoint(x1 + dx, y1 + dy), QPoint(x2 + dx, y2 + dy)); }

inline QRect QRect::translated(const QPoint &p) const
{ return QRect(QPoint(x1 + p.x(), y1 + p.y()), QPoint(x2 + p.x(), y2 + p.y())); }

inline void QRect::moveTo(int ax, int ay)
{
    x2 += ax - x1;
    y2 += ay - y1;
    x1 = ax;
    y1 = ay;
}

inline void QRect::moveTo(const QPoint &p)
{
    x2 += p.x() - x1;
    y2 += p.y() - y1;
    x1 = p.x();
    y1 = p.y();
}

inline void QRect::moveLeft(int pos)
{ x2 += (pos - x1); x1 = pos; }

inline void QRect::moveTop(int pos)
{ y2 += (pos - y1); y1 = pos; }

inline void QRect::moveRight(int pos)
{
    x1 += (pos - x2);
    x2 = pos;
}

inline void QRect::moveBottom(int pos)
{
    y1 += (pos - y2);
    y2 = pos;
}

inline void QRect::moveTopLeft(const QPoint &p)
{
    moveLeft(p.x());
    moveTop(p.y());
}

inline void QRect::moveBottomRight(const QPoint &p)
{
    moveRight(p.x());
    moveBottom(p.y());
}

inline void QRect::moveTopRight(const QPoint &p)
{
    moveRight(p.x());
    moveTop(p.y());
}

inline void QRect::moveBottomLeft(const QPoint &p)
{
    moveLeft(p.x());
    moveBottom(p.y());
}

inline void QRect::getRect(int *ax, int *ay, int *aw, int *ah) const
{
    *ax = x1;
    *ay = y1;
    *aw = x2 - x1 + 1;
    *ah = y2 - y1 + 1;
}

inline void QRect::setRect(int ax, int ay, int aw, int ah)
{
    x1 = ax;
    y1 = ay;
    x2 = (ax + aw - 1);
    y2 = (ay + ah - 1);
}

inline void QRect::getCoords(int *xp1, int *yp1, int *xp2, int *yp2) const
{
    *xp1 = x1;
    *yp1 = y1;
    *xp2 = x2;
    *yp2 = y2;
}

inline void QRect::setCoords(int xp1, int yp1, int xp2, int yp2)
{
    x1 = xp1;
    y1 = yp1;
    x2 = xp2;
    y2 = yp2;
}








inline QRect QRect::adjusted(int xp1, int yp1, int xp2, int yp2) const
{ return QRect(QPoint(x1 + xp1, y1 + yp1), QPoint(x2 + xp2, y2 + yp2)); }

inline void QRect::adjust(int dx1, int dy1, int dx2, int dy2)
{
    x1 += dx1;
    y1 += dy1;
    x2 += dx2;
    y2 += dy2;
}

inline void QRect::setWidth(int w)
{ x2 = (x1 + w - 1); }

inline void QRect::setHeight(int h)
{ y2 = (y1 + h - 1); }

inline void QRect::setSize(const QSize &s)
{
    x2 = (s.width()  + x1 - 1);
    y2 = (s.height() + y1 - 1);
}

inline bool QRect::contains(int ax, int ay, bool aproper) const
{
    return contains(QPoint(ax, ay), aproper);
}

inline bool QRect::contains(int ax, int ay) const
{
    return contains(QPoint(ax, ay), false);
}

inline QRect& QRect::operator|=(const QRect &r)
{
    *this = *this | r;
    return *this;
}

inline QRect& QRect::operator&=(const QRect &r)
{
    *this = *this & r;
    return *this;
}

inline QRect QRect::intersect(const QRect &r) const
{
    return *this & r;
}
inline QRect QRect::unite(const QRect &r) const
{
    return *this | r;
}

inline bool operator==(const QRect &r1, const QRect &r2)
{
    return r1.x1==r2.x1 && r1.x2==r2.x2 && r1.y1==r2.y1 && r1.y2==r2.y2;
}

inline bool operator!=(const QRect &r1, const QRect &r2)
{
    return r1.x1!=r2.x1 || r1.x2!=r2.x2 || r1.y1!=r2.y1 || r1.y2!=r2.y2;
}


__declspec(dllimport) QDebug operator<<(QDebug, const QRect &);



class __declspec(dllimport) QRectF
{
public:
    QRectF() { xp = yp = 0.; w = h = 0.; }
    QRectF(const QPointF &topleft, const QSizeF &size);
    QRectF(qreal left, qreal top, qreal width, qreal height);
    QRectF(const QRect &rect);

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;
    QRectF normalized() const;

    inline qreal left() const { return xp; }
    inline qreal top() const { return yp; }
    inline qreal right() const { return xp + w; }
    inline qreal bottom() const { return yp + h; }

    inline qreal x() const;
    inline qreal y() const;
    inline void setLeft(qreal pos);
    inline void setTop(qreal pos);
    inline void setRight(qreal pos);
    inline void setBottom(qreal pos);
    inline void setX(qreal pos) { setLeft(pos); }
    inline void setY(qreal pos) { setTop(pos); }

    inline QPointF topLeft() const { return QPointF(xp, yp); }
    inline QPointF bottomRight() const { return QPointF(xp+w, yp+h); }
    inline QPointF topRight() const { return QPointF(xp+w, yp); }
    inline QPointF bottomLeft() const { return QPointF(xp, yp+h); }
    inline QPointF center() const;

    void setTopLeft(const QPointF &p);
    void setBottomRight(const QPointF &p);
    void setTopRight(const QPointF &p);
    void setBottomLeft(const QPointF &p);

    void moveLeft(qreal pos);
    void moveTop(qreal pos);
    void moveRight(qreal pos);
    void moveBottom(qreal pos);
    void moveTopLeft(const QPointF &p);
    void moveBottomRight(const QPointF &p);
    void moveTopRight(const QPointF &p);
    void moveBottomLeft(const QPointF &p);
    void moveCenter(const QPointF &p);

    void translate(qreal dx, qreal dy);
    void translate(const QPointF &p);

    QRectF translated(qreal dx, qreal dy) const;
    QRectF translated(const QPointF &p) const;

    void moveTo(qreal x, qreal t);
    void moveTo(const QPointF &p);

    void setRect(qreal x, qreal y, qreal w, qreal h);
    void getRect(qreal *x, qreal *y, qreal *w, qreal *h) const;

    void setCoords(qreal x1, qreal y1, qreal x2, qreal y2);
    void getCoords(qreal *x1, qreal *y1, qreal *x2, qreal *y2) const;

    inline void adjust(qreal x1, qreal y1, qreal x2, qreal y2);
    inline QRectF adjusted(qreal x1, qreal y1, qreal x2, qreal y2) const;

    QSizeF size() const;
    qreal width() const;
    qreal height() const;
    void setWidth(qreal w);
    void setHeight(qreal h);
    void setSize(const QSizeF &s);

    QRectF operator|(const QRectF &r) const;
    QRectF operator&(const QRectF &r) const;
    QRectF& operator|=(const QRectF &r);
    QRectF& operator&=(const QRectF &r);

    bool contains(const QPointF &p) const;
    bool contains(qreal x, qreal y) const;
    bool contains(const QRectF &r) const;
    QRectF unite(const QRectF &r) const;
    QRectF intersect(const QRectF &r) const;
    bool intersects(const QRectF &r) const;

    friend __declspec(dllimport) inline bool operator==(const QRectF &, const QRectF &);
    friend __declspec(dllimport) inline bool operator!=(const QRectF &, const QRectF &);

    QRect toRect() const;

private:
    qreal xp;
    qreal yp;
    qreal w;
    qreal h;
};
template <> class QTypeInfo<QRectF> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRectF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRectF"; } };

__declspec(dllimport) inline bool operator==(const QRectF &, const QRectF &);
__declspec(dllimport) inline bool operator!=(const QRectF &, const QRectF &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRectF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRectF &);






inline QRectF::QRectF(qreal aleft, qreal atop, qreal awidth, qreal aheight)
    : xp(aleft), yp(atop), w(awidth), h(aheight)
{
}

inline QRectF::QRectF(const QPointF &atopLeft, const QSizeF &asize)
{
    xp = atopLeft.x();
    yp = atopLeft.y();
    w = asize.width();
    h = asize.height();
}

inline QRectF::QRectF(const QRect &r)
    : xp(r.x()), yp(r.y()), w(r.width()), h(r.height())
{
}

inline bool QRectF::isNull() const
{ return qFuzzyCompare(w, 0) && qFuzzyCompare(h, 0); }

inline bool QRectF::isEmpty() const
{ return w <= 0. || h <= 0.; }

inline bool QRectF::isValid() const
{ return w > 0. && h > 0.; }

inline qreal QRectF::x() const
{ return xp; }

inline qreal QRectF::y() const
{ return yp; }

inline void QRectF::setLeft(qreal pos) { qreal diff = pos - xp; xp += diff; w -= diff; }

inline void QRectF::setRight(qreal pos) { w = pos - xp; }

inline void QRectF::setTop(qreal pos) { qreal diff = pos - yp; yp += diff; h -= diff; }

inline void QRectF::setBottom(qreal pos) { h = pos - yp; }

inline void QRectF::setTopLeft(const QPointF &p) { setLeft(p.x()); setTop(p.y()); }

inline void QRectF::setTopRight(const QPointF &p) { setRight(p.x()); setTop(p.y()); }

inline void QRectF::setBottomLeft(const QPointF &p) { setLeft(p.x()); setBottom(p.y()); }

inline void QRectF::setBottomRight(const QPointF &p) { setRight(p.x()); setBottom(p.y()); }

inline QPointF QRectF::center() const
{ return QPointF(xp + w/2, yp + h/2); }

inline void QRectF::moveLeft(qreal pos) { xp = pos; }

inline void QRectF::moveTop(qreal pos) { yp = pos; }

inline void QRectF::moveRight(qreal pos) { xp = pos - w; }

inline void QRectF::moveBottom(qreal pos) { yp = pos - h; }

inline void QRectF::moveTopLeft(const QPointF &p) { moveLeft(p.x()); moveTop(p.y()); }

inline void QRectF::moveTopRight(const QPointF &p) { moveRight(p.x()); moveTop(p.y()); }

inline void QRectF::moveBottomLeft(const QPointF &p) { moveLeft(p.x()); moveBottom(p.y()); }

inline void QRectF::moveBottomRight(const QPointF &p) { moveRight(p.x()); moveBottom(p.y()); }

inline void QRectF::moveCenter(const QPointF &p) { xp = p.x() - w/2; yp = p.y() - h/2; }

inline qreal QRectF::width() const
{ return w; }

inline qreal QRectF::height() const
{ return h; }

inline QSizeF QRectF::size() const
{ return QSizeF(w, h); }

inline void QRectF::translate(qreal dx, qreal dy)
{
    xp += dx;
    yp += dy;
}

inline void QRectF::translate(const QPointF &p)
{
    xp += p.x();
    yp += p.y();
}

inline void QRectF::moveTo(qreal ax, qreal ay)
{
    xp = ax;
    yp = ay;
}

inline void QRectF::moveTo(const QPointF &p)
{
    xp = p.x();
    yp = p.y();
}

inline QRectF QRectF::translated(qreal dx, qreal dy) const
{ return QRectF(xp + dx, yp + dy, w, h); }

inline QRectF QRectF::translated(const QPointF &p) const
{ return QRectF(xp + p.x(), yp + p.y(), w, h); }

inline void QRectF::getRect(qreal *ax, qreal *ay, qreal *aaw, qreal *aah) const
{
    *ax = this->xp;
    *ay = this->yp;
    *aaw = this->w;
    *aah = this->h;
}

inline void QRectF::setRect(qreal ax, qreal ay, qreal aaw, qreal aah)
{
    this->xp = ax;
    this->yp = ay;
    this->w = aaw;
    this->h = aah;
}

inline void QRectF::getCoords(qreal *xp1, qreal *yp1, qreal *xp2, qreal *yp2) const
{
    *xp1 = xp;
    *yp1 = yp;
    *xp2 = xp + w;
    *yp2 = yp + h;
}

inline void QRectF::setCoords(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{
    xp = xp1;
    yp = yp1;
    w = xp2 - xp1;
    h = yp2 - yp1;
}

inline void QRectF::adjust(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{ xp += xp1; yp += yp1; w += xp2 - xp1; h += yp2 - yp1; }

inline QRectF QRectF::adjusted(qreal xp1, qreal yp1, qreal xp2, qreal yp2) const
{ return QRectF(xp + xp1, yp + yp1, w + xp2 - xp1, h + yp2 - yp1); }

inline void QRectF::setWidth(qreal aw)
{ this->w = aw; }

inline void QRectF::setHeight(qreal ah)
{ this->h = ah; }

inline void QRectF::setSize(const QSizeF &s)
{
    w = s.width();
    h = s.height();
}

inline bool QRectF::contains(qreal ax, qreal ay) const
{
    return contains(QPointF(ax, ay));
}

inline QRectF& QRectF::operator|=(const QRectF &r)
{
    *this = *this | r;
    return *this;
}

inline QRectF& QRectF::operator&=(const QRectF &r)
{
    *this = *this & r;
    return *this;
}

inline QRectF QRectF::intersect(const QRectF &r) const
{
    return *this & r;
}
inline QRectF QRectF::unite(const QRectF &r) const
{
    return *this | r;
}

inline bool operator==(const QRectF &r1, const QRectF &r2)
{
    return qFuzzyCompare(r1.xp, r2.xp) && qFuzzyCompare(r1.yp, r2.yp)
           && qFuzzyCompare(r1.w, r2.w) && qFuzzyCompare(r1.h, r2.h);
}

inline bool operator!=(const QRectF &r1, const QRectF &r2)
{
    return !qFuzzyCompare(r1.xp, r2.xp) || !qFuzzyCompare(r1.yp, r2.yp)
           || !qFuzzyCompare(r1.w, r2.w) || !qFuzzyCompare(r1.h, r2.h);
}

inline QRect QRectF::toRect() const
{
    return QRect(qRound(xp), qRound(yp), qRound(w), qRound(h));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QRectF &);































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QSet
{
    typedef QHash<T, QHashDummyValue> Hash;

public:
    inline QSet() {}
    inline QSet(const QSet<T> &other) : q_hash(other.q_hash) {}

    inline QSet<T> &operator=(const QSet<T> &other)
        { q_hash = other.q_hash; return *this; }

    inline bool operator==(const QSet<T> &other) const
        { return q_hash == other.q_hash; }
    inline bool operator!=(const QSet<T> &other) const
        { return q_hash != other.q_hash; }

    inline int size() const { return q_hash.size(); }

    inline bool isEmpty() const { return q_hash.isEmpty(); }

    inline int capacity() const { return q_hash.capacity(); }
    inline void reserve(int size);
    inline void squeeze() { q_hash.squeeze(); }

    inline void detach() { q_hash.detach(); }
    inline bool isDetached() const { return q_hash.isDetached(); }

    inline void clear() { q_hash.clear(); }

    inline bool remove(const T &value) { return q_hash.remove(value) != 0; }

    inline bool contains(const T &value) const { return q_hash.contains(value); }

    class const_iterator
    {
        typedef QHash<T, QHashDummyValue> Hash;
        typename Hash::const_iterator i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline const_iterator() {}
        inline const_iterator(typename Hash::const_iterator o) : i(o) {}
        inline const_iterator(const const_iterator &o) : i(o.i) {}
        inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
        inline const T &operator*() const { return i.key(); }
        inline const T *operator->() const { return &i.key(); }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { const_iterator r = *this; ++i; return r; }
        inline const_iterator &operator--() { --i; return *this; }
        inline const_iterator operator--(int) { const_iterator r = *this; --i; return r; }
        inline const_iterator operator+(int j) const { return i + j; }
        inline const_iterator operator-(int j) const { return i - j; }
        inline const_iterator &operator+=(int j) { i += j; return *this; }
        inline const_iterator &operator-=(int j) { i -= j; return *this; }
    };


    inline const_iterator begin() const { return q_hash.begin(); }
    inline const_iterator constBegin() const { return q_hash.constBegin(); }
    inline const_iterator end() const { return q_hash.end(); }
    inline const_iterator constEnd() const { return q_hash.constEnd(); }


    typedef const_iterator ConstIterator;
    inline int count() const { return q_hash.count(); }
    inline const_iterator insert(const T &value)
        { return static_cast<typename Hash::const_iterator>(q_hash.insert(value,
                                                                          QHashDummyValue())); }
    QSet<T> &unite(const QSet<T> &other);
    QSet<T> &intersect(const QSet<T> &other);
    QSet<T> &subtract(const QSet<T> &other);


    inline bool empty() const { return isEmpty(); }


    inline QSet<T> &operator<<(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator|=(const QSet<T> &other) { unite(other); return *this; }
    inline QSet<T> &operator|=(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator&=(const QSet<T> &other) { intersect(other); return *this; }
    inline QSet<T> &operator&=(const T &value)
        { QSet<T> result; if (contains(value)) result.insert(value); return (*this = result); }
    inline QSet<T> &operator+=(const QSet<T> &other) { unite(other); return *this; }
    inline QSet<T> &operator+=(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator-=(const QSet<T> &other) { subtract(other); return *this; }
    inline QSet<T> &operator-=(const T &value) { remove(value); return *this; }
    inline QSet<T> operator|(const QSet<T> &other)
        { QSet<T> result = *this; result |= other; return result; }
    inline QSet<T> operator&(const QSet<T> &other)
        { QSet<T> result = *this; result &= other; return result; }
    inline QSet<T> operator+(const QSet<T> &other)
        { QSet<T> result = *this; result += other; return result; }
    inline QSet<T> operator-(const QSet<T> &other)
        { QSet<T> result = *this; result -= other; return result; }

    QList<T> toList() const;
    inline QList<T> values() const { return toList(); }

    static QSet<T> fromList(const QList<T> &list);

private:
    Hash q_hash;
};

template <class T>
inline void QSet<T>::reserve(int asize) { q_hash.reserve(asize); }

template <class T>
inline QSet<T> &QSet<T>::unite(const QSet<T> &other)
{
    QSet<T> copy(other);
    typename QSet<T>::const_iterator i = copy.constEnd();
    while (i != copy.constBegin()) {
        --i;
        insert(*i);
    }
    return *this;
}

template <class T>
inline QSet<T> &QSet<T>::intersect(const QSet<T> &other)
{
    QSet<T> copy1(*this);
    QSet<T> copy2(other);
    typename QSet<T>::const_iterator i = copy1.constEnd();
    while (i != copy1.constBegin()) {
        --i;
        if (!copy2.contains(*i))
            remove(*i);
    }
    return *this;
}

template <class T>
inline QSet<T> &QSet<T>::subtract(const QSet<T> &other)
{
    QSet<T> copy1(*this);
    QSet<T> copy2(other);
    typename QSet<T>::const_iterator i = copy1.constEnd();
    while (i != copy1.constBegin()) {
        --i;
        if (copy2.contains(*i))
            remove(*i);
    }
    return *this;
}

template <typename T>
inline QList<T> QSet<T>::toList() const
{
    QList<T> result;
    typename QSet<T>::const_iterator i = constBegin();
    while (i != constEnd()) {
        result.append(*i);
        ++i;
    }
    return result;
}

template <typename T>
inline QSet<T> QList<T>::toSet() const
{
    QSet<T> result;
    result.reserve(size());
    for (int i = 0; i < size(); ++i)
        result.insert(at(i));
    return result;
}

template <typename T>
QSet<T> QSet<T>::fromList(const QList<T> &list)
{
    return list.toSet();
}

template <typename T>
QList<T> QList<T>::fromSet(const QSet<T> &set)
{
    return set.toList();
}

template <class T> class QSetIterator { typedef typename QSet<T>::const_iterator const_iterator; QSet<T> c; const_iterator i; public: inline QSetIterator(const QSet<T> &container) : c(container), i(c.constBegin()) {} inline QSetIterator &operator=(const QSet<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T> class QSharedDataPointer;

class __declspec(dllimport) QSharedData
{
public:
    QAtomic ref;

    inline QSharedData() : ref(0) { }
    inline QSharedData(const QSharedData &) : ref(0) { }

private:

    QSharedData &operator=(const QSharedData &);
};

template <class T> class QSharedDataPointer
{
public:
    inline void detach() { if (d && d->ref != 1) detach_helper(); }
    inline T &operator*() { detach(); return *d; }
    inline const T &operator*() const { return *d; }
    inline T *operator->() { detach(); return d; }
    inline const T *operator->() const { return d; }
    inline operator T *() { detach(); return d; }
    inline operator const T *() const { return d; }
    inline T *data() { detach(); return d; }
    inline const T *data() const { return d; }
    inline const T *constData() const { return d; }

    inline bool operator==(const QSharedDataPointer<T> &other) const { return d == other.d; }
    inline bool operator!=(const QSharedDataPointer<T> &other) const { return d != other.d; }

    inline QSharedDataPointer() { d = 0; }
    inline ~QSharedDataPointer() { if (d && !d->ref.deref()) delete d; }

    explicit QSharedDataPointer(T *data);
    inline QSharedDataPointer(const QSharedDataPointer &o) : d(o.d) { if (d) d->ref.ref(); }
    inline QSharedDataPointer & operator=(const QSharedDataPointer &o) {
        if (o.d != d) {
            T *x = o.d;
            if (x) x->ref.ref();
            x = qAtomicSetPtr(&d, x);
            if (x && !x->ref.deref())
                delete x;
        }
        return *this;
    }
    inline QSharedDataPointer &operator=(T *o) {
        if (o != d) {
            T *x = o;
            if (x) x->ref.ref();
            x = qAtomicSetPtr(&d, x);
            if (x && !x->ref.deref())
                delete x;
        }
        return *this;
    }

    inline bool operator!() const { return !d; }

private:
    void detach_helper();

    T *d;
};

template <class T>
inline QSharedDataPointer<T>::QSharedDataPointer(T *adata) : d(adata)
{ if (d) d->ref.ref(); }

template <class T>
inline void QSharedDataPointer<T>::detach_helper()
{
    T *x = new T(*d);
    x->ref.ref();
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        delete x;
}












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#pragma once





#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4244)

namespace std {

template<class _Ty, class _Alloc>
	class _Vector_val
	{
protected:
	_Vector_val(_Alloc _Al = _Alloc())
		: _Alval(_Al)
		{
		}

	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	_Alty _Alval;
	};


template<class _Ty,
	class _Ax = allocator<_Ty> >
	class vector
		: public _Vector_val<_Ty, _Ax>
	{
public:
	typedef vector<_Ty, _Ax> _Myt;
	typedef _Vector_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;
	typedef _Ptrit<value_type, difference_type, _Tptr,
		reference, _Tptr, reference> iterator;
	typedef _Ptrit<value_type, difference_type, _Ctptr,
		const_reference, _Tptr, reference> const_iterator;
	typedef std::reverse_iterator<iterator>
		reverse_iterator;
	typedef std::reverse_iterator<const_iterator>
		const_reverse_iterator;

	vector()
		: _Mybase()
		{
		_Buy(0);
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Buy(0);
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{
		_Ty _Val = _Ty();
		if (_Buy(_Count))
			_Construct_n(_Count, _Val);
		}

	vector(size_type _Count, const _Ty& _Val)
		: _Mybase()
		{
		if (_Buy(_Count))
			_Construct_n(_Count, _Val);
		}

	vector(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		if (_Buy(_Count))
			_Construct_n(_Count, _Val);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right._Alval)
		{
		if (_Buy(_Right.size()))
			try {
			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		size_type _Size = (size_type)_Count;
		if (_Buy(_Size))
			_Construct_n(_Size, _Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		_Buy(0);
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count, const _Ty& _Val)
		{
		try {
		_Mylast = _Ufill(_Myfirst, _Count, _Val);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	~vector()
		{
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{
		if (this == &_Right)
			;
		else if (_Right.size() == 0)
			clear();
		else if (_Right.size() <= size())
			{
			pointer _Ptr = copy(_Right.begin(), _Right.end(), _Myfirst);
			_Destroy(_Ptr, _Mylast);
			_Mylast = _Myfirst + _Right.size();
			}
		else if (_Right.size() <= capacity())
			{
			const_iterator _Where = _Right.begin() + size();
			copy(_Right.begin(), _Where, _Myfirst);
			_Mylast = _Ucopy(_Where, _Right.end(), _Mylast);
			}
		else
			{
			_Destroy(_Myfirst, _Mylast);
			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
			if (_Buy(_Right.size()))
				_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{
		if (max_size() < _Count)
			_Xlen();
		else if (capacity() < _Count)
			{
			pointer _Ptr = this->_Alval.allocate(_Count, (void *)0);

			try {
			_Ucopy(begin(), end(), _Ptr);
			} catch (...) {
			this->_Alval.deallocate(_Ptr, _Count);
			throw;
			}

			size_type _Size = size();
			if (_Myfirst != 0)
				{
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}
			_Myend = _Ptr + _Count;
			_Mylast = _Ptr + _Size;
			_Myfirst = _Ptr;
			}
		}

	size_type capacity() const
		{
		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);
		}

	iterator begin()
		{
		return (iterator(_Myfirst));
		}

	const_iterator begin() const
		{
		return (const_iterator(_Myfirst));
		}

	iterator end()
		{
		return (iterator(_Mylast));
		}

	const_iterator end() const
		{
		return (const_iterator(_Mylast));
		}

	reverse_iterator rbegin()
		{
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{
		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);
		}

	size_type max_size() const
		{
		return (this->_Alval.max_size());
		}

	bool empty() const
		{
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{
		return (this->_Alval);
		}

	const_reference at(size_type _Off) const
		{
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference at(size_type _Off)
		{
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference operator[](size_type _Off)
		{
		return (*(begin() + _Off));
		}

	const_reference operator[](size_type _Off) const
		{
		return (*(begin() + _Off));
		}

	reference front()
		{
		return (*begin());
		}

	const_reference front() const
		{
		return (*begin());
		}

	reference back()
		{
		return (*(end() - 1));
		}

	const_reference back() const
		{
		return (*(end() - 1));
		}

	void push_back(const _Ty& _Val)
		{
		if (size() < capacity())
			_Mylast = _Ufill(_Mylast, 1, _Val);
		else
			insert(end(), _Val);
		}

	void pop_back()
		{
		if (!empty())
			{
			_Destroy(_Mylast - 1, _Mylast);
			--_Mylast;
			}
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{
		size_type _Off = size() == 0 ? 0 : _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			_Int_iterator_tag)
		{
		_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{
		for (; _First != _Last; ++_First, ++_Where)
			_Where = insert(_Where, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			forward_iterator_tag)
		{
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();
		else if (_Capacity < size() + _Count)
			{
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity, (void *)0);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Ucopy(begin(), _Where, _Newvec);
			_Ptr = _Ucopy(_First, _Last, _Ptr);
			_Ucopy(_Where, end(), _Ptr);
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (_Myfirst != 0)
				{
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}
			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(end() - _Where) < _Count)
			{
			_Ucopy(_Where, end(), _Where.base() + _Count);
			_Iter _Mid = _First;
			advance(_Mid, end() - _Where);

			try {
			_Ucopy(_Mid, _Last, _Mylast);
			} catch (...) {
			_Destroy(_Where.base() + _Count, _Mylast + _Count);
			throw;
			}

			_Mylast += _Count;
			copy(_First, _Mid, _Where);
			}
		else
			{
			iterator _Oldend = end();
			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
				_Mylast);
			copy_backward(_Where, _Oldend - _Count, _Oldend);
			copy(_First, _Last, _Where);
			}
		}

	iterator erase(iterator _Where)
		{
		copy(_Where + 1, end(), _Where);
		_Destroy(_Mylast - 1, _Mylast);
		--_Mylast;
		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{
		if (_First != _Last)
			{
			pointer _Ptr = copy(_Last, end(), _First.base());
			_Destroy(_Ptr, _Mylast);
			_Mylast = _Ptr;
			}
		return (_First);
		}

	void clear()
		{
		_Tidy();
		}

	bool _Eq(const _Myt& _Right) const
		{
		return (size() == _Right.size()
			&& equal(begin(), end(), _Right.begin()));
		}

	bool _Lt(const _Myt& _Right) const
		{
		return (lexicographical_compare(begin(), end(),
			_Right.begin(), _Right.end()));
		}

	void swap(_Myt& _Right)
		{
		if (this->_Alval == _Right._Alval)
			{
			std::swap(_Myfirst, _Right._Myfirst);
			std::swap(_Mylast, _Right._Mylast);
			std::swap(_Myend, _Right._Myend);
			}
		else
			{
			_Myt _Ts = *this; *this = _Right, _Right = _Ts;
			}
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{
		_Ty _Tmp = _Val;
		erase(begin(), end());
		insert(begin(), _Count, _Tmp);
		}

	bool _Buy(size_type _Capacity)
		{
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();
		else
			{
			_Myfirst = this->_Alval.allocate(_Capacity, (void *)0);
			_Mylast = _Myfirst;
			_Myend = _Myfirst + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{
		_Destroy_range(_First, _Last, this->_Alval);
		}

	void _Tidy()
		{
		if (_Myfirst != 0)
			{
			_Destroy(_Myfirst, _Mylast);
			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
			}
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, this->_Alval));
		}

	void _Insert_n(iterator _Where, size_type _Count, const _Ty& _Val)
		{
		_Ty _Tmp = _Val;
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();
		else if (_Capacity < size() + _Count)
			{
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity, (void *)0);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Ucopy(begin(), _Where, _Newvec);
			_Ptr = _Ufill(_Ptr, _Count, _Tmp);
			_Ucopy(_Where, end(), _Ptr);
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (_Myfirst != 0)
				{
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}
			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(end() - _Where) < _Count)
			{
			_Ucopy(_Where, end(), _Where.base() + _Count);

			try {
			_Ufill(_Mylast, _Count - (end() - _Where),
				_Tmp);
			} catch (...) {
			_Destroy(_Where.base() + _Count, _Mylast + _Count);
			throw;
			}

			_Mylast += _Count;
			fill(_Where, end() - _Count, _Tmp);
			}
		else
			{
			iterator _Oldend = end();
			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
				_Mylast);
			copy_backward(_Where, _Oldend - _Count, _Oldend);
			fill(_Where, _Where + _Count, _Tmp);
			}
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty &_Val)
		{
		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
		return (_Ptr + _Count);
		}

	void _Xlen() const
		{
		throw length_error("vector<T> too long");
		}

	void _Xran() const
		{
		throw out_of_range("invalid vector<T> subscript");
		}

	pointer _Myfirst;
	pointer _Mylast;
	pointer _Myend;
	};


template<class _Ty, class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (_Left._Eq(_Right));
	}

template<class _Ty, class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (!(_Left == _Right));
	}

template<class _Ty, class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (_Left._Lt(_Right));
	}

template<class _Ty, class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (_Right < _Left);
	}

template<class _Ty, class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (!(_Right < _Left));
	}

template<class _Ty, class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{
	return (!(_Left < _Right));
	}


typedef unsigned _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);

typedef allocator<_Vbase> _Bool_allocator;

template<> class vector<_Bool, _Bool_allocator>
	{
public:
	typedef _Bool_allocator _Alloc;
	typedef _Alloc::size_type size_type;
	typedef _Alloc::difference_type _Dift;
	typedef std::vector<_Vbase, _Alloc> _Vbtype;
	typedef std::vector<_Bool, _Alloc> _Myt;
	typedef _Dift difference_type;
	typedef _Bool _Ty;
	typedef _Alloc allocator_type;


	class reference
		{
	public:
		reference()
			: _Mask(0), _Myptr(0)
			{
			}

		reference(size_t _Off, _Vbase *_Ptr)
			: _Mask((_Vbase)(1 << _Off)), _Myptr(_Ptr)
			{
			}

		reference& operator=(const reference& _Right)
			{
			return (*this = bool(_Right));
			}

		reference& operator=(bool _Val)
			{
			if (_Val)
				*_Myptr |= _Mask;
			else
				*_Myptr &= ~_Mask;
			return (*this);
			}

		void flip()
			{
			*_Myptr ^= _Mask;
			}

		bool operator~() const
			{
			return (!bool(*this));
			}

		operator bool() const
			{
			return ((*_Myptr & _Mask) != 0);
			}

	protected:
		_Vbase _Mask;
		_Vbase *_Myptr;
		};

	typedef reference _Reft;
	typedef bool const_reference;
	typedef bool value_type;




	class const_iterator
		: public _Ranit<_Bool, _Dift, const_reference *, const_reference>
		{
	public:
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Dift difference_type;
		typedef const_reference *pointer;
		typedef const_reference reference;

		const_iterator()
			: _Myoff(0), _Myptr(0)
			{
			}

		const_iterator(size_t _Off,
			 _Vbtype::const_iterator _Where)
			: _Myoff(_Off), _Myptr(_Where.base())
			{
			}

		const_reference operator*() const
			{
			return (_Reft(_Myoff, (_Vbase *)_Myptr));
			}

		const_iterator& operator++()
			{
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{
			const_iterator _Tmp = *this;
			_Inc();
			return (_Tmp);
			}

		const_iterator& operator--()
			{
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{
			const_iterator _Tmp = *this;
			_Dec();
			return (_Tmp);
			}

		const_iterator& operator+=(difference_type _Off)
			{
			_Myoff += _Off;
			_Myptr += _Myoff / _VBITS;
			_Myoff %= _VBITS;
			return (*this);
			}

		const_iterator operator+(difference_type _Off) const
			{
			const_iterator _Tmp = *this;
			return (_Tmp += _Off);
			}

		const_iterator& operator-=(difference_type _Off)
			{
			return (*this += -_Off);
			}

		const_iterator operator-(difference_type _Off) const
			{
			const_iterator _Tmp = *this;
			return (_Tmp -= _Off);
			}

		difference_type operator-(const const_iterator _Right) const
			{
			return (_VBITS * (_Myptr - _Right._Myptr)
				+ (difference_type)_Myoff
				- (difference_type)_Right._Myoff);
			}

		const_reference operator[](difference_type _Off) const
			{
			return (*(*this + _Off));
			}

		bool operator==(const const_iterator& _Right) const
			{
			return (_Myptr == _Right._Myptr && _Myoff == _Right._Myoff);
			}

		bool operator!=(const const_iterator& _Right) const
			{
			return (!(*this == _Right));
			}

		bool operator<(const const_iterator& _Right) const
			{
			return (_Myptr < _Right._Myptr
				|| _Myptr == _Right._Myptr && _Myoff < _Right._Myoff);
			}

		bool operator>(const const_iterator& _Right) const
			{
			return (_Right < *this);
			}

		bool operator<=(const const_iterator& _Right) const
			{
			return (!(_Right < *this));
			}

		bool operator>=(const const_iterator& _Right) const
			{
			return (!(*this < _Right));
			}

		friend const_iterator operator+(difference_type _Off,
			const const_iterator& _Right)
			{
			return (_Right + _Off);
			}

	protected:
		void _Dec()
			{
			if (_Myoff != 0)
				--_Myoff;
			else
				_Myoff = _VBITS - 1, --_Myptr;
			}

		void _Inc()
			{
			if (_Myoff < _VBITS - 1)
				++_Myoff;
			else
				_Myoff = 0, ++_Myptr;
			}

		size_t _Myoff;
		const _Vbase *_Myptr;
		};


	class iterator
		: public const_iterator
		{
	public:
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Dift difference_type;
		typedef _Reft *pointer;
		typedef _Reft reference;

		iterator()
			: const_iterator()
			{
			}

		iterator(size_t _Off,  _Vbtype::iterator _Where)
			: const_iterator(_Off, _Where)
			{
			}

		reference operator*() const
			{
			return (_Reft(_Myoff, (_Vbase *)_Myptr));
			}

		iterator& operator++()
			{
			_Inc();
			return (*this);
			}

		iterator operator++(int)
			{
			iterator _Tmp = *this;
			_Inc();
			return (_Tmp);
			}

		iterator& operator--()
			{
			_Dec();
			return (*this);
			}

		iterator operator--(int)
			{
			iterator _Tmp = *this;
			_Dec();
			return (_Tmp);
			}

		iterator& operator+=(difference_type _Off)
			{
			_Myoff += _Off;
			_Myptr += _Myoff / _VBITS;
			_Myoff %= _VBITS;
			return (*this);
			}

		iterator operator+(difference_type _Off) const
			{
			iterator _Tmp = *this;
			return (_Tmp += _Off);
			}

		iterator& operator-=(difference_type _Off)
			{
			return (*this += -_Off);
			}

		iterator operator-(difference_type _Off) const
			{
			iterator _Tmp = *this;
			return (_Tmp -= _Off);
			}

		difference_type operator-(const iterator _Right) const
			{
			return (_VBITS * (_Myptr - _Right._Myptr)
				+ (difference_type)_Myoff
				- (difference_type)_Right._Myoff);
			}

		reference operator[](difference_type _Off) const
			{
			return (*(*this + _Off));
			}

		friend iterator operator+(difference_type _Off,
			const iterator& _Right)
			{
			return (_Right + _Off);
			}
		};

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mysize(0), _Myvec()
		{
		}

	explicit vector(const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{
		}

	explicit vector(size_type _Count, bool _Val = false)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0))
		{
		_Trim(_Count);
		}

	vector(size_type _Count, bool _Val, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{
		_Trim(_Count);
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mysize(0), _Myvec()
		{
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		size_type _Num = (size_type)_Count;
		_Myvec.assign(_Num, (_Ty)_Val ? -1 : 0);
		_Trim(_Num);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		insert(begin(), _First, _Last);
		}

	~vector()
		{
		_Mysize = 0;
		}

	void reserve(size_type _Count)
		{
		_Myvec.reserve(_Nw(_Count));
		}

	size_type capacity() const
		{
		return (_Myvec.capacity() * _VBITS);
		}

	iterator begin()
		{
		return (iterator(0, _Myvec.begin()));
		}

	const_iterator begin() const
		{
		return (const_iterator(0, _Myvec.begin()));
		}

	iterator end()
		{
		iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	const_iterator end() const
		{
		const_iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	reverse_iterator rbegin()
		{
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{
		return (_Mysize);
		}

	size_type max_size() const
		{
		const size_type _Maxsize = _Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const
		{
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{
		return (_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference at(size_type _Off)
		{
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	const_reference operator[](size_type _Off) const
		{
		return (*(begin() + _Off));
		}

	reference operator[](size_type _Off)
		{
		return (*(begin() + _Off));
		}

	reference front()
		{
		return (*begin());
		}

	const_reference front() const
		{
		return (*begin());
		}

	reference back()
		{
		return (*(end() - 1));
		}

	const_reference back() const
		{
		return (*(end() - 1));
		}

	void push_back(bool _Val)
		{
		insert(end(), _Val);
		}

	void pop_back()
		{
		if (!empty())
			erase(end() - 1);
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
		_Assign_n((size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, bool _Val)
		{
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, bool _Val)
		{
		size_type _Off = _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, bool _Val)
		{
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{
		_Insert_n(_Where, (size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, ++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			forward_iterator_tag)
		{
		size_type _Capacity = 0;
		_Distance(_First, _Last, _Capacity);

		if (_Capacity == 0)
			;
		else if (max_size() - size() < _Capacity)
			_Xlen();
		else
			{
			if (size() == 0)
				{
				_Myvec.resize(_Nw(size() + _Capacity), 0);
				_Where = begin();
				}
			else
				{
				size_type _Off = _Where - begin();
				_Myvec.resize(_Nw(size() + _Capacity), 0);
				_Where = begin() + _Off;
				copy_backward(_Where, end(), end() + _Capacity);
				}

			copy(_First, _Last, _Where);
			_Mysize += _Capacity;
			}
		}

	iterator erase(iterator _Where)
		{
		copy(_Where + 1, end(), _Where);
		_Trim(_Mysize - 1);
		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{
		iterator _Next = copy(_Last, end(), _First);
		_Trim(_Next - begin());
		return (_First);
		}

	void clear()
		{
		erase(begin(), end());
		}

	void flip()
		{
		for (_Vbtype::iterator _Next = _Myvec.begin();
			_Next != _Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(_Mysize);
		}

	bool _Eq(const _Myt& _Right) const
		{
		return (_Mysize == _Right._Mysize && _Myvec == _Right._Myvec);
		}

	bool _Lt(const _Myt& _Right) const
		{
		return (lexicographical_compare(begin(), end(),
			_Right.begin(), _Right.end()));
		}

	void swap(_Myt& _Right)
		{
		std::swap(_Mysize, _Right._Mysize);
		_Myvec.swap(_Right._Myvec);
		}

	friend void swap(_Myt& _Left, _Myt& _Right)
		{
		_Left.swap(_Right);
		}

	static void swap(reference _Left, reference _Right)
		{
		bool _Val = _Left;
		_Left = _Right;
		_Right = _Val;
		}

protected:
	void _Assign_n(size_type _Count, bool _Val)
		{
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	void _Insert_n(iterator _Where, size_type _Count, bool _Val)
		{
		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();
		else
			{
			if (size() == 0)
				{
				_Myvec.resize(_Nw(size() + _Count), 0);
				_Where = begin();
				}
			else
				{
				size_type _Off = _Where - begin();
				_Myvec.resize(_Nw(size() + _Count), 0);
				_Where = begin() + _Off;
				copy_backward(_Where, end(), end() + _Count);
				}

			fill(_Where, _Where + _Count, _Val);
			_Mysize += _Count;
			}
		}

	static size_type _Nw(size_type _Count)
		{
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	void _Trim(size_type _Size)
		{
		if (max_size() < _Size)
			_Xlen();
		size_type _Words = _Nw(_Size);

		if (_Words < _Myvec.size())
			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());
		_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
		}

	void _Xlen() const
		{
		throw length_error("vector<bool> too long");
		}

	void _Xran() const
		{
		throw out_of_range("invalid vector<bool> subscript");
		}

	size_type _Mysize;
	_Vbtype _Myvec;
	};

typedef vector<_Bool, _Bool_allocator> _Bvector;
}
  #pragma warning(default: 4244)
#pragma warning(pop)
#pragma pack(pop)




























typedef QtValidLicenseForCoreModule QtCoreModule;

struct __declspec(dllimport) QVectorData
{
    QBasicAtomic ref;
    int alloc;
    int size;
    uint sharable : 1;

    static QVectorData shared_null;
    static QVectorData *malloc(int sizeofTypedData, int size, int sizeofT, QVectorData *init);
    static int grow(int sizeofTypedData, int size, int sizeofT, bool excessive);
};

template <typename T>
struct QVectorTypedData
{
    QBasicAtomic ref;
    int alloc;
    int size;
    uint sharable : 1;
    T array[1];
};

template <typename T>
class QVector
{
    typedef QVectorTypedData<T> Data;
    union { QVectorData *p; QVectorTypedData<T> *d; };

public:
    inline QVector() : p(&QVectorData::shared_null) { d->ref.ref(); }
    explicit QVector(int size);
    QVector(int size, const T &t);
    inline QVector(const QVector &v) : d(v.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }
    inline ~QVector() { if (!d) return; if (!d->ref.deref()) free(d); }
    QVector &operator=(const QVector &v);
    bool operator==(const QVector &v) const;
    inline bool operator!=(const QVector &v) const { return !(*this == v); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    void resize(int size);

    inline int capacity() const { return d->alloc; }
    void reserve(int size);
    inline void squeeze() { realloc(d->size, d->size); }

    inline void detach() { if (d->ref != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref == 1; }
    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

    inline T *data() { detach(); return d->array; }
    inline const T *data() const { return d->array; }
    inline const T *constData() const { return d->array; }
    void clear();

    const T &at(int i) const;
    T &operator[](int i);
    const T &operator[](int i) const;
    void append(const T &t);
    void prepend(const T &t);
    void insert(int i, const T &t);
    void insert(int i, int n, const T &t);
    void replace(int i, const T &t);
    void remove(int i);
    void remove(int i, int n);

    QVector &fill(const T &t, int size = -1);

    int indexOf(const T &t, int from = 0) const;
    int lastIndexOf(const T &t, int from = -1) const;
    bool contains(const T &t) const;
    int count(const T &t) const;


    typedef T* iterator;
    typedef const T* const_iterator;
    inline iterator begin() { detach(); return d->array; }
    inline const_iterator begin() const { return d->array; }
    inline const_iterator constBegin() const { return d->array; }
    inline iterator end() { detach(); return d->array + d->size; }
    inline const_iterator end() const { return d->array + d->size; }
    inline const_iterator constEnd() const { return d->array + d->size; }
    iterator insert(iterator before, int n, const T &x);
    inline iterator insert(iterator before, const T &x) { return insert(before, 1, x); }
    iterator erase(iterator begin, iterator end);
    inline iterator erase(iterator pos) { return erase(pos, pos+1); }


    inline int count() const { return d->size; }
    inline T& first() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",121);} while (0); return *begin(); }
    inline const T &first() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",122);} while (0); return *begin(); }
    inline T& last() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",123);} while (0); return *(end()-1); }
    inline const T &last() const { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",124);} while (0); return *(end()-1); }
    QVector<T> mid(int pos, int length = -1) const;

    T value(int i) const;
    T value(int i, const T &defaultValue) const;


    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    typedef ptrdiff_t difference_type;



    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    typedef int size_type;
    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    void pop_back() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",146);} while (0); erase(end()-1); }
    void pop_front() { do {if(!(!isEmpty()))qt_assert("!isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",147);} while (0); erase(begin()); }
    inline bool empty() const
    { return d->size == 0; }
    inline T& front() { return first(); }
    inline const_reference front() const { return first(); }
    inline reference back() { return last(); }
    inline const_reference back() const { return last(); }


    QVector &operator+=(const QVector &l);
    inline QVector operator+(const QVector &l) const
    { QVector n = *this; n += l; return n; }
    inline QVector &operator+=(const T &t)
    { append(t); return *this; }
    inline QVector &operator<< (const T &t)
    { append(t); return *this; }
    inline QVector &operator<<(const QVector &l)
    { *this += l; return *this; }

    QList<T> toList() const;

    static QVector<T> fromList(const QList<T> &list);


    static inline QVector<T> fromStdVector(const std::vector<T> &vector)
    { QVector<T> tmp; qCopy(vector.begin(), vector.end(), std::back_inserter(tmp)); return tmp; }
    inline std::vector<T> toStdVector() const
    { std::vector<T> tmp; qCopy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }


private:
    void detach_helper();
    QVectorData *malloc(int alloc);
    void realloc(int size, int alloc);
    void free(Data *d);
};

template <typename T>
void QVector<T>::detach_helper()
{ realloc(d->size, d->alloc); }
template <typename T>
void QVector<T>::reserve(int asize)
{ if (asize > d->alloc) realloc(d->size, asize); }
template <typename T>
void QVector<T>::resize(int asize)
{ realloc(asize, (asize > d->alloc || (asize < d->size && asize < (d->alloc >> 1))) ?
          QVectorData::grow(sizeof(Data), asize, sizeof(T), QTypeInfo<T>::isStatic)
          : d->alloc); }
template <typename T>
inline void QVector<T>::clear()
{ *this = QVector<T>(); }
template <typename T>
inline const T &QVector<T>::at(int i) const
{ do {if(!(i >= 0 && i < d->size))qt_assert_x("QVector<T>::at", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",200);} while (0);
  return d->array[i]; }
template <typename T>
inline const T &QVector<T>::operator[](int i) const
{ do {if(!(i >= 0 && i < d->size))qt_assert_x("QVector<T>::operator[]", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",204);} while (0);
  return d->array[i]; }
template <typename T>
inline T &QVector<T>::operator[](int i)
{ do {if(!(i >= 0 && i < d->size))qt_assert_x("QVector<T>::operator[]", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",208);} while (0);
  return data()[i]; }
template <typename T>
inline void QVector<T>::insert(int i, const T &t)
{ do {if(!(i >= 0 && i <= d->size))qt_assert_x("QVector<T>::insert", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",212);} while (0);
  insert(begin() + i, 1, t); }
template <typename T>
inline void QVector<T>::insert(int i, int n, const T &t)
{ do {if(!(i >= 0 && i <= d->size))qt_assert_x("QVector<T>::insert", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",216);} while (0);
  insert(begin() + i, n, t); }
template <typename T>
inline void QVector<T>::remove(int i, int n)
{ do {if(!(i >= 0 && n >= 0 && i + n <= d->size))qt_assert_x("QVector<T>::remove", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",220);} while (0);
  erase(begin() + i, begin() + i + n); }
template <typename T>
inline void QVector<T>::remove(int i)
{ do {if(!(i >= 0 && i < d->size))qt_assert_x("QVector<T>::remove", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",224);} while (0);
  erase(begin() + i, begin() + i + 1); }
template <typename T>
inline void QVector<T>::prepend(const T &t)
{ insert(begin(), 1, t); }

template <typename T>
inline void QVector<T>::replace(int i, const T &t)
{
    do {if(!(i >= 0 && i < d->size))qt_assert_x("QVector<T>::replace", "index out of range","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",233);} while (0);
    const T copy(t);
    data()[i] = copy;
}

template <typename T>
QVector<T> &QVector<T>::operator=(const QVector<T> &v)
{
    typename QVector::Data *x = v.d;
    x->ref.ref();
    x = qAtomicSetPtr(&d, x);
    if (!x->ref.deref())
        free(x);
    if (!d->sharable)
        detach_helper();
    return *this;
}

template <typename T>
inline QVectorData *QVector<T>::malloc(int aalloc)
{
    return static_cast<QVectorData *>(qMalloc(sizeof(Data) + (aalloc - 1) * sizeof(T)));
}

template <typename T>
QVector<T>::QVector(int asize)
{
    p = malloc(asize);
    d->ref.init(1);
    d->alloc = d->size = asize;
    d->sharable = true;
    if (QTypeInfo<T>::isComplex) {
        T* b = d->array;
        T* i = d->array + d->size;
        while (i != b)
            new (--i) T;
    } else {
        qMemSet(d->array, 0, asize * sizeof(T));
    }
}

template <typename T>
QVector<T>::QVector(int asize, const T &t)
{
    p = malloc(asize);
    d->ref.init(1);
    d->alloc = d->size = asize;
    d->sharable = true;
    T* i = d->array + d->size;
    while (i != d->array)
        new (--i) T(t);
}

template <typename T>
void QVector<T>::free(Data *x)
{
    if (QTypeInfo<T>::isComplex) {
        T* b = x->array;
        T* i = b + x->size;
        while (i-- != b)
             i->~T();
    }
    qFree(x);
}

template <typename T>
void QVector<T>::realloc(int asize, int aalloc)
{
    T *j, *i, *b;
    union { QVectorData *p; Data *d; } x;
    x.d = d;

    if (QTypeInfo<T>::isComplex && aalloc == d->alloc && d->ref == 1) {

        i = d->array + d->size;
        j = d->array + asize;
        if (i > j) {
            while (i-- != j)
                i->~T();
        } else {
            while (j-- != i)
                new (j) T;
        }
        d->size = asize;
        return;
    }

    if (aalloc != d->alloc || d->ref != 1) {

        if (QTypeInfo<T>::isStatic) {
            x.p = malloc(aalloc);
        } else if (d->ref != 1) {
            x.p = QVectorData::malloc(sizeof(Data), aalloc, sizeof(T), p);
        } else {
            if (QTypeInfo<T>::isComplex) {


                if (asize < d->size) {
                    j = d->array + asize;
                    i = d->array + d->size;
                    while (i-- != j)
                        i->~T();
                    i = d->array + asize;
                }
            }
            x.p = p =
                  static_cast<QVectorData *>(qRealloc(p, sizeof(Data) + (aalloc - 1) * sizeof(T)));
        }
        x.d->ref.init(1);
        x.d->sharable = true;
    }
    if (QTypeInfo<T>::isComplex) {
        if (asize < d->size) {
            j = d->array + asize;
            i = x.d->array + asize;
        } else {

            i = x.d->array + asize;
            j = x.d->array + d->size;
            while (i != j)
                new (--i) T;
            j = d->array + d->size;
        }
        if (i != j) {

            b = x.d->array;
            while (i != b)
                new (--i) T(*--j);
        }
    } else if (asize > d->size) {

        qMemSet(x.d->array + d->size, 0, (asize - d->size) * sizeof(T));
    }
    x.d->size = asize;
    x.d->alloc = aalloc;
    if (d != x.d) {
        x.d = qAtomicSetPtr(&d, x.d);
        if (!x.d->ref.deref())
            free(x.d);
    }
}

template<typename T>
inline T QVector<T>::value(int i) const
{
    if (i < 0 || i >= p->size) {
        return T();
    }
    return d->array[i];
}
template<typename T>
inline T QVector<T>::value(int i, const T &defaultValue) const
{
    return ((i < 0 || i >= p->size) ? defaultValue : d->array[i]);
}

template <typename T>
void QVector<T>::append(const T &t)
{
    const T copy(t);
    if (d->ref != 1 || d->size + 1 > d->alloc)
        realloc(d->size, QVectorData::grow(sizeof(Data), d->size + 1, sizeof(T),
                                           QTypeInfo<T>::isStatic));
    if (QTypeInfo<T>::isComplex)
        new (d->array + d->size) T(copy);
    else
        d->array[d->size] = copy;
    ++d->size;
}


template <typename T>
 QVector<T>::iterator QVector<T>::insert(iterator before, size_type n, const T &t)
{
    int offset = before - d->array;
    if (n != 0) {
        const T copy(t);
        if (d->ref != 1 || d->size + n > d->alloc)
            realloc(d->size, QVectorData::grow(sizeof(Data), d->size + n, sizeof(T),
                                               QTypeInfo<T>::isStatic));
        if (QTypeInfo<T>::isStatic) {
            T *b = d->array + d->size;
            T *i = d->array + d->size + n;
            while (i != b)
                new (--i) T;
            i = d->array + d->size;
            T *j = i + n;
            b = d->array + offset;
            while (i != b)
                *--j = *--i;
            i = b+n;
            while (i != b)
                *--i = copy;
        } else {
            T *b = d->array + offset;
            T *i = b + n;
            memmove(i, b, (d->size - offset) * sizeof(T));
            while (i != b)
                new (--i) T(copy);
        }
        d->size += n;
    }
    return d->array + offset;
}

template <typename T>
 QVector<T>::iterator QVector<T>::erase(iterator abegin, iterator aend)
{
    int f = abegin - d->array;
    int l = aend - d->array;
    int n = l - f;
    detach();
    if (QTypeInfo<T>::isComplex) {
        qCopy(d->array+l, d->array+d->size, d->array+f);
        T *i = d->array+d->size;
        T* b = d->array+d->size-n;
        while (i != b) {
            --i;
            i->~T();
        }
    } else {
        memmove(d->array + f, d->array + l, (d->size-l)*sizeof(T));
    }
    d->size -= n;
    return d->array + f;
}

template <typename T>
bool QVector<T>::operator==(const QVector<T> &v) const
{
    if (d->size != v.d->size)
        return false;
    if (d == v.d)
        return true;
    T* b = d->array;
    T* i = b + d->size;
    T* j = v.d->array + d->size;
    while (i != b)
        if (!(*--i == *--j))
            return false;
    return true;
}

template <typename T>
QVector<T> &QVector<T>::fill(const T &from, int asize)
{
    const T copy(from);
    resize(asize < 0 ? d->size : asize);
    if (d->size) {
        T *i = d->array + d->size;
        T *b = d->array;
        while (i != b)
            *--i = copy;
    }
    return *this;
}

template <typename T>
QVector<T> &QVector<T>::operator+=(const QVector &l)
{
    int newSize = d->size + l.d->size;
    realloc(d->size, newSize);

    T *w = d->array + newSize;
    T *i = l.d->array + l.d->size;
    T *b = l.d->array;
    while (i != b) {
        if (QTypeInfo<T>::isComplex)
            new (--w) T(*--i);
        else
            *--w = *--i;
    }
    d->size = newSize;
    return *this;
}

template <typename T>
int QVector<T>::indexOf(const T &t, int from) const
{
    if (from < 0)
        from = qMax(from + d->size, 0);
    if (from < d->size) {
        T* n = d->array + from - 1;
        T* e = d->array + d->size;
        while (++n != e)
            if (*n == t)
                return n - d->array;
    }
    return -1;
}

template <typename T>
int QVector<T>::lastIndexOf(const T &t, int from) const
{
    if (from < 0)
        from += d->size;
    else if (from >= d->size)
        from = d->size-1;
    if (from >= 0) {
        T* b = d->array;
        T* n = d->array + from + 1;
        while (n != b) {
            if (*--n == t)
                return n - b;
        }
    }
    return -1;
}

template <typename T>
bool QVector<T>::contains(const T &t) const
{
    T* b = d->array;
    T* i = d->array + d->size;
    while (i != b)
        if (*--i == t)
            return true;
    return false;
}

template <typename T>
int QVector<T>::count(const T &t) const
{
    int c = 0;
    T* b = d->array;
    T* i = d->array + d->size;
    while (i != b)
        if (*--i == t)
            ++c;
    return c;
}

template <typename T>
inline QVector<T> QVector<T>::mid(int pos, int length) const
{
    if (length < 0)
        length = size() - pos;
    if (pos == 0 && length == size())
        return *this;
    QVector<T> copy;
    if (pos + length > size())
        length = size() - pos;
    for (int i = pos; i < pos + length; ++i)
        copy += at(i);
    return copy;
}

template <typename T>
inline QList<T> QVector<T>::toList() const
{
    QList<T> result;
    for (int i = 0; i < size(); ++i)
        result.append(at(i));
    return result;
}

template <typename T>
inline QVector<T> QList<T>::toVector() const
{
    QVector<T> result(size());
    for (int i = 0; i < size(); ++i)
        result[i] = at(i);
    return result;
}

template <typename T>
QVector<T> QVector<T>::fromList(const QList<T> &list)
{
    return list.toVector();
}

template <typename T>
QList<T> QList<T>::fromVector(const QVector<T> &vector)
{
    return vector.toList();
}

template <class T> class QVectorIterator { typedef typename QVector<T>::const_iterator const_iterator; QVector<T> c; const_iterator i; public: inline QVectorIterator(const QVector<T> &container) : c(container), i(c.constBegin()) {} inline QVectorIterator &operator=(const QVector<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableVectorIterator { typedef typename QVector<T>::iterator iterator; QVector<T> *c; iterator i, n; inline bool item_exists() const { return n != c->constEnd(); } public: inline QMutableVectorIterator(QVector<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableVectorIterator() { c->setSharable(true); } inline QMutableVectorIterator &operator=(QVector<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != i; } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != i; } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != n) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != n) *n = t; } inline T &value() { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",611);} while (0); return *n; } inline const T &value() const { do {if(!(item_exists()))qt_assert("item_exists()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvector.h",611);} while (0); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != (n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != i) if (*(n = --i) == t) return true; n = c->end(); return false; } };





typedef QtValidLicenseForCoreModule QtCoreModule;

template<class T>
class QStack : public QVector<T>
{
public:
    inline QStack() {}
    inline ~QStack() {}
    inline void push(const T &t) { append(t); }
    T pop();
    T &top();
    const T &top() const;
};

template<class T>
inline T QStack<T>::pop()
{ do {if(!(!this->isEmpty()))qt_assert("!this->isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstack.h",35);} while (0); T t = this->data()[this->size() -1];
  this->resize(this->size()-1); return t; }

template<class T>
inline T &QStack<T>::top()
{ do {if(!(!this->isEmpty()))qt_assert("!this->isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstack.h",40);} while (0); this->detach(); return this->data()[this->size()-1]; }

template<class T>
inline const T &QStack<T>::top() const
{ do {if(!(!this->isEmpty()))qt_assert("!this->isEmpty()","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qstack.h",44);} while (0); return this->data()[this->size()-1]; }











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForCoreModule QtCoreModule;

template<class T, int Prealloc = 256>
class QVarLengthArray
{
public:
    inline explicit QVarLengthArray(int size = 0);

    inline QVarLengthArray(const QVarLengthArray &other)
        : a(Prealloc), s(0), ptr(reinterpret_cast<T *>(array))
    {
        append(other.constData(), other.size());
    }

    inline ~QVarLengthArray() {
        if (QTypeInfo<T>::isComplex) {
            T *i = ptr + s;
            while (i-- != ptr)
                i->~T();
        }
        if (ptr != reinterpret_cast<T *>(array))
            qFree(ptr);
    }
    inline QVarLengthArray &operator=(const QVarLengthArray &other)
    {
        if (this != &other) {
            clear();
            append(other.constData(), other.size());
        }
        return *this;
    }

    inline int size() const { return s; }
    inline int count() const { return s; }
    inline bool isEmpty() const { return (s == 0); }
    inline void resize(int size);
    inline void clear() { resize(0); }

    inline int capacity() const { return a; }
    inline void reserve(int size);

    inline T &operator[](int idx) {
        do {if(!(idx >= 0 && idx < s))qt_assert("idx >= 0 && idx < s","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvarlengtharray.h",61);} while (0);
        return ptr[idx];
    }
    inline const T &operator[](int idx) const {
        do {if(!(idx >= 0 && idx < s))qt_assert("idx >= 0 && idx < s","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvarlengtharray.h",65);} while (0);
        return ptr[idx];
    }

    inline void append(const T &t) {
        const int idx = s;
        resize(idx + 1);
        ptr[idx] = t;
    }
    void append(const T *buf, int size);

    inline T *data() { return ptr; }
    inline const T *data() const { return ptr; }
    inline const T * constData() const { return ptr; }

private:
    void realloc(int size, int alloc);

    int a;
    int s;
    T *ptr;
    qint64 array[((Prealloc * sizeof(T)) / sizeof(qint64)) + 1];
};

template <class T, int Prealloc>
inline QVarLengthArray<T, Prealloc>::QVarLengthArray(int asize)
    : s(asize) {
    if (s > Prealloc) {
        ptr = reinterpret_cast<T *>(qMalloc(s * sizeof(T)));
        a = s;
    } else {
        ptr = reinterpret_cast<T *>(array);
        a = Prealloc;
    }
    if (QTypeInfo<T>::isComplex) {
        T *i = ptr + s;
        while (i != ptr)
            new (--i) T;
    }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::resize(int asize)
{ realloc(asize, qMax(asize, a)); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::reserve(int asize)
{ if (asize > a) realloc(s, asize); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::append(const T *abuf, int asize)
{
    do {if(!(abuf))qt_assert("abuf","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvarlengtharray.h",117);} while (0);
    if (asize <= 0)
        return;

    const int idx = s;
    resize(idx + asize);

    if (QTypeInfo<T>::isComplex) {
        T *i = ptr + idx;
        T *j = i + asize;
        while (i < j)
            new (i++) T(*abuf++);
    } else {
        qMemCopy(&ptr[idx], abuf, asize * sizeof(T));
    }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::realloc(int asize, int aalloc)
{
    do {if(!(aalloc >= asize))qt_assert("aalloc >= asize","d:\\depot\\qt\\include\\qtcore\\../../src/corelib/tools/qvarlengtharray.h",137);} while (0);
    T *oldPtr = ptr;
    int osize = s;
    s = asize;

    if (aalloc != a) {
        ptr = reinterpret_cast<T *>(qMalloc(aalloc * sizeof(T)));
        a = aalloc;

        if (QTypeInfo<T>::isStatic) {
            T *i = ptr + osize;
            T *j = oldPtr + osize;
            while (i != ptr) {
                new (--i) T(*--j);
                j->~T();
            }
        } else {
            qMemCopy(ptr, oldPtr, osize * sizeof(T));
        }
    }

    if (QTypeInfo<T>::isComplex) {
        if (asize < osize) {
            T *i = oldPtr + osize;
            T *j = oldPtr + asize;
            while (i-- != j)
                i->~T();
        } else {
            T *i = ptr + asize;
            T *j = ptr + osize;
            while (i != j)
                new (--i) T;
        }
    }

    if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
        qFree(oldPtr);
}







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPaintDevice;
class QWidget;
class QDialog;
class QColor;
class QPalette;



class QCursor;
class QPoint;
class QSize;
class QRect;
class QPolygon;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QPicture;
class QPrinter;
class QTimer;
class QTime;
class QClipboard;
class QString;
class QByteArray;
class QApplication;

template<typename T> class QList;
typedef QList<QWidget *> QWidgetList;

















































































struct HINSTANCE__; typedef struct HINSTANCE__ *HINSTANCE;


struct HDC__; typedef struct HDC__ *HDC;


struct HWND__; typedef struct HWND__ *HWND;


struct HFONT__; typedef struct HFONT__ *HFONT;


struct HPEN__; typedef struct HPEN__ *HPEN;


struct HBRUSH__; typedef struct HBRUSH__ *HBRUSH;


struct HBITMAP__; typedef struct HBITMAP__ *HBITMAP;


struct HICON__; typedef struct HICON__ *HICON;


typedef HICON HCURSOR;


struct HPALETTE__; typedef struct HPALETTE__ *HPALETTE;


struct HRGN__; typedef struct HRGN__ *HRGN;


struct HMONITOR__; typedef struct HMONITOR__ *HMONITOR;


typedef long HRESULT;


typedef struct tagMSG MSG;
typedef HWND WId;

__declspec(dllimport) HINSTANCE qWinAppInst();
__declspec(dllimport) HINSTANCE qWinAppPrevInst();
__declspec(dllimport) int           qWinAppCmdShow();
__declspec(dllimport) HDC           qt_win_display_dc();




























template<class K, class V> class QHash;
typedef QHash<WId, QWidget *> QWidgetMapper;










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

template <class T> class QVector;
class QVariant;





class QBitmap;

class __declspec(dllimport) QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion(int x, int y, int w, int h, RegionType t = Rectangle);
    QRegion(const QRect &r, RegionType t = Rectangle);
    QRegion(const QPolygon &pa, Qt::FillRule fillRule = Qt::OddEvenFill);



    QRegion(const QRegion &region);
    QRegion(const QBitmap &bitmap);
    ~QRegion();
    QRegion &operator=(const QRegion &);




    bool isEmpty() const;

    bool contains(const QPoint &p) const;
    bool contains(const QRect &r) const;

    void translate(int dx, int dy);
    inline void translate(const QPoint &p) { translate(p.x(), p.y()); }

    QRegion unite(const QRegion &r) const;
    QRegion intersect(const QRegion &r) const;
    QRegion subtract(const QRegion &r) const;
    QRegion eor(const QRegion &r) const;

    QRect boundingRect() const;
    QVector<QRect> rects() const;
    void setRects(const QRect *rect, int num);

    const QRegion operator|(const QRegion &r) const;
    const QRegion operator+(const QRegion &r) const;
    const QRegion operator&(const QRegion &r) const;
    const QRegion operator-(const QRegion &r) const;
    const QRegion operator^(const QRegion &r) const;
    QRegion& operator|=(const QRegion &r);
    QRegion& operator+=(const QRegion &r);
    QRegion& operator&=(const QRegion &r);
    QRegion& operator-=(const QRegion &r);
    QRegion& operator^=(const QRegion &r);

    bool operator==(const QRegion &r) const;
    inline bool operator!=(const QRegion &r) const { return !(operator==(r)); }
    operator QVariant() const;




    inline HRGN    handle() const { return d->rgn; }











    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRegion &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QRegion &);

private:
    QRegion copy() const;
    void detach();

    QRegion winCombine(const QRegion &r, int num) const;







    void exec(const QByteArray &ba, int ver = 0);
    struct QRegionData {
        QBasicAtomic ref;

        HRGN   rgn;









    };

    friend class QETWidget;

    struct QRegionData *d;
    static struct QRegionData shared_empty;
    static void cleanUp(QRegionData *x);
};






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRegion &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRegion &);



__declspec(dllimport) QDebug operator<<(QDebug, const QRegion &);













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;







class QKeySequence;
__declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
__declspec(dllimport) QDataStream &operator>>(QDataStream &out, QKeySequence &ks);


class QVariant;
class QKeySequencePrivate;

class __declspec(dllimport) QKeySequence
{
public:
    QKeySequence();
    QKeySequence(const QString &key);
    QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0);
    QKeySequence(const QKeySequence &ks);
    ~QKeySequence();

    uint count() const;
    bool isEmpty() const;

    enum SequenceMatch {
        NoMatch,
        PartialMatch,
        ExactMatch



    };

    SequenceMatch matches(const QKeySequence &seq) const;
    static QKeySequence mnemonic(const QString &text);

    operator QString() const;
    operator QVariant() const;
    operator int() const;
    int operator[](uint i) const;
    QKeySequence &operator=(const QKeySequence &other);
    bool operator==(const QKeySequence &other) const;
    inline bool operator!= (const QKeySequence &other) const
    { return !(*this == other); }
    bool operator< (const QKeySequence &ks) const;
    inline bool operator> (const QKeySequence &other) const
    { return other < *this; }
    inline bool operator<= (const QKeySequence &other) const
    { return !(other < *this); }
    inline bool operator>= (const QKeySequence &other) const
    { return !(*this < other); }

    bool isDetached() const;
private:
    static int decodeString(const QString &ks);
    static QString encodeString(int key);
    int assign(const QString &str);
    void setKey(int key, int index);

    QKeySequencePrivate *d;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &in, QKeySequence &ks);
    friend class Q3AccelManager;
    friend class QShortcutMap;
    friend class QShortcut;
};
template <> class QTypeInfo<QKeySequence> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QKeySequence)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QKeySequence"; } };
template <> inline bool qIsDetached<QKeySequence>(QKeySequence &t) { return t.isDetached(); }


__declspec(dllimport) QDebug operator<<(QDebug, const QKeySequence &);












































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QMimeSource
{
public:
    virtual ~QMimeSource();
    virtual const char* format(int n = 0) const = 0;
    virtual bool provides(const char*) const;
    virtual QByteArray encodedData(const char*) const = 0;
};




typedef struct tagFORMATETC FORMATETC;
typedef struct tagSTGMEDIUM STGMEDIUM;
struct IDataObject;



































































































































































































































































































































































































































































































































































































































































class __declspec(dllimport) QWindowsMime {
public:
    QWindowsMime();
    virtual ~QWindowsMime();


    virtual bool canConvertFromMime(const FORMATETC &formatetc, const QMimeData *mimeData) const = 0;
    virtual bool convertFromMime(const FORMATETC &formatetc, const QMimeData *mimeData, STGMEDIUM * pmedium) const = 0;
    virtual QVector<FORMATETC> formatsForMime(const QString &mimeType, const QMimeData *mimeData) const = 0;


    virtual bool canConvertToMime(const QString &mimeType, IDataObject *pDataObj) const = 0;
    virtual QVariant convertToMime(const QString &mimeType, IDataObject *pDataObj, QVariant::Type preferredType) const = 0;
    virtual QString mimeForFormat(const FORMATETC &formatetc) const = 0;

    static int registerMimeType(const QString &mime);

private:
    friend class QClipboardWatcher;
    friend class QDragManager;
    friend class QDropData;
    friend class QOleDataObject;

    static QWindowsMime *converterToMime(const QString &mimeType, IDataObject *pDataObj);
    static QStringList allMimesForFormats(IDataObject *pDataObj);
    static QWindowsMime *converterFromMime(const FORMATETC &formatetc, const QMimeData *mimeData);
    static QVector<FORMATETC> allFormatsForMime(const QMimeData *mimeData);
};











































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QMimeData;
class QDragPrivate;
class QWidget;
class QPixmap;
class QPoint;
class QDragManager;

class __declspec(dllimport) QDrag : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QDragPrivate* d_func() { return reinterpret_cast<QDragPrivate *>(d_ptr); } inline const QDragPrivate* d_func() const { return reinterpret_cast<const QDragPrivate *>(d_ptr); } friend class QDragPrivate;
public:
    explicit QDrag(QWidget *dragSource);
    ~QDrag();

    void setMimeData(QMimeData *data);
    QMimeData *mimeData() const;

    void setPixmap(const QPixmap &);
    QPixmap pixmap() const;

    void setHotSpot(const QPoint &hotspot);
    QPoint hotSpot() const;

    QWidget *source() const;
    QWidget *target() const;

    Qt::DropAction start(Qt::DropActions supportedActions = Qt::CopyAction);

    void setDragCursor(const QPixmap &cursor, Qt::DropAction action);

protected:
    void actionChanged(Qt::DropAction action);
    void targetChanged(QWidget *newTarget);

private:



    friend class QDragManager;
    QDrag(const QDrag &); QDrag &operator=(const QDrag &);
};

































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QAction;

class __declspec(dllimport) QInputEvent : public QEvent
{
public:
    QInputEvent(Type type, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
    ~QInputEvent();
    inline Qt::KeyboardModifiers modifiers() const { return modState; }
protected:
    Qt::KeyboardModifiers modState;
};


class __declspec(dllimport) QMouseEvent : public QInputEvent
{
public:
    QMouseEvent(Type type, const QPoint &pos, Qt::MouseButton button,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
    QMouseEvent(Type type, const QPoint &pos, const QPoint &globalPos,
                Qt::MouseButton button, Qt::MouseButtons buttons,
                Qt::KeyboardModifiers modifiers);
    ~QMouseEvent();

    inline const QPoint &pos() const { return p; }
    inline const QPoint &globalPos() const { return g; }
    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return g.x(); }
    inline int globalY() const { return g.y(); }
    inline Qt::MouseButton button() const { return b; }
    inline Qt::MouseButtons buttons() const { return mouseState; }










protected:
    QPoint p, g;
    Qt::MouseButton b;
    Qt::MouseButtons mouseState;
};

class __declspec(dllimport) QHoverEvent : public QEvent
{
public:
    QHoverEvent(Type type, const QPoint &pos, const QPoint &oldPos);
    ~QHoverEvent();

    inline const QPoint &pos() const { return p; }
    inline const QPoint &oldPos() const { return op; }

protected:
    QPoint p, op;
};


class __declspec(dllimport) QWheelEvent : public QInputEvent
{
public:
    QWheelEvent(const QPoint &pos, int delta,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
                Qt::Orientation orient = Qt::Vertical);
    QWheelEvent(const QPoint &pos, const QPoint& globalPos, int delta,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
                Qt::Orientation orient = Qt::Vertical);
    ~QWheelEvent();

    inline int delta() const { return d; }
    inline const QPoint &pos() const { return p; }
    inline const QPoint &globalPos()   const { return g; }
    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return g.x(); }
    inline int globalY() const { return g.y(); }

    inline Qt::MouseButtons buttons() const { return mouseState; }
    Qt::Orientation orientation() const { return o; }









protected:
    QPoint p;
    QPoint g;
    int d;
    Qt::MouseButtons mouseState;
    Qt::Orientation o;
};


class __declspec(dllimport) QTabletEvent : public QInputEvent
{
public:
    enum TabletDevice { NoDevice, Puck, Stylus, Airbrush, FourDMouse,
                        XFreeEraser  };
    enum PointerType { UnknownPointer, Pen, Cursor, Eraser };
    QTabletEvent(Type t, const QPoint &pos, const QPoint &globalPos, const QPointF &hiResGlobalPos,
                 int device, int pointerType, qreal pressure, int xTilt, int yTilt,
                 qreal tangentialPressure, qreal rotation, int z,
                 Qt::KeyboardModifiers keyState, qint64 uniqueID);
    ~QTabletEvent();

    inline const QPoint &pos() const { return mPos; }
    inline const QPoint &globalPos() const { return mGPos; }
    inline const QPointF &hiResGlobalPos() const { return mHiResGlobalPos; }
    inline int x() const { return mPos.x(); }
    inline int y() const { return mPos.y(); }
    inline int globalX() const { return mGPos.x(); }
    inline int globalY() const { return mGPos.y(); }
    inline qreal hiResGlobalX() const { return mHiResGlobalPos.x(); }
    inline qreal hiResGlobalY() const { return mHiResGlobalPos.y(); }
    inline TabletDevice device() const { return TabletDevice(mDev); }
    inline PointerType pointerType() const { return PointerType(mPointerType); }
    inline qint64 uniqueId() const { return mUnique; }
    inline qreal pressure() const { return mPress; }
    inline int z() const { return mZ; }
    inline qreal tangentialPressure() const { return mTangential; }
    inline qreal rotation() const { return mRot; }
    inline int xTilt() const { return mXT; }
    inline int yTilt() const { return mYT; }

protected:
    QPoint mPos, mGPos;
    QPointF mHiResGlobalPos;
    int mDev, mPointerType, mXT, mYT, mZ;
    qreal mPress, mTangential, mRot;
    qint64 mUnique;




    void *mExtra;

};


class __declspec(dllimport) QKeyEvent : public QInputEvent
{
public:
    QKeyEvent(Type type, int key, Qt::KeyboardModifiers modifiers,
              const QString& text = QString(),
              bool autorep = false, ushort count = 1);
    ~QKeyEvent();

    int key() const { return k; }
    Qt::KeyboardModifiers modifiers() const;
    inline QString text() const { return txt; }
    inline bool isAutoRepeat() const { return autor; }
    inline int count() const { return int(c); }

















protected:
    QString txt;
    int k;
    ushort c;
    uint autor:1;
};


class __declspec(dllimport) QFocusEvent : public QEvent
{
public:
    QFocusEvent(Type type, Qt::FocusReason reason=Qt::OtherFocusReason);
    ~QFocusEvent();

    inline bool gotFocus() const { return type() == FocusIn; }
    inline bool lostFocus() const { return type() == FocusOut; }







    Qt::FocusReason reason();

private:
    Qt::FocusReason m_reason;
};


class __declspec(dllimport) QPaintEvent : public QEvent
{
public:
    QPaintEvent(const QRegion& paintRegion);
    QPaintEvent(const QRect &paintRect);
    ~QPaintEvent();

    inline const QRect &rect() const { return m_rect; }
    inline const QRegion &region() const { return m_region; }







protected:
    friend class QApplication;
    friend class QCoreApplication;
    QRect m_rect;
    QRegion m_region;
    bool m_erased;
};













class __declspec(dllimport) QMoveEvent : public QEvent
{
public:
    QMoveEvent(const QPoint &pos, const QPoint &oldPos);
    ~QMoveEvent();

    inline const QPoint &pos() const { return p; }
    inline const QPoint &oldPos() const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QCoreApplication;
};


class __declspec(dllimport) QResizeEvent : public QEvent
{
public:
    QResizeEvent(const QSize &size, const QSize &oldSize);
    ~QResizeEvent();

    inline const QSize &size() const { return s; }
    inline const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QCoreApplication;
};


class __declspec(dllimport) QCloseEvent : public QEvent
{
public:
    QCloseEvent();
    ~QCloseEvent();
};


class __declspec(dllimport) QIconDragEvent : public QEvent
{
public:
    QIconDragEvent();
    ~QIconDragEvent();
};


class __declspec(dllimport) QShowEvent : public QEvent
{
public:
    QShowEvent();
    ~QShowEvent();
};


class __declspec(dllimport) QHideEvent : public QEvent
{
public:
    QHideEvent();
    ~QHideEvent();
};


class __declspec(dllimport) QContextMenuEvent : public QInputEvent
{
public:
    enum Reason { Mouse, Keyboard, Other };

    QContextMenuEvent(Reason reason, const QPoint &pos, const QPoint &globalPos);
    QContextMenuEvent(Reason reason, const QPoint &pos);
    ~QContextMenuEvent();

    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return gp.x(); }
    inline int globalY() const { return gp.y(); }

    inline const QPoint& pos() const { return p; }
    inline const QPoint& globalPos() const { return gp; }

    inline Reason reason() const { return Reason(reas); }







protected:
    QPoint p;
    QPoint gp;
    uint reas : 8;
};

class __declspec(dllimport) QInputMethodEvent : public QEvent
{
public:
    enum AttributeType {
       TextFormat,
       Cursor,
       Language,
       Ruby
    };
    class Attribute {
    public:
        Attribute(AttributeType t, int s, int l, QVariant val) : type(t), start(s), length(l), value(val) {}
        AttributeType type;

        int start;
        int length;
        QVariant value;
    };
    QInputMethodEvent();
    QInputMethodEvent(const QString &preeditText, const QList<Attribute> &attributes);
    void setCommitString(const QString &commitString, int replaceFrom = 0, int replaceLength = 0);

    inline const QList<Attribute> &attributes() const { return attrs; }
    inline const QString &preeditString() const { return preedit; }

    inline const QString &commitString() const { return commit; }
    inline int replacementStart() const { return replace_from; }
    inline int replacementLength() const { return replace_length; }

    QInputMethodEvent(const QInputMethodEvent &other);

private:
    QString preedit;
    QList<Attribute> attrs;
    QString commit;
    int replace_from;
    int replace_length;
};



class QMimeData;

class __declspec(dllimport) QDropEvent : public QEvent

                              , public QMimeSource

{
public:
    QDropEvent(const QPoint& pos, Qt::DropActions actions, const QMimeData *data,
               Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = Drop);
    ~QDropEvent();

    inline const QPoint &pos() const { return p; }
    inline Qt::MouseButtons mouseButtons() const { return mouseState; }
    inline Qt::KeyboardModifiers keyboardModifiers() const { return modState; }

    inline Qt::DropActions possibleActions() const { return act; }
    inline Qt::DropAction proposedAction() const { return default_action; }
    inline void acceptProposedAction() { drop_action = default_action; accept(); }

    inline Qt::DropAction dropAction() const { return drop_action; }
    void setDropAction(Qt::DropAction action);

    QWidget* source() const;
    inline const QMimeData *mimeData() const { return mdata; }


    const char* format(int n = 0) const;
    QByteArray encodedData(const char*) const;
    bool provides(const char*) const;













protected:
    QPoint p;
    Qt::MouseButtons mouseState;
    Qt::KeyboardModifiers modState;
    Qt::DropActions act;
    Qt::DropAction drop_action;
    Qt::DropAction default_action;
    const QMimeData *mdata;
    mutable QList<QByteArray> fmts;
};


class __declspec(dllimport) QDragMoveEvent : public QDropEvent
{
public:
    QDragMoveEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
                   Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = DragMove);
    ~QDragMoveEvent();

    inline QRect answerRect() const { return rect; }

    inline void accept() { QDropEvent::accept(); }
    inline void ignore() { QDropEvent::ignore(); }

    inline void accept(const QRect & r) { accept(); rect = r; }
    inline void ignore(const QRect & r) { ignore(); rect = r; }





protected:
    QRect rect;
};


class __declspec(dllimport) QDragEnterEvent : public QDragMoveEvent
{
public:
    QDragEnterEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
                    Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
    ~QDragEnterEvent();
};



class __declspec(dllimport) QDragResponseEvent : public QEvent
{
public:
    QDragResponseEvent(bool accepted);
    ~QDragResponseEvent();

    inline bool dragAccepted() const { return a; }
protected:
    bool a;
};


class __declspec(dllimport) QDragLeaveEvent : public QEvent
{
public:
    QDragLeaveEvent();
    ~QDragLeaveEvent();
};



class __declspec(dllimport) QHelpEvent : public QEvent
{
public:
    QHelpEvent(Type type, const QPoint &pos, const QPoint &globalPos);
    ~QHelpEvent();

    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return gp.x(); }
    inline int globalY() const { return gp.y(); }

    inline const QPoint& pos()  const { return p; }
    inline const QPoint& globalPos() const { return gp; }

private:
    QPoint p;
    QPoint gp;
};


class __declspec(dllimport) QStatusTipEvent : public QEvent
{
public:
    QStatusTipEvent(const QString &tip);
    ~QStatusTipEvent();

    inline QString tip() const { return s; }
private:
    QString s;
};

class __declspec(dllimport) QWhatsThisClickedEvent : public QEvent
{
public:
    QWhatsThisClickedEvent(const QString &href);
    ~QWhatsThisClickedEvent();

    inline QString href() const { return s; }
private:
    QString s;
};


class __declspec(dllimport) QActionEvent : public QEvent
{
    QAction *act, *bef;
public:
    QActionEvent(int type, QAction *action, QAction *before = 0);
    ~QActionEvent();

    inline QAction *action() const { return act; }
    inline QAction *before() const { return bef; }
};


class __declspec(dllimport) QFileOpenEvent : public QEvent
{
public:
    QFileOpenEvent(const QString &file);
    ~QFileOpenEvent();

    inline QString file() const { return f; }
private:
    QString f;
};

class __declspec(dllimport) QToolBarChangeEvent : public QEvent
{
public:
    QToolBarChangeEvent(bool t);
    ~QToolBarChangeEvent();

    inline bool toggle() const { return tog; }
private:
    uint tog : 1;
};

class __declspec(dllimport) QShortcutEvent : public QEvent
{
public:
    QShortcutEvent(const QKeySequence &key, int id, bool ambiguous = false);
    ~QShortcutEvent();

    inline const QKeySequence &key() { return sequence; }
    inline int shortcutId() { return sid; }
    inline bool isAmbiguous() { return ambig; }
protected:
    QKeySequence sequence;
    bool ambig;
    int  sid;
};

class __declspec(dllimport) QClipboardEvent : public QEvent
{
public:
    QClipboardEvent(QEventPrivate *data);
    ~QClipboardEvent();

    QEventPrivate *data() { return d; };
};

class __declspec(dllimport) QWindowStateChangeEvent: public QEvent
{
public:
    QWindowStateChangeEvent(Qt::WindowStates aOldState);
    QWindowStateChangeEvent(Qt::WindowStates aOldState, bool isOverride);
    ~QWindowStateChangeEvent();

    inline Qt::WindowStates oldState() const { return ostate; }
    bool isOverride() const;

private:
    Qt::WindowStates ostate;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QEvent *);

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QAccessibleInterface;

class __declspec(dllimport) QAccessible
{
private:



public:
    enum Event {
        SoundPlayed          = 0x0001,
        Alert                = 0x0002,
        ForegroundChanged    = 0x0003,
        MenuStart            = 0x0004,
        MenuEnd              = 0x0005,
        PopupMenuStart       = 0x0006,
        PopupMenuEnd         = 0x0007,
        ContextHelpStart     = 0x000C,
        ContextHelpEnd       = 0x000D,
        DragDropStart        = 0x000E,
        DragDropEnd          = 0x000F,
        DialogStart          = 0x0010,
        DialogEnd            = 0x0011,
        ScrollingStart       = 0x0012,
        ScrollingEnd         = 0x0013,

        MenuCommand          = 0x0018,

        ObjectCreated        = 0x8000,
        ObjectDestroyed      = 0x8001,
        ObjectShow           = 0x8002,
        ObjectHide           = 0x8003,
        ObjectReorder        = 0x8004,
        Focus                = 0x8005,
        Selection            = 0x8006,
        SelectionAdd         = 0x8007,
        SelectionRemove      = 0x8008,
        SelectionWithin      = 0x8009,
        StateChanged         = 0x800A,
        LocationChanged      = 0x800B,
        NameChanged          = 0x800C,
        DescriptionChanged   = 0x800D,
        ValueChanged         = 0x800E,
        ParentChanged        = 0x800F,
        HelpChanged          = 0x80A0,
        DefaultActionChanged = 0x80B0,
        AcceleratorChanged   = 0x80C0
    };

    enum StateFlag {
        Normal          = 0x00000000,
        Unavailable     = 0x00000001,
        Selected        = 0x00000002,
        Focused         = 0x00000004,
        Pressed         = 0x00000008,
        Checked         = 0x00000010,
        Mixed           = 0x00000020,
        ReadOnly        = 0x00000040,
        HotTracked      = 0x00000080,
        DefaultButton   = 0x00000100,
        Expanded        = 0x00000200,
        Collapsed       = 0x00000400,
        Busy            = 0x00000800,

        Marqueed        = 0x00002000,
        Animated        = 0x00004000,
        Invisible       = 0x00008000,
        Offscreen       = 0x00010000,
        Sizeable        = 0x00020000,
        Movable         = 0x00040000,



        SelfVoicing     = 0x00080000,
        Focusable       = 0x00100000,
        Selectable      = 0x00200000,
        Linked          = 0x00400000,
        Traversed       = 0x00800000,
        MultiSelectable = 0x01000000,
        ExtSelectable   = 0x02000000,



        Protected       = 0x20000000,
        HasPopup        = 0x40000000,
        Modal           = 0x80000000
    };
    typedef QFlags<StateFlag> State;

    enum Role {
        NoRole         = 0x00000000,
        TitleBar       = 0x00000001,
        MenuBar        = 0x00000002,
        ScrollBar      = 0x00000003,
        Grip           = 0x00000004,
        Sound          = 0x00000005,
        Cursor         = 0x00000006,
        Caret          = 0x00000007,
        AlertMessage   = 0x00000008,
        Window         = 0x00000009,
        Client         = 0x0000000A,
        PopupMenu      = 0x0000000B,
        MenuItem       = 0x0000000C,
        ToolTip        = 0x0000000D,
        Application    = 0x0000000E,
        Document       = 0x0000000F,
        Pane           = 0x00000010,
        Chart          = 0x00000011,
        Dialog         = 0x00000012,
        Border         = 0x00000013,
        Grouping       = 0x00000014,
        Separator      = 0x00000015,
        ToolBar        = 0x00000016,
        StatusBar      = 0x00000017,
        Table          = 0x00000018,
        ColumnHeader   = 0x00000019,
        RowHeader      = 0x0000001A,
        Column         = 0x0000001B,
        Row            = 0x0000001C,
        Cell           = 0x0000001D,
        Link           = 0x0000001E,
        HelpBalloon    = 0x0000001F,
        Assistant      = 0x00000020,
        List           = 0x00000021,
        ListItem       = 0x00000022,
        Tree           = 0x00000023,
        TreeItem       = 0x00000024,
        PageTab        = 0x00000025,
        PropertyPage   = 0x00000026,
        Indicator      = 0x00000027,
        Graphic        = 0x00000028,
        StaticText     = 0x00000029,
        EditableText   = 0x0000002A,
        PushButton     = 0x0000002B,
        CheckBox       = 0x0000002C,
        RadioButton    = 0x0000002D,
        ComboBox       = 0x0000002E,

        ProgressBar    = 0x00000030,
        Dial           = 0x00000031,
        HotkeyField    = 0x00000032,
        Slider         = 0x00000033,
        SpinBox        = 0x00000034,
        Canvas         = 0x00000035,
        Animation      = 0x00000036,
        Equation       = 0x00000037,
        ButtonDropDown = 0x00000038,
        ButtonMenu     = 0x00000039,
        ButtonDropGrid = 0x0000003A,
        Whitespace     = 0x0000003B,
        PageTabList    = 0x0000003C,
        Clock          = 0x0000003D,
        Splitter       = 0x0000003E,
        LayeredPane    = 0x0000003F,
        UserRole       = 0x0000ffff
    };

    enum Text {
        Name         = 0,
        Description,
        Value,
        Help,
        Accelerator,
        UserText     = 0x0000ffff
    };

    enum RelationFlag {
        Unrelated     = 0x00000000,
        Self          = 0x00000001,
        Ancestor      = 0x00000002,
        Child         = 0x00000004,
        Descendent    = 0x00000008,
        Sibling       = 0x00000010,
        HierarchyMask = 0x000000ff,

        Up            = 0x00000100,
        Down          = 0x00000200,
        Left          = 0x00000400,
        Right         = 0x00000800,
        Covers        = 0x00001000,
        Covered       = 0x00002000,
        GeometryMask  = 0x0000ff00,

        FocusChild    = 0x00010000,
        Label         = 0x00020000,
        Labelled      = 0x00040000,
        Controller    = 0x00080000,
        Controlled    = 0x00100000,
        LogicalMask   = 0x00ff0000
    };
    typedef QFlags<RelationFlag> Relation;

    enum Action {
        DefaultAction       = 0,
        Press               = -1,
        FirstStandardAction = Press,
        SetFocus            = -2,
        Increase            = -3,
        Decrease            = -4,
        Accept              = -5,
        Cancel	            = -6,
        Select              = -7,
        ClearSelection      = -8,
        RemoveSelection     = -9,
        ExtendSelection     = -10,
        AddToSelection      = -11,
        LastStandardAction  = AddToSelection
    };

    typedef QAccessibleInterface*(*InterfaceFactory)(const QString &key, QObject*);
    typedef void(*UpdateHandler)(QObject*, int who, Event reason);
    typedef void(*RootObjectHandler)(QObject*);

    static void installFactory(InterfaceFactory);
    static void removeFactory(InterfaceFactory);
    static UpdateHandler installUpdateHandler(UpdateHandler);
    static RootObjectHandler installRootObjectHandler(RootObjectHandler);

    static QAccessibleInterface *queryAccessibleInterface(QObject *);
    static void updateAccessibility(QObject *, int who, Event reason);
    static bool isActive();
    static void setRootObject(QObject*);

    static void initialize();
    static void cleanup();

private:
    static UpdateHandler updateHandler;
    static RootObjectHandler rootObjectHandler;
};

inline QFlags<QAccessible::State::enum_type> operator|(QAccessible::State::enum_type f1, QAccessible::State::enum_type f2) { return QFlags<QAccessible::State::enum_type>(f1) | f2; } inline QFlags<QAccessible::State::enum_type> operator|(QAccessible::State::enum_type f1, QFlags<QAccessible::State::enum_type> f2) { return f2 | f1; }
inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QAccessible::Relation::enum_type f2) { return QFlags<QAccessible::Relation::enum_type>(f1) | f2; } inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QFlags<QAccessible::Relation::enum_type> f2) { return f2 | f1; }

class __declspec(dllimport) QAccessibleInterface : public QAccessible
{
public:
    virtual ~QAccessibleInterface() {}

    virtual bool isValid() const = 0;
    virtual QObject *object() const = 0;


    virtual int childCount() const = 0;
    virtual int indexOfChild(const QAccessibleInterface *) const = 0;


    virtual Relation relationTo(int child, const QAccessibleInterface *other,
                                int otherChild) const = 0;
    virtual int childAt(int x, int y) const = 0;


    virtual int navigate(RelationFlag relation, int index, QAccessibleInterface **iface) const = 0;


    virtual QString text(Text t, int child) const = 0;
    virtual void setText(Text t, int child, const QString &text) = 0;
    virtual QRect rect(int child) const = 0;
    virtual Role role(int child) const = 0;
    virtual State state(int child) const = 0;


    virtual int userActionCount(int child) const = 0;
    virtual QString actionText(int action, Text t, int child) const = 0;
    virtual bool doAction(int action, int child, const QVariantList &params = QVariantList()) = 0;
};


template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleInterface") : 0)); } template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleInterface") : 0)); }


class __declspec(dllimport) QAccessibleEvent : public QEvent
{
public:
    inline QAccessibleEvent(Type type, int child);
    inline int child() const { return c; }
    inline QString value() const { return val; }
    inline void setValue(const QString &aText) { val = aText; }

private:
    int c;
    QString val;
};

inline QAccessibleEvent::QAccessibleEvent(Type atype, int achild)
    : QEvent(atype), c(achild) {}

































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAccessibleInterface;

class QAccessibleBridge
{
public:
    virtual ~QAccessibleBridge() {}
    virtual void setRootObject(QAccessibleInterface *) = 0;
    virtual void notifyAccessibilityUpdate(int, QAccessibleInterface*, int) = 0;
};

struct __declspec(dllimport) QAccessibleBridgeFactoryInterface : public QFactoryInterface
{
    virtual QAccessibleBridge *create(const QString& name) = 0;
};


template <> inline QAccessibleBridgeFactoryInterface *qobject_cast<QAccessibleBridgeFactoryInterface *>(QObject *object) { return reinterpret_cast<QAccessibleBridgeFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleBridgeFactoryInterface") : 0)); } template <> inline QAccessibleBridgeFactoryInterface *qobject_cast<QAccessibleBridgeFactoryInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleBridgeFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleBridgeFactoryInterface") : 0)); }

class __declspec(dllimport) QAccessibleBridgePlugin : public QObject, public QAccessibleBridgeFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QAccessibleBridgePlugin(QObject *parent = 0);
    ~QAccessibleBridgePlugin();

    virtual QStringList keys() const = 0;
    virtual QAccessibleBridge *create(const QString &key) = 0;
};



























































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAccessibleObjectPrivate;
class QObject;

class __declspec(dllimport) QAccessibleObject : public QAccessibleInterface
{
public:
    explicit QAccessibleObject(QObject *object);

    bool isValid() const;
    QObject *object() const;


    QRect rect(int child) const;
    void setText(Text t, int child, const QString &text);


    int userActionCount(int child) const;
    bool doAction(int action, int child, const QVariantList &params);
    QString actionText(int action, Text t, int child) const;

protected:
    virtual ~QAccessibleObject();

private:
    QAccessibleObjectPrivate *d;
};

class __declspec(dllimport) QAccessibleApplication : public QAccessibleObject
{
public:
    QAccessibleApplication();


    int childCount() const;
    int indexOfChild(const QAccessibleInterface*) const;
    Relation relationTo(int, const QAccessibleInterface *, int) const;


    int childAt(int x, int y) const;
    int navigate(RelationFlag, int, QAccessibleInterface **) const;


    QString text(Text t, int child) const;
    Role role(int child) const;
    State state(int child) const;


    int userActionCount(int child) const;
    bool doAction(int action, int child, const QVariantList &params);
    QString actionText(int action, Text t, int child) const;
};





























































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QStringList;
class QAccessibleInterface;

struct __declspec(dllimport) QAccessibleFactoryInterface : public QAccessible, public QFactoryInterface
{
    virtual QAccessibleInterface* create(const QString &key, QObject *object) = 0;
};


template <> inline QAccessibleFactoryInterface *qobject_cast<QAccessibleFactoryInterface *>(QObject *object) { return reinterpret_cast<QAccessibleFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleFactoryInterface") : 0)); } template <> inline QAccessibleFactoryInterface *qobject_cast<QAccessibleFactoryInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleFactoryInterface") : 0)); }

class QAccessiblePluginPrivate;

class __declspec(dllimport) QAccessiblePlugin : public QObject, public QAccessibleFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QAccessiblePlugin(QObject *parent = 0);
    ~QAccessiblePlugin();

    virtual QStringList keys() const = 0;
    virtual QAccessibleInterface *create(const QString &key, QObject *object) = 0;
};










































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAccessibleWidgetPrivate;

class __declspec(dllimport) QAccessibleWidget : public QAccessibleObject
{
public:
    explicit QAccessibleWidget(QWidget *o, Role r = Client, const QString& name = QString());

    int childCount() const;
    int indexOfChild(const QAccessibleInterface *child) const;
    Relation relationTo(int child, const QAccessibleInterface *other, int otherChild) const;

    int childAt(int x, int y) const;
    QRect rect(int child) const;
    int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;

    QString text(Text t, int child) const;
    Role role(int child) const;
    State state(int child) const;

    QString actionText(int action, Text t, int child) const;
    bool doAction(int action, int child, const QVariantList &params);

protected:
    ~QAccessibleWidget();
    QWidget *widget() const;
    QObject *parentObject() const;

    void addControllingSignal(const QString &signal);
    void setValue(const QString &value);
    void setDescription(const QString &desc);
    void setHelp(const QString &help);
    void setAccelerator(const QString &accel);

private:
    QAccessibleWidgetPrivate *d;
};










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;





class QPaintEngine;

class __declspec(dllimport) QPaintDevice
{
public:
    enum PaintDeviceMetric {
        PdmWidth = 1,
        PdmHeight,
        PdmWidthMM,
        PdmHeightMM,
        PdmNumColors,
        PdmDepth,
        PdmDpiX,
        PdmDpiY,
        PdmPhysicalDpiX,
        PdmPhysicalDpiY
    };

    virtual ~QPaintDevice();

    virtual int devType() const;
    bool paintingActive() const;
    virtual QPaintEngine *paintEngine() const = 0;








    virtual HDC getDC() const;
    virtual void releaseDC(HDC hdc) const;


    int width() const { return metric(PdmWidth); }
    int height() const { return metric(PdmHeight); }
    int widthMM() const { return metric(PdmWidthMM); }
    int heightMM() const { return metric(PdmHeightMM); }
    int logicalDpiX() const { return metric(PdmDpiX); }
    int logicalDpiY() const { return metric(PdmDpiY); }
    int physicalDpiX() const { return metric(PdmPhysicalDpiX); }
    int physicalDpiY() const { return metric(PdmPhysicalDpiY); }
    int numColors() const { return metric(PdmNumColors); }
    int depth() const { return metric(PdmDepth); }

protected:
    QPaintDevice();
    virtual int metric(PaintDeviceMetric metric) const;

    ushort        painters;

private:
    QPaintDevice(const QPaintDevice &); QPaintDevice &operator=(const QPaintDevice &);



























    friend class QPainter;
    friend class QQuickDrawPaintEngine;
    friend class QFontEngineMac;
};






















inline int QPaintDevice::devType() const
{ return QInternal::UnknownDevice; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

typedef unsigned int QRgb;

const QRgb  RGB_MASK    = 0x00ffffff;

__declspec(dllimport) inline int qRed(QRgb rgb)
{ return ((rgb >> 16) & 0xff); }

__declspec(dllimport) inline int qGreen(QRgb rgb)
{ return ((rgb >> 8) & 0xff); }

__declspec(dllimport) inline int qBlue(QRgb rgb)
{ return (rgb & 0xff); }

__declspec(dllimport) inline int qAlpha(QRgb rgb)
{ return ((rgb >> 24) & 0xff); }

__declspec(dllimport) inline QRgb qRgb(int r, int g, int b)
{ return (0xff << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline QRgb qRgba(int r, int g, int b, int a)
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline int qGray(int r, int g, int b)
{ return (r*11+g*16+b*5)/32; }

__declspec(dllimport) inline int qGray(QRgb rgb)
{ return qGray(qRed(rgb), qGreen(rgb), qBlue(rgb)); }

__declspec(dllimport) inline bool qIsGray(QRgb rgb)
{ return qRed(rgb) == qGreen(rgb) && qRed(rgb) == qBlue(rgb); }





typedef QtValidLicenseForGuiModule QtGuiModule;

class QColor;
class QColormap;
class QVariant;


__declspec(dllimport) QDebug operator<<(QDebug, const QColor &);


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QColor &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QColor &);


class __declspec(dllimport) QColor
{
public:
    enum Spec { Invalid, Rgb, Hsv, Cmyk };

    QColor();
    QColor(Qt::GlobalColor color);
    QColor(int r, int g, int b, int a = 255);
    QColor(QRgb rgb);
    QColor(const QString& name);
    QColor(const char *name);
    QColor(const QColor &color);

    bool isValid() const;

    QString name() const;
    void setNamedColor(const QString& name);

    static QStringList colorNames();

    inline Spec spec() const
    { return cspec; }

    int alpha() const;
    void setAlpha(int alpha);

    qreal alphaF() const;
    void setAlphaF(qreal alpha);

    int red() const;
    int green() const;
    int blue() const;
    void setRed(int red);
    void setGreen(int green);
    void setBlue(int blue);

    qreal redF() const;
    qreal greenF() const;
    qreal blueF() const;
    void setRedF(qreal red);
    void setGreenF(qreal green);
    void setBlueF(qreal blue);

    void getRgb(int *r, int *g, int *b, int *a = 0) const;
    void setRgb(int r, int g, int b, int a = 255);

    void getRgbF(qreal *r, qreal *g, qreal *b, qreal *a = 0) const;
    void setRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

    QRgb rgba() const;
    void setRgba(QRgb rgba);

    QRgb rgb() const;
    void setRgb(QRgb rgb);

    int hue() const;
    int saturation() const;
    int value() const;

    qreal hueF() const;
    qreal saturationF() const;
    qreal valueF() const;

    void getHsv(int *h, int *s, int *v, int *a = 0) const;
    void setHsv(int h, int s, int v, int a = 255);

    void getHsvF(qreal *h, qreal *s, qreal *v, qreal *a = 0) const;
    void setHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

    int cyan() const;
    int magenta() const;
    int yellow() const;
    int black() const;

    qreal cyanF() const;
    qreal magentaF() const;
    qreal yellowF() const;
    qreal blackF() const;

    void getCmyk(int *c, int *m, int *y, int *k, int *a = 0);
    void setCmyk(int c, int m, int y, int k, int a = 255);

    void getCmykF(qreal *c, qreal *m, qreal *y, qreal *k, qreal *a = 0);
    void setCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

    QColor toRgb() const;
    QColor toHsv() const;
    QColor toCmyk() const;

    QColor convertTo(Spec colorSpec) const;

    static QColor fromRgb(QRgb rgb);
    static QColor fromRgba(QRgb rgba);

    static QColor fromRgb(int r, int g, int b, int a = 255);
    static QColor fromRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

    static QColor fromHsv(int h, int s, int v, int a = 255);
    static QColor fromHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

    static QColor fromCmyk(int c, int m, int y, int k, int a = 255);
    static QColor fromCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

    QColor light(int f = 150) const;
    QColor dark(int f = 200) const;

    QColor &operator=(const QColor &);
    QColor &operator=(Qt::GlobalColor color);

    bool operator==(const QColor &c) const;
    bool operator!=(const QColor &c) const;

    operator QVariant() const;


















private:


    QColor(int, int, int, Spec);


    void invalidate();

    Spec cspec;
    union {
        struct {
            ushort alpha;
            ushort red;
            ushort green;
            ushort blue;
            ushort pad;
        } argb;
        struct {
            ushort alpha;
            ushort hue;
            ushort saturation;
            ushort value;
            ushort pad;
        } ahsv;
        struct {
            ushort alpha;
            ushort cyan;
            ushort magenta;
            ushort yellow;
            ushort black;
        } acmyk;
    } ct;

    friend class QColormap;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QColor &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QColor &);

};

inline QColor::QColor()
{ invalidate(); }

inline QColor::QColor(int r, int g, int b, int a)
{ setRgb(r, g, b, a); }

inline QColor::QColor(const char *aname)
{ setNamedColor(QLatin1String(aname)); }

inline QColor::QColor(const QString& aname)
{ setNamedColor(aname); }

inline QColor::QColor(const QColor &acolor)
    : cspec(acolor.cspec)
{ ct.argb = acolor.ct.argb; }

inline bool QColor::isValid() const
{ return cspec != Invalid; }















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

struct QBrushData;
class QPixmap;
class QGradient;
class QVariant;

class __declspec(dllimport) QBrush
{
public:
    QBrush();
    QBrush(Qt::BrushStyle bs);
    QBrush(const QColor &color, Qt::BrushStyle bs=Qt::SolidPattern);
    QBrush(Qt::GlobalColor color, Qt::BrushStyle bs=Qt::SolidPattern);

    QBrush(const QColor &color, const QPixmap &pixmap);
    QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
    QBrush(const QPixmap &pixmap);

    QBrush(const QBrush &brush);

    QBrush(const QGradient &gradient);

    ~QBrush();
    QBrush &operator=(const QBrush &brush);
    operator QVariant() const;

    inline Qt::BrushStyle style() const;
    void setStyle(Qt::BrushStyle);

    QPixmap texture() const;
    void setTexture(const QPixmap &pixmap);

    inline const QColor &color() const;
    void setColor(const QColor &color);
    inline void setColor(Qt::GlobalColor color);

    const QGradient *gradient() const;

    bool isOpaque() const;

    bool operator==(const QBrush &b) const;
    inline bool operator!=(const QBrush &b) const { return !(operator==(b)); }







private:



    friend class QPainter;
    void detach(Qt::BrushStyle newStyle);
    void init(const QColor &color, Qt::BrushStyle bs);
    QBrushData *d;
    void cleanUp(QBrushData *x);
};

inline void QBrush::setColor(Qt::GlobalColor acolor)
{ setColor(QColor(acolor)); }

template <> class QTypeInfo<QBrush> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBrush)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBrush"; } };






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBrush &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QBrush &);



__declspec(dllimport) QDebug operator<<(QDebug, const QBrush &);


struct QBrushData
{
    QAtomic ref;
    Qt::BrushStyle style;
    QColor color;
};

inline Qt::BrushStyle QBrush::style() const { return d->style; }
inline const QColor &QBrush::color() const { return d->color; }









class QGradientPrivate;

typedef QPair<qreal, QColor> QGradientStop;
typedef QVector<QGradientStop> QGradientStops;

class __declspec(dllimport) QGradient
{
public:
    enum Type {
        LinearGradient,
        RadialGradient,
        ConicalGradient
    };

    enum Spread {
        PadSpread,
        ReflectSpread,
        RepeatSpread
    };

    QGradient();

    Type type() const { return m_type; }

    inline void setSpread(Spread spread);
    Spread spread() const { return m_spread; }

    void setColorAt(qreal pos, const QColor &color);

    void setStops(const QGradientStops &stops);
    QGradientStops stops() const;

    bool operator==(const QGradient &gradient);

private:
    friend class QLinearGradient;
    friend class QRadialGradient;
    friend class QConicalGradient;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBrush &);

    Type m_type;
    Spread m_spread;
    QGradientStops m_stops;
    union {
        struct {
            qreal x1, y1, x2, y2;
        } linear;
        struct {
            qreal cx, cy, fx, fy, radius;
        } radial;
        struct {
            qreal cx, cy, angle;
        } conical;
    } m_data;
    void *dummy;
};

inline void QGradient::setSpread(Spread aspread)
{ m_spread = aspread; }

class __declspec(dllimport) QLinearGradient : public QGradient
{
public:
    QLinearGradient(const QPointF &start, const QPointF &finalStop);
    QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);

    QPointF start() const;
    QPointF finalStop() const;
};


class __declspec(dllimport) QRadialGradient : public QGradient
{
public:
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint = QPointF());
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx=0, qreal fy=0);

    QPointF center() const;
    QPointF focalPoint() const;
    qreal radius() const;
};


class __declspec(dllimport) QConicalGradient : public QGradient
{
public:
    QConicalGradient(const QPointF &center, qreal startAngle);
    QConicalGradient(qreal cx, qreal cy, qreal startAngle);

    QPointF center() const;
    qreal angle() const;
};





typedef QtValidLicenseForGuiModule QtGuiModule;





class QPalettePrivate;
class QVariant;

class __declspec(dllimport) QPalette
{
    public: static const QMetaObject staticMetaObject; private:

public:
    QPalette();
    QPalette(const QColor &button);
    QPalette(Qt::GlobalColor button);
    QPalette(const QColor &button, const QColor &background);
    QPalette(const QBrush &foreground, const QBrush &button, const QBrush &light,
             const QBrush &dark, const QBrush &mid, const QBrush &text,
             const QBrush &bright_text, const QBrush &base, const QBrush &background);
    QPalette(const QColor &foreground, const QColor &background, const QColor &light,
             const QColor &dark, const QColor &mid, const QColor &text, const QColor &base);



    QPalette(const QPalette &palette);
    ~QPalette();
    QPalette &operator=(const QPalette &palette);
    operator QVariant() const;


    enum ColorGroup { Active, Disabled, Inactive, NColorGroups, Current, All, Normal = Active };
    enum ColorRole { Foreground, Button, Light, Midlight, Dark, Mid,
                     Text, BrightText, ButtonText, Base, Background, Shadow,
                     Highlight, HighlightedText, Link, LinkVisited, AlternateBase,
                     NColorRoles, NoRole = NColorRoles };

    inline ColorGroup currentColorGroup() const { return static_cast<ColorGroup>(current_group); }
    inline void setCurrentColorGroup(ColorGroup cg) { current_group = cg; }

    inline const QColor &color(ColorGroup cg, ColorRole cr) const
    { return brush(cg, cr).color(); }
    const QBrush &brush(ColorGroup cg, ColorRole cr) const;
    inline void setColor(ColorGroup cg, ColorRole cr, const QColor &color);
    inline void setColor(ColorRole cr, const QColor &color);
    inline void setBrush(ColorRole cr, const QBrush &brush);
    void setBrush(ColorGroup cg, ColorRole cr, const QBrush &brush);
    void setColorGroup(ColorGroup cr, const QBrush &foreground, const QBrush &button,
                       const QBrush &light, const QBrush &dark, const QBrush &mid,
                       const QBrush &text, const QBrush &bright_text, const QBrush &base,
                       const QBrush &background);
    bool isEqual(ColorGroup cr1, ColorGroup cr2) const;

    inline const QColor &color(ColorRole cr) const { return color(Current, cr); }
    inline const QBrush &brush(ColorRole cr) const { return brush(Current, cr); }
    inline const QBrush &foreground() const { return brush(Foreground); }
    inline const QBrush &button() const { return brush(Button); }
    inline const QBrush &light() const { return brush(Light); }
    inline const QBrush &dark() const { return brush(Dark); }
    inline const QBrush &mid() const { return brush(Mid); }
    inline const QBrush &text() const { return brush(Text); }
    inline const QBrush &base() const { return brush(Base); }
    inline const QBrush &alternateBase() const { return brush(AlternateBase); }
    inline const QBrush &background() const { return brush(Background); }
    inline const QBrush &midlight() const { return brush(Midlight); }
    inline const QBrush &brightText() const { return brush(BrightText); }
    inline const QBrush &buttonText() const { return brush(ButtonText); }
    inline const QBrush &shadow() const { return brush(Shadow); }
    inline const QBrush &highlight() const { return brush(Highlight); }
    inline const QBrush &highlightedText() const { return brush(HighlightedText); }
    inline const QBrush &link() const { return brush(Link); }
    inline const QBrush &linkVisited() const { return brush(LinkVisited); }














    bool operator==(const QPalette &p) const;
    inline bool operator!=(const QPalette &p) const { return !(operator==(p)); }
    bool isCopyOf(const QPalette &p) const;

    int serialNumber() const;

    QPalette resolve(const QPalette &) const;
    inline uint resolve() const { return resolve_mask; }
    inline void resolve(uint mask) { resolve_mask = mask; }

private:
    void setColorGroup(ColorGroup cr, const QBrush &foreground, const QBrush &button,
                       const QBrush &light, const QBrush &dark, const QBrush &mid,
                       const QBrush &text, const QBrush &bright_text,
                       const QBrush &base, const QBrush &alternate_base,
                       const QBrush &background, const QBrush &midlight,
                       const QBrush &button_text, const QBrush &shadow,
                       const QBrush &highlight, const QBrush &highlighted_text,
                       const QBrush &link, const QBrush &link_visited);





    void init();
    void detach();

    QPalettePrivate *d;
    uint current_group : 4;
    uint resolve_mask : 28;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &s, const QPalette &p);
};

inline void QPalette::setColor(ColorGroup acg, ColorRole acr,
                               const QColor &acolor)
{ setBrush(acg, acr, QBrush(acolor)); }
inline void QPalette::setColor(ColorRole acr, const QColor &acolor)
{ setColor(All, acr, acolor); }
inline void QPalette::setBrush(ColorRole acr, const QBrush &abrush)
{ setBrush(All, acr, abrush); }






















































__declspec(dllimport) QDataStream &operator<<(QDataStream &ds, const QPalette &p);
__declspec(dllimport) QDataStream &operator>>(QDataStream &ds, QPalette &p);












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QFontPrivate;
class QStringList;
class QVariant;
class Q3TextFormatCollection;

class __declspec(dllimport) QFont
{
public:
    enum StyleHint {
        Helvetica,  SansSerif = Helvetica,
        Times,      Serif = Times,
        Courier,    TypeWriter = Courier,
        OldEnglish, Decorative = OldEnglish,
        System,
        AnyStyle
    };

    enum StyleStrategy {
        PreferDefault    = 0x0001,
        PreferBitmap     = 0x0002,
        PreferDevice     = 0x0004,
        PreferOutline    = 0x0008,
        ForceOutline     = 0x0010,
        PreferMatch      = 0x0020,
        PreferQuality    = 0x0040,
        PreferAntialias  = 0x0080,
        NoAntialias      = 0x0100,
        OpenGLCompatible = 0x0200
    };

    enum Weight {
        Light    = 25,
        Normal   = 50,
        DemiBold = 63,
        Bold     = 75,
        Black    = 87
    };

    enum Style {
        StyleNormal,
        StyleItalic,
        StyleOblique
    };

    enum Stretch {
        UltraCondensed =  50,
        ExtraCondensed =  62,
        Condensed      =  75,
        SemiCondensed  =  87,
        Unstretched    = 100,
        SemiExpanded   = 112,
        Expanded       = 125,
        ExtraExpanded  = 150,
        UltraExpanded  = 200
    };

    QFont();
    QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false);
    QFont(const QFont &, QPaintDevice *pd);
    QFont(const QFont &);
    ~QFont();

    QString family() const;
    void setFamily(const QString &);

    int pointSize() const;
    void setPointSize(int);
    qreal pointSizeF() const;
    void setPointSizeF(qreal);

    int pixelSize() const;
    void setPixelSize(int);

    int weight() const;
    void setWeight(int);

    inline bool bold() const;
    inline void setBold(bool);

    void setStyle(Style style);
    Style style() const;

    inline bool italic() const;
    inline void setItalic(bool b);

    bool underline() const;
    void setUnderline(bool);

    bool overline() const;
    void setOverline(bool);

    bool strikeOut() const;
    void setStrikeOut(bool);

    bool fixedPitch() const;
    void setFixedPitch(bool);

    bool kerning() const;
    void setKerning(bool);

    StyleHint styleHint() const;
    StyleStrategy styleStrategy() const;
    void setStyleHint(StyleHint, StyleStrategy = PreferDefault);
    void setStyleStrategy(StyleStrategy s);

    int stretch() const;
    void setStretch(int);


    bool rawMode() const;
    void setRawMode(bool);


    bool exactMatch() const;

    QFont &operator=(const QFont &);
    bool operator==(const QFont &) const;
    bool operator!=(const QFont &) const;
    bool operator<(const QFont &) const;
    operator QVariant() const;
    bool isCopyOf(const QFont &) const;



    HFONT handle() const;






    void setRawName(const QString &);
    QString rawName() const;

    QString key() const;

    QString toString() const;
    bool fromString(const QString &);

    static QString substitute(const QString &);
    static QStringList substitutes(const QString &);
    static QStringList substitutions();
    static void insertSubstitution(const QString&, const QString &);
    static void insertSubstitutions(const QString&, const QStringList &);
    static void removeSubstitution(const QString &);
    static void initialize();
    static void cleanup();

    static void cacheStatistics();


    QString defaultFamily() const;
    QString lastResortFamily() const;
    QString lastResortFont() const;

    QFont resolve(const QFont &) const;
    inline uint resolve() const { return resolve_mask; }
    inline void resolve(uint mask) { resolve_mask = mask; }









private:
    QFont(QFontPrivate *);

    void detach();









    friend class QFontMetrics;
    friend class QFontMetricsF;
    friend class QFontInfo;
    friend class QPainter;
    friend class QPSPrintEngineFont;
    friend class QApplication;
    friend class QWidget;
    friend class QWidgetPrivate;
    friend class Q3TextFormatCollection;
    friend class QTextLayout;
    friend class QTextEngine;
    friend class QTextLine;
    friend struct QScriptLine;
    friend class QGLContext;
    friend class QWin32PaintEngine;
    friend class QPainterPath;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QFont &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QFont &);


    QFontPrivate *d;
    uint resolve_mask;
};


inline bool QFont::bold() const
{ return weight() > Normal; }


inline void QFont::setBold(bool enable)
{ setWeight(enable ? Bold : Normal); }

inline bool QFont::italic() const
{
    return (style() != StyleNormal);
}

inline void QFont::setItalic(bool b) {
    setStyle(b ? StyleItalic : StyleNormal);
}







__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QFont &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QFont &);



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;





class QTextCodec;
class QRect;


class __declspec(dllimport) QFontMetrics
{
public:
    QFontMetrics(const QFont &);
    QFontMetrics(const QFont &, QPaintDevice *pd);
    QFontMetrics(const QFontMetrics &);
    ~QFontMetrics();

    QFontMetrics &operator=(const QFontMetrics &);

    int ascent() const;
    int descent() const;
    int height() const;
    int leading() const;
    int lineSpacing() const;
    int minLeftBearing() const;
    int minRightBearing() const;
    int maxWidth() const;

    bool inFont(QChar) const;

    int leftBearing(QChar) const;
    int rightBearing(QChar) const;
    int width(const QString &, int len = -1) const;

    int width(QChar) const;
    int charWidth(const QString &str, int pos) const;

    QRect boundingRect(QChar) const;

    QRect boundingRect(const QString &text) const;
    QRect boundingRect(const QRect &r, int flags, const QString &text, int tabstops=0, int *tabarray=0) const;
    inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text,
                              int tabstops=0, int *tabarray=0) const
        { return boundingRect(QRect(x, y, w, h), flags, text, tabstops, tabarray); }
    QSize size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

    int underlinePos() const;
    int overlinePos() const;
    int strikeOutPos() const;
    int lineWidth() const;

    bool operator==(const QFontMetrics &other);
    inline bool operator !=(const QFontMetrics &other) { return !operator==(other); }










private:




    QFontPrivate *d;
};


class __declspec(dllimport) QFontMetricsF
{
public:
    QFontMetricsF(const QFont &);
    QFontMetricsF(const QFont &, QPaintDevice *pd);
    QFontMetricsF(const QFontMetrics &);
    QFontMetricsF(const QFontMetricsF &);
    ~QFontMetricsF();

    QFontMetricsF &operator=(const QFontMetricsF &);
    QFontMetricsF &operator=(const QFontMetrics &);

    qreal ascent() const;
    qreal descent() const;
    qreal height() const;
    qreal leading() const;
    qreal lineSpacing() const;
    qreal minLeftBearing() const;
    qreal minRightBearing() const;
    qreal maxWidth() const;

    bool inFont(QChar) const;

    qreal leftBearing(QChar) const;
    qreal rightBearing(QChar) const;
    qreal width(const QString &string) const;

    qreal width(QChar) const;

    QRectF boundingRect(const QString &string) const;
    QRectF boundingRect(QChar) const;
    QRectF boundingRect(const QRectF &r, int flags, const QString& string, int tabstops=0, int *tabarray=0) const;
    QSizeF size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

    qreal underlinePos() const;
    qreal overlinePos() const;
    qreal strikeOutPos() const;
    qreal lineWidth() const;

    bool operator==(const QFontMetricsF &other);
    inline bool operator !=(const QFontMetricsF &other) { return !operator==(other); }

private:
    QFontPrivate *d;
};



























































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QFontInfo
{
public:
    QFontInfo(const QFont &);
    QFontInfo(const QFontInfo &);
    ~QFontInfo();

    QFontInfo &operator=(const QFontInfo &);

    QString family() const;
    int pixelSize() const;
    int pointSize() const;
    qreal pointSizeF() const;
    bool italic() const;
    QFont::Style style() const;
    int weight() const;
    inline bool bold() const { return weight() > QFont::Normal; }
    bool underline() const;
    bool overline() const;
    bool strikeOut() const;
    bool fixedPitch() const;
    QFont::StyleHint styleHint() const;
    bool rawMode() const;

    bool exactMatch() const;

private:
    QFontPrivate *d;
};































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;

class __declspec(dllimport) QSizePolicy
{
    public: static const QMetaObject staticMetaObject; private:

private:
    enum SizePolicyMasks {
        HSize = 4,
        HMask = 0x0f,
        VMask = HMask << HSize
    };
public:
    enum PolicyFlag {
        GrowFlag = 1,
        ExpandFlag = 2,
        ShrinkFlag = 4,
        IgnoreFlag = 8
    };

    enum Policy {
        Fixed = 0,
        Minimum = GrowFlag,
        Maximum = ShrinkFlag,
        Preferred = GrowFlag | ShrinkFlag,
        MinimumExpanding = GrowFlag | ExpandFlag,
        Expanding = GrowFlag | ShrinkFlag | ExpandFlag,
        Ignored = ShrinkFlag|GrowFlag|IgnoreFlag
    };

    QSizePolicy() : data(0) { }

    QSizePolicy(Policy horizontal, Policy vertical)
        : data(horizontal | (vertical<<HSize)) { }

    Policy horizontalPolicy() const { return static_cast<Policy>(data & HMask); }
    Policy verticalPolicy() const { return static_cast<Policy>((data & VMask) >> HSize); }

    void setHorizontalPolicy(Policy d) { data = (data & ~HMask) | d; }
    void setVerticalPolicy(Policy d) { data = (data & ~(HMask << HSize)) | (d << HSize); }

    Qt::Orientations expandingDirections() const {
        Qt::Orientations result;
        if (verticalPolicy() & ExpandFlag)
            result |= Qt::Vertical;
        if (horizontalPolicy() & ExpandFlag)
            result |= Qt::Horizontal;
        return result;
    }

    void setHeightForWidth(bool b) { data = b ? (data | (1 << 2*HSize)) : (data & ~(1 << 2*HSize));  }
    bool hasHeightForWidth() const { return data & (1 << 2*HSize); }

    bool operator==(const QSizePolicy& s) const { return data == s.data; }
    bool operator!=(const QSizePolicy& s) const { return data != s.data; }
    operator QVariant() const;

    int horizontalStretch() const { return data >> 24; }
    int verticalStretch() const { return (data >> 16) & 0xff; }
    void setHorizontalStretch(uchar stretchFactor) { data = (data&0x00ffffff) | (uint(stretchFactor)<<24); }
    void setVerticalStretch(uchar stretchFactor) { data = (data&0xff00ffff) | (uint(stretchFactor)<<16); }

    void transpose();















































private:
    QSizePolicy(int i) : data(i) { }

    quint32 data;
};

inline void QSizePolicy::transpose() {
    Policy hData = horizontalPolicy();
    Policy vData = verticalPolicy();
    uchar hStretch = horizontalStretch();
    uchar vStretch = verticalStretch();
    setHorizontalPolicy(vData);
    setVerticalPolicy(hData);
    setHorizontalStretch(vStretch);
    setVerticalStretch(hStretch);
}



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;




















struct QCursorData;
class QBitmap;
class QPixmap;





class __declspec(dllimport) QCursor
{
public:
    QCursor();
    QCursor(Qt::CursorShape shape);
    QCursor(const QBitmap &bitmap, const QBitmap &mask, int hotX=-1, int hotY=-1);
    QCursor(const QPixmap &pixmap, int hotX=-1, int hotY=-1);
    QCursor(const QCursor &cursor);
    ~QCursor();
    QCursor &operator=(const QCursor &cursor);
    operator QVariant() const;

    Qt::CursorShape shape() const;
    void setShape(Qt::CursorShape newShape);

    const QBitmap *bitmap() const;
    const QBitmap *mask() const;
    QPixmap pixmap() const;
    QPoint hotSpot() const;

    static QPoint pos();
    static void setPos(int x, int y);
    inline static void setPos(const QPoint &p) { setPos(p.x(), p.y()); }






    HCURSOR handle() const;
    QCursor(HCURSOR cursor);









private:
    QCursorData *d;



};

















__declspec(dllimport) QDataStream &operator<<(QDataStream &outS, const QCursor &cursor);
__declspec(dllimport) QDataStream &operator>>(QDataStream &inS, QCursor &cursor);




























































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QLayout;
class QWSRegionManager;
class QStyle;
class QAction;
class QVariant;

class QActionEvent;
class QMouseEvent;
class QWheelEvent;
class QHoverEvent;
class QKeyEvent;
class QFocusEvent;
class QPaintEvent;
class QMoveEvent;
class QResizeEvent;
class QCloseEvent;
class QContextMenuEvent;
class QInputMethodEvent;
class QTabletEvent;
class QDragEnterEvent;
class QDragMoveEvent;
class QDragLeaveEvent;
class QDropEvent;
class QShowEvent;
class QHideEvent;
class QInputContext;
class QIcon;




class QWidgetData
{
public:
    WId winid;
    uint widget_attributes;
    Qt::WindowFlags window_flags;
    uint window_state : 4;
    uint focus_policy : 4;
    uint sizehint_forced :1;
    uint is_closing :1;
    uint in_show : 1;
    uint in_set_window_state : 1;
    mutable uint fstrut_dirty : 1;
    uint context_menu_policy : 3;
    uint unused : 16;
    QRect crect;
    mutable QPalette pal;
    QFont fnt;











    QRect wrect;
};

class QWidgetPrivate;

class __declspec(dllimport) QWidget : public QObject, public QPaintDevice
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QWidgetPrivate* d_func() { return reinterpret_cast<QWidgetPrivate *>(d_ptr); } inline const QWidgetPrivate* d_func() const { return reinterpret_cast<const QWidgetPrivate *>(d_ptr); } friend class QWidgetPrivate;





























































public:
    explicit QWidget(QWidget* parent = 0, Qt::WFlags f = 0);



    ~QWidget();

    int devType() const;

    WId winId() const;

    QStyle *style() const;
    void setStyle(QStyle *);


    bool isTopLevel() const;
    bool isWindow() const;

    bool isModal() const;

    bool isEnabled() const;
    bool isEnabledTo(QWidget*) const;
    bool isEnabledToTLW() const;

public :
    void setEnabled(bool);
    void setDisabled(bool);
    void setWindowModified(bool);



public:
    QRect frameGeometry() const;
    const QRect &geometry() const;
    QRect normalGeometry() const;

    int x() const;
    int y() const;
    QPoint pos() const;
    QSize frameSize() const;
    QSize size() const;
    inline int width() const;
    inline int height() const;
    inline QRect rect() const;
    QRect childrenRect() const;
    QRegion childrenRegion() const;

    QSize minimumSize() const;
    QSize maximumSize() const;
    int minimumWidth() const;
    int minimumHeight() const;
    int maximumWidth() const;
    int maximumHeight() const;
    void setMinimumSize(const QSize &);
    void setMinimumSize(int minw, int minh);
    void setMaximumSize(const QSize &);
    void setMaximumSize(int maxw, int maxh);
    void setMinimumWidth(int minw);
    void setMinimumHeight(int minh);
    void setMaximumWidth(int maxw);
    void setMaximumHeight(int maxh);

    QSize sizeIncrement() const;
    void setSizeIncrement(const QSize &);
    void setSizeIncrement(int w, int h);
    QSize baseSize() const;
    void setBaseSize(const QSize &);
    void setBaseSize(int basew, int baseh);

    void setFixedSize(const QSize &);
    void setFixedSize(int w, int h);
    void setFixedWidth(int w);
    void setFixedHeight(int h);



    QPoint mapToGlobal(const QPoint &) const;
    QPoint mapFromGlobal(const QPoint &) const;
    QPoint mapToParent(const QPoint &) const;
    QPoint mapFromParent(const QPoint &) const;
    QPoint mapTo(QWidget *, const QPoint &) const;
    QPoint mapFrom(QWidget *, const QPoint &) const;

    QWidget *window() const;
    inline QWidget *topLevelWidget() const { return window(); }


    const QPalette &palette() const;
    void setPalette(const QPalette &);

    void setBackgroundRole(QPalette::ColorRole);
    QPalette::ColorRole backgroundRole() const;

    void setForegroundRole(QPalette::ColorRole);
    QPalette::ColorRole foregroundRole() const;

    const QFont &font() const;
    void setFont(const QFont &);
    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;


    QCursor cursor() const;
    void setCursor(const QCursor &);
    void unsetCursor();


    void setMouseTracking(bool enable);
    bool hasMouseTracking() const;
    bool underMouse() const;

    void setMask(const QBitmap &);
    void setMask(const QRegion &);
    QRegion mask() const;
    void clearMask();

    void setWindowTitle(const QString &);
    QString windowTitle() const;
    void setWindowIcon(const QIcon &icon);
    QIcon windowIcon() const;
    void setWindowIconText(const QString &);
    QString windowIconText() const;
    void setWindowRole(const QString &);
    QString windowRole() const;

    void setWindowOpacity(qreal level);
    qreal windowOpacity() const;

    bool isWindowModified() const;

    void setToolTip(const QString &);
    QString toolTip() const;

    void setStatusTip(const QString &);
    QString statusTip() const;

    void setWhatsThis(const QString &);
    QString whatsThis() const;


    QString accessibleName() const;
    void setAccessibleName(const QString &name);
    QString accessibleDescription() const;
    void setAccessibleDescription(const QString &description);


    void setLayoutDirection(Qt::LayoutDirection direction);
    Qt::LayoutDirection layoutDirection() const;
    void unsetLayoutDirection();

    inline bool isRightToLeft() const { return layoutDirection() == Qt::RightToLeft; }
    inline bool isLeftToRight() const { return layoutDirection() == Qt::LeftToRight; }

public :
    inline void setFocus() { setFocus(Qt::OtherFocusReason); }

public:
    bool isActiveWindow() const;
    void activateWindow();
    void clearFocus();

    void setFocus(Qt::FocusReason reason);
    Qt::FocusPolicy focusPolicy() const;
    void setFocusPolicy(Qt::FocusPolicy policy);
    bool hasFocus() const;
    static void setTabOrder(QWidget *, QWidget *);
    void setFocusProxy(QWidget *);
    QWidget *focusProxy() const;
    Qt::ContextMenuPolicy contextMenuPolicy() const;
    void setContextMenuPolicy(Qt::ContextMenuPolicy policy);


    void grabMouse();

    void grabMouse(const QCursor &);

    void releaseMouse();
    void grabKeyboard();
    void releaseKeyboard();

    int grabShortcut(const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut);
    void releaseShortcut(int id);
    void setShortcutEnabled(int id, bool enable = true);

    static QWidget *mouseGrabber();
    static QWidget *keyboardGrabber();


    inline bool updatesEnabled() const;
    void setUpdatesEnabled(bool enable);





public :
    void update();
    void repaint();

public:
    inline void update(int x, int y, int w, int h);
    void update(const QRect&);
    void update(const QRegion&);

    void repaint(int x, int y, int w, int h);
    void repaint(const QRect &);
    void repaint(const QRegion &);

public :


    virtual void setVisible(bool visible);
    inline void setHidden(bool hidden) { setVisible(!hidden); }
    inline void show() { setVisible(true); }
    inline void hide() { setVisible(false); }
    inline  void setShown(bool shown) { setVisible(shown); }

    void showMinimized();
    void showMaximized();
    void showFullScreen();
    void showNormal();

    bool close();
    void raise();
    void lower();

public:
    void stackUnder(QWidget*);
    void move(int x, int y);
    void move(const QPoint &);
    void resize(int w, int h);
    void resize(const QSize &);
    inline void setGeometry(int x, int y, int w, int h);
    void setGeometry(const QRect &);
    void adjustSize();
    bool isVisible() const;
    bool isVisibleTo(QWidget*) const;
    inline bool isHidden() const;

    bool isMinimized() const;
    bool isMaximized() const;
    bool isFullScreen() const;

    Qt::WindowStates windowState() const;
    void setWindowState(Qt::WindowStates state);
    void overrideWindowState(Qt::WindowStates state);

    virtual QSize sizeHint() const;
    virtual QSize minimumSizeHint() const;

    QSizePolicy sizePolicy() const;
    void setSizePolicy(QSizePolicy);
    inline void setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical);
    virtual int heightForWidth(int) const;

    QRegion visibleRegion() const;

    void setContentsMargins(int left, int top, int right, int bottom);
    void getContentsMargins(int *left, int *top, int *right, int *bottom) const;
    QRect contentsRect() const;

public:
    QLayout *layout() const;
    void setLayout(QLayout *);
    void updateGeometry();

    void setParent(QWidget *parent);
    void setParent(QWidget *parent, Qt::WFlags f);

    void scroll(int dx, int dy);
    void scroll(int dx, int dy, const QRect&);



    QWidget *focusWidget() const;
    QWidget *nextInFocusChain() const;


    bool acceptDrops() const;
    void setAcceptDrops(bool on);



    void addAction(QAction *action);
    void addActions(QList<QAction*> actions);
    void insertAction(QAction *before, QAction *action);
    void insertActions(QAction *before, QList<QAction*> actions);
    void removeAction(QAction *action);
    QList<QAction*> actions() const;


    QWidget *parentWidget() const;

    void setWindowFlags(Qt::WindowFlags type);
    inline Qt::WindowFlags windowFlags() const;
    void overrideWindowFlags(Qt::WindowFlags type);

    inline Qt::WindowType windowType() const;

    static QWidget *find(WId);



    inline QWidget *childAt(int x, int y) const;
    QWidget *childAt(const QPoint &p) const;







    HDC getDC() const;
    void releaseDC(HDC) const;




    void setAttribute(Qt::WidgetAttribute, bool on = true);
    inline bool testAttribute(Qt::WidgetAttribute) const;

    QPaintEngine *paintEngine() const;

    void ensurePolished() const;

    QInputContext *inputContext();
    void setInputContext(QInputContext *);

    bool isAncestorOf(const QWidget *child) const;






protected:
    void customContextMenuRequested(const QPoint &pos);

protected:

    bool event(QEvent *);
    virtual void mousePressEvent(QMouseEvent *);
    virtual void mouseReleaseEvent(QMouseEvent *);
    virtual void mouseDoubleClickEvent(QMouseEvent *);
    virtual void mouseMoveEvent(QMouseEvent *);

    virtual void wheelEvent(QWheelEvent *);

    virtual void keyPressEvent(QKeyEvent *);
    virtual void keyReleaseEvent(QKeyEvent *);
    virtual void focusInEvent(QFocusEvent *);
    virtual void focusOutEvent(QFocusEvent *);
    virtual void enterEvent(QEvent *);
    virtual void leaveEvent(QEvent *);
    virtual void paintEvent(QPaintEvent *);
    virtual void moveEvent(QMoveEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void closeEvent(QCloseEvent *);
    virtual void contextMenuEvent(QContextMenuEvent *);
    virtual void tabletEvent(QTabletEvent *);
    virtual void actionEvent(QActionEvent *);


    virtual void dragEnterEvent(QDragEnterEvent *);
    virtual void dragMoveEvent(QDragMoveEvent *);
    virtual void dragLeaveEvent(QDragLeaveEvent *);
    virtual void dropEvent(QDropEvent *);


    virtual void showEvent(QShowEvent *);
    virtual void hideEvent(QHideEvent *);





    virtual bool winEvent(MSG *message, long *result);











    virtual void changeEvent(QEvent *);

    int metric(PaintDeviceMetric) const;

    virtual void inputMethodEvent(QInputMethodEvent *);
public:
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;
protected:
    void resetInputContext();
    void updateMicroFocus();

    void create(WId = 0, bool initializeWindow = true,
                         bool destroyOldWindow = true);
    void destroy(bool destroyWindow = true,
                 bool destroySubWindows = true);

    virtual bool focusNextPrevChild(bool next);
    inline bool focusNextChild() { return focusNextPrevChild(true); }
    inline bool focusPreviousChild() { return focusNextPrevChild(false); }

protected:
    QWidget(QWidgetPrivate &d, QWidget* parent, Qt::WFlags f);
private:

    bool testAttribute_helper(Qt::WidgetAttribute) const;

    friend void qt_syncBackingStores();
    friend void qt_syncBackingStore(QRegion, QWidget *);
    friend class QBackingStoreDevice;
    friend class QWidgetBackingStore;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QPixmap;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;
    friend class QLayout;
    friend class QWidgetItem;
    friend class QGLContext;
    friend class QX11PaintEngine;
    friend class QWin32PaintEngine;
    friend class QShortcutPrivate;













private:
    QWidget(const QWidget &); QWidget &operator=(const QWidget &);

    QWidgetData *data;
































































































protected:
    virtual void styleChange(QStyle&);
    virtual void enabledChange(bool);
    virtual void paletteChange(const QPalette &);
    virtual void fontChange(const QFont &);
    virtual void windowActivationChange(bool);
    virtual void languageChange();
};








template <> inline QWidget *qobject_cast<QWidget*>(QObject *o)
{
    if (!o || !o->isWidgetType()) return 0;
    return static_cast<QWidget*>(o);
}
template <> inline const QWidget *qobject_cast<const QWidget*>(const QObject *o)
{
    if (!o || !o->isWidgetType()) return 0;
    return static_cast<const QWidget*>(o);
}


inline QWidget *QWidget::childAt(int ax, int ay) const
{ return childAt(QPoint(ax, ay)); }

inline Qt::WindowType QWidget::windowType() const
{ return static_cast<Qt::WindowType>(int(data->window_flags & Qt::WindowType_Mask)); }
inline Qt::WindowFlags QWidget::windowFlags() const
{ return data->window_flags; }

inline WId QWidget::winId() const
{ return data->winid; }

inline bool QWidget::isTopLevel() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isWindow() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isEnabled() const
{ return !testAttribute(Qt::WA_Disabled); }

inline bool QWidget::isModal() const
{ return testAttribute(Qt::WA_ShowModal); }

inline bool QWidget::isEnabledToTLW() const
{ return isEnabled(); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize(const QSize &s)
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize(const QSize &s)
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement(const QSize &s)
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize(const QSize &s)
{ setBaseSize(s.width(),s.height()); }

inline const QFont &QWidget::font() const
{ return data->fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(data->fnt); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(data->fnt); }

inline void QWidget::setMouseTracking(bool enable)
{ setAttribute(Qt::WA_MouseTracking, enable); }

inline bool QWidget::hasMouseTracking() const
{ return testAttribute(Qt::WA_MouseTracking); }

inline bool QWidget::underMouse() const
{ return testAttribute(Qt::WA_UnderMouse); }

inline bool QWidget::updatesEnabled() const
{ return !testAttribute(Qt::WA_UpdatesDisabled); }

inline void QWidget::update(int ax, int ay, int aw, int ah)
{ update(QRect(ax, ay, aw, ah)); }

inline bool QWidget::isVisible() const
{ return testAttribute(Qt::WA_WState_Visible); }

inline bool QWidget::isHidden() const
{ return testAttribute(Qt::WA_WState_Hidden); }

inline void QWidget::move(int ax, int ay)
{ move(QPoint(ax, ay)); }

inline void QWidget::resize(int w, int h)
{ resize(QSize(w, h)); }

inline void QWidget::setGeometry(int ax, int ay, int aw, int ah)
{ setGeometry(QRect(ax, ay, aw, ah)); }

inline QRect QWidget::rect() const
{ return QRect(0,0,data->crect.width(),data->crect.height()); }

inline const QRect &QWidget::geometry() const
{ return data->crect; }

inline QSize QWidget::size() const
{ return data->crect.size(); }

inline int QWidget::width() const
{ return data->crect.width(); }

inline int QWidget::height() const
{ return data->crect.height(); }

inline QWidget *QWidget::parentWidget() const
{ return static_cast<QWidget *>(QObject::parent()); }

inline void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver)
{ setSizePolicy(QSizePolicy(hor, ver)); }

inline bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
{
    if (attribute < int(8*sizeof(uint)))
        return data->widget_attributes & (1<<attribute);
    return testAttribute_helper(attribute);
}














































typedef QtValidLicenseForGuiModule QtGuiModule;

class QPushButton;
class QDialogPrivate;

class __declspec(dllimport) QDialog : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QDialogPrivate* d_func() { return reinterpret_cast<QDialogPrivate *>(d_ptr); } inline const QDialogPrivate* d_func() const { return reinterpret_cast<const QDialogPrivate *>(d_ptr); } friend class QDialogPrivate;
    friend class QPushButton;




public:
    explicit QDialog(QWidget *parent = 0, Qt::WFlags f = 0);




    ~QDialog();

    enum DialogCode { Rejected, Accepted };

    int result() const;

    void setVisible(bool visible);

    void setOrientation(Qt::Orientation orientation);
    Qt::Orientation orientation() const;

    void setExtension(QWidget* extension);
    QWidget* extension() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setSizeGripEnabled(bool);
    bool isSizeGripEnabled() const;

    void setModal(bool modal);




    void setResult(int r);

public :
    int exec();
    virtual void done(int);
    virtual void accept();
    virtual void reject();

    void showExtension(bool);

protected:
    QDialog(QDialogPrivate &, QWidget *parent, Qt::WFlags f = 0);

    void keyPressEvent(QKeyEvent *);
    void closeEvent(QCloseEvent *);
    void showEvent(QShowEvent *);
    void resizeEvent(QResizeEvent *);
    void contextMenuEvent(QContextMenuEvent *);
    bool eventFilter(QObject *, QEvent *);
    void adjustPosition(QWidget*);

private:
    QDialog(const QDialog &); QDialog &operator=(const QDialog &);
};






typedef QtValidLicenseForGuiModule QtGuiModule;



class QAbstractPageSetupDialogPrivate;
class QPrinter;

class __declspec(dllimport) QAbstractPageSetupDialog : public QDialog
{
    inline QAbstractPageSetupDialogPrivate* d_func() { return reinterpret_cast<QAbstractPageSetupDialogPrivate *>(d_ptr); } inline const QAbstractPageSetupDialogPrivate* d_func() const { return reinterpret_cast<const QAbstractPageSetupDialogPrivate *>(d_ptr); } friend class QAbstractPageSetupDialogPrivate;

public:
    explicit QAbstractPageSetupDialog(QPrinter *printer, QWidget *parent = 0);
    QAbstractPageSetupDialog(QAbstractPageSetupDialogPrivate &ptr,
                             QPrinter *printer, QWidget *parent = 0);

    virtual int exec() = 0;

    QPrinter *printer();
};






















































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAbstractPrintDialogPrivate;
class QPrinter;

class __declspec(dllimport) QAbstractPrintDialog : public QDialog
{
    inline QAbstractPrintDialogPrivate* d_func() { return reinterpret_cast<QAbstractPrintDialogPrivate *>(d_ptr); } inline const QAbstractPrintDialogPrivate* d_func() const { return reinterpret_cast<const QAbstractPrintDialogPrivate *>(d_ptr); } friend class QAbstractPrintDialogPrivate;

public:
    enum PrintRange {
        AllPages,
        Selection,
        PageRange
    };

    enum PrintDialogOption {
        None                    = 0x0000,
        PrintToFile             = 0x0001,
        PrintSelection          = 0x0002,
        PrintPageRange          = 0x0004,
        PrintCollateCopies      = 0x0010
    };

    typedef QFlags<PrintDialogOption> PrintDialogOptions;

    explicit QAbstractPrintDialog(QPrinter *printer, QWidget *parent = 0);

    virtual int exec() = 0;

    void addEnabledOption(PrintDialogOption option);
    void setEnabledOptions(PrintDialogOptions options);
    PrintDialogOptions enabledOptions() const;
    bool isOptionEnabled(PrintDialogOption option) const;

    void setPrintRange(PrintRange range);
    PrintRange printRange() const;

    void setMinMax(int min, int max);
    int minPage() const;
    int maxPage() const;

    void setFromTo(int fromPage, int toPage);
    int fromPage() const;
    int toPage() const;

    QPrinter *printer() const;

protected:
    QAbstractPrintDialog(QAbstractPrintDialogPrivate &ptr, QPrinter *printer, QWidget *parent = 0);

private:
    QAbstractPrintDialog(const QAbstractPrintDialog &); QAbstractPrintDialog &operator=(const QAbstractPrintDialog &);
};

inline QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> operator|(QAbstractPrintDialog::PrintDialogOptions::enum_type f1, QAbstractPrintDialog::PrintDialogOptions::enum_type f2) { return QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type>(f1) | f2; } inline QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> operator|(QAbstractPrintDialog::PrintDialogOptions::enum_type f1, QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> f2) { return f2 | f1; }























































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QColorDialogPrivate;

class __declspec(dllimport) QColorDialog : public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QColorDialogPrivate* d_func() { return reinterpret_cast<QColorDialogPrivate *>(d_ptr); } inline const QColorDialogPrivate* d_func() const { return reinterpret_cast<const QColorDialogPrivate *>(d_ptr); } friend class QColorDialogPrivate;

public:
    static QColor getColor(const QColor& init = Qt::white, QWidget* parent=0);
    static QRgb getRgba(QRgb, bool* ok = 0, QWidget* parent=0);

    static int customCount();
    static QRgb customColor(int);
    static void setCustomColor(int, QRgb);
    static void setStandardColor(int, QRgb);








private:
    ~QColorDialog();
    explicit QColorDialog(QWidget* parent=0, bool modal=false);

    void setColor(const QColor&);
    QColor color() const;

    bool selectColor(const QColor&);

    void setSelectedAlpha(int);
    int selectedAlpha() const;

    void showCustom(bool=true);

private:
    QColorDialog(const QColorDialog &); QColorDialog &operator=(const QColorDialog &);








    friend class QColorShower;
};





















































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QErrorMessagePrivate;

class __declspec(dllimport) QErrorMessage: public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QErrorMessagePrivate* d_func() { return reinterpret_cast<QErrorMessagePrivate *>(d_ptr); } inline const QErrorMessagePrivate* d_func() const { return reinterpret_cast<const QErrorMessagePrivate *>(d_ptr); } friend class QErrorMessagePrivate;
public:
    explicit QErrorMessage(QWidget* parent = 0);
    ~QErrorMessage();

    static QErrorMessage * qtHandler();

public :
    void showMessage(const QString &message);




protected:
    void done(int);

private:
    QErrorMessage(const QErrorMessage &); QErrorMessage &operator=(const QErrorMessage &);
};






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QModelIndex;
class QItemSelection;
struct QFileDialogArgs;
class QFileIconProvider;
class QFileDialogPrivate;
class QAbstractItemDelegate;

class __declspec(dllimport) QFileDialog : public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:









public:
    enum ViewMode { Detail, List };
    enum FileMode { AnyFile, ExistingFile, Directory, ExistingFiles, DirectoryOnly };
    enum AcceptMode { AcceptOpen, AcceptSave };
    enum DialogLabel { LookIn, FileName, FileType, Accept, Reject };

    enum Option {
        ShowDirsOnly = 0x01,
        DontResolveSymlinks = 0x02,
        DontConfirmOverwrite = 0x04,
        DontUseSheet = 0x08,
        DontUseNativeDialog = 0x10
    };
    typedef QFlags<Option> Options;

    QFileDialog(QWidget *parent, Qt::WFlags f);
    explicit QFileDialog(QWidget *parent = 0,
                         const QString &caption = QString(),
                         const QString &directory = QString(),
                         const QString &filter = QString());
    ~QFileDialog();

    void setDirectory(const QString &directory);
    inline void setDirectory(const QDir &directory);
    QDir directory() const;

    void selectFile(const QString &filename);
    QStringList selectedFiles() const;

    void setFilter(const QString &filter);
    void setFilters(const QStringList &filters);
    QStringList filters() const;

    void selectFilter(const QString &filter);
    QString selectedFilter() const;

    void setViewMode(ViewMode mode);
    ViewMode viewMode() const;

    void setFileMode(FileMode mode);
    FileMode fileMode() const;

    void setAcceptMode(AcceptMode mode);
    AcceptMode acceptMode() const;

    void setReadOnly(bool enabled);
    bool isReadOnly() const;

    void setResolveSymlinks(bool enabled);
    bool resolveSymlinks() const;

    void setConfirmOverwrite(bool enabled);
    bool confirmOverwrite() const;

    void setDefaultSuffix(const QString &suffix);
    QString defaultSuffix() const;

    void setHistory(const QStringList &paths);
    QStringList history() const;

    void setItemDelegate(QAbstractItemDelegate *delegate);
    QAbstractItemDelegate *itemDelegate() const;

    void setIconProvider(QFileIconProvider *provider);
    QFileIconProvider *iconProvider() const;

    void setLabelText(DialogLabel label, const QString &text);
    QString labelText(DialogLabel label) const;

protected:
    void filesSelected(const QStringList &files);
    void currentChanged(const QString &path);

public:









    static QString getOpenFileName(QWidget *parent = 0,
                                   const QString &caption = QString(),
                                   const QString &dir = QString(),
                                   const QString &filter = QString(),
                                   QString *selectedFilter = 0,
                                   Options options = 0);

    static QString getSaveFileName(QWidget *parent = 0,
                                   const QString &caption = QString(),
                                   const QString &dir = QString(),
                                   const QString &filter = QString(),
                                   QString *selectedFilter = 0,
                                   Options options = 0);

    static QString getExistingDirectory(QWidget *parent = 0,
                                        const QString &caption = QString(),
                                        const QString &dir = QString(),
                                        Options options = ShowDirsOnly);

    static QStringList getOpenFileNames(QWidget *parent = 0,
                                        const QString &caption = QString(),
                                        const QString &dir = QString(),
                                        const QString &filter = QString(),
                                        QString *selectedFilter = 0,
                                        Options options = 0);













































protected:
    QFileDialog(const QFileDialogArgs &args);
    void done(int result);
    void accept();

private:
    inline QFileDialogPrivate* d_func() { return reinterpret_cast<QFileDialogPrivate *>(d_ptr); } inline const QFileDialogPrivate* d_func() const { return reinterpret_cast<const QFileDialogPrivate *>(d_ptr); } friend class QFileDialogPrivate;
    QFileDialog(const QFileDialog &); QFileDialog &operator=(const QFileDialog &);






















};

inline void QFileDialog::setDirectory(const QDir &adirectory)
{ setDirectory(adirectory.absolutePath()); }

inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFileDialog::Options::enum_type f2) { return QFlags<QFileDialog::Options::enum_type>(f1) | f2; } inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFlags<QFileDialog::Options::enum_type> f2) { return f2 | f1; }




































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;






































































































































































































































































































































































class QFontDialogPrivate;

class __declspec(dllimport) QFontDialog: public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QFontDialogPrivate* d_func() { return reinterpret_cast<QFontDialogPrivate *>(d_ptr); } inline const QFontDialogPrivate* d_func() const { return reinterpret_cast<const QFontDialogPrivate *>(d_ptr); } friend class QFontDialogPrivate;

public:
    static QFont getFont(bool *ok, const QFont &def, QWidget* parent=0);
    static QFont getFont(bool *ok, QWidget* parent=0);








private:
    static QFont getFont(bool *ok, const QFont *def, QWidget* parent=0);

    explicit QFontDialog(QWidget* parent=0, bool modal=false, Qt::WFlags f=0);
    ~QFontDialog();

    QFont font() const;
    void setFont(const QFont &font);

    bool eventFilter(QObject *, QEvent *);

    void updateFamilies();
    void updateStyles();
    void updateSizes();

private:







    QFontDialog(const QFontDialog &); QFontDialog &operator=(const QFontDialog &);
};

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class QValidator;
class QMenu;

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QFramePrivate;

class __declspec(dllimport) QFrame : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:









public:
    explicit QFrame(QWidget* parent = 0, Qt::WFlags f = 0);
    ~QFrame();

    int frameStyle() const;
    void setFrameStyle(int);

    int frameWidth() const;

    QSize sizeHint() const;

    enum Shape {
        NoFrame  = 0,
        Box = 0x0001,
        Panel = 0x0002,
        WinPanel = 0x0003,
        HLine = 0x0004,
        VLine = 0x0005,
        StyledPanel = 0x0006









    };
    enum Shadow {
        Plain = 0x0010,
        Raised = 0x0020,
        Sunken = 0x0030
    };

    enum {
        Shadow_Mask = 0x00f0,
        Shape_Mask = 0x000f




    };

    Shape frameShape() const;
    void setFrameShape(Shape);
    Shadow frameShadow() const;
    void setFrameShadow(Shadow);

    int lineWidth() const;
    void setLineWidth(int);

    int midLineWidth() const;
    void setMidLineWidth(int);

    QRect frameRect() const;
    void setFrameRect(const QRect &);

protected:
    void paintEvent(QPaintEvent *);
    void changeEvent(QEvent *);
    void drawFrame(QPainter *);






protected:
    QFrame(QFramePrivate &dd, QWidget* parent = 0, Qt::WFlags f = 0);

private:
    QFrame(const QFrame &); QFrame &operator=(const QFrame &);
    inline QFramePrivate* d_func() { return reinterpret_cast<QFramePrivate *>(d_ptr); } inline const QFramePrivate* d_func() const { return reinterpret_cast<const QFramePrivate *>(d_ptr); } friend class QFramePrivate;
};














































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QLineEditPrivate;

class __declspec(dllimport) QLineEdit : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



















public:
    explicit QLineEdit(QWidget* parent=0);
    explicit QLineEdit(const QString &, QWidget* parent=0);





    ~QLineEdit();

    QString text() const;

    QString displayText() const;

    int maxLength() const;
    void setMaxLength(int);

    void setFrame(bool);
    bool hasFrame() const;

    enum EchoMode { Normal, NoEcho, Password };
    EchoMode echoMode() const;
    void setEchoMode(EchoMode);

    bool isReadOnly() const;
    void setReadOnly(bool);


    void setValidator(const QValidator *);
    const QValidator * validator() const;


    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    int cursorPosition() const;
    void setCursorPosition(int);
    int cursorPositionAt(const QPoint &pos);

    void setAlignment(Qt::Alignment flag);
    Qt::Alignment alignment() const;

    void cursorForward(bool mark, int steps = 1);
    void cursorBackward(bool mark, int steps = 1);
    void cursorWordForward(bool mark);
    void cursorWordBackward(bool mark);
    void backspace();
    void del();
    void home(bool mark);
    void end(bool mark);

    bool isModified() const;
    void setModified(bool);

    void setSelection(int, int);
    bool hasSelectedText() const;
    QString selectedText() const;
    int selectionStart() const;

    bool isUndoAvailable() const;
    bool isRedoAvailable() const;

    void setDragEnabled(bool b);
    bool dragEnabled() const;

    QString inputMask() const;
    void setInputMask(const QString &inputMask);
    bool hasAcceptableInput() const;

public :
    void setText(const QString &);
    void clear();
    void selectAll();
    void undo();
    void redo();

    void cut();
    void copy() const;
    void paste();


public:
    void deselect();
    void insert(const QString &);

    QMenu *createStandardContextMenu();


protected:
    void textChanged(const QString &);
    void textEdited(const QString &);
    void cursorPositionChanged(int, int);
    void returnPressed();
    void editingFinished();
    void selectionChanged();

protected:
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseDoubleClickEvent(QMouseEvent *);
    void keyPressEvent(QKeyEvent *);
    void focusInEvent(QFocusEvent *);
    void focusOutEvent(QFocusEvent *);
    void paintEvent(QPaintEvent *);

    void dragEnterEvent(QDragEnterEvent *);
    void dragMoveEvent(QDragMoveEvent *e);
    void dragLeaveEvent(QDragLeaveEvent *e);
    void dropEvent(QDropEvent *);

    void changeEvent(QEvent *);

    void contextMenuEvent(QContextMenuEvent *);





    void inputMethodEvent(QInputMethodEvent *);
public:
    QVariant inputMethodQuery(Qt::InputMethodQuery) const;
    bool event(QEvent *);
protected:

public:




















private:
    QLineEdit(const QLineEdit &); QLineEdit &operator=(const QLineEdit &);
    inline QLineEditPrivate* d_func() { return reinterpret_cast<QLineEditPrivate *>(d_ptr); } inline const QLineEditPrivate* d_func() const { return reinterpret_cast<const QLineEditPrivate *>(d_ptr); } friend class QLineEditPrivate;

};







typedef QtValidLicenseForGuiModule QtGuiModule;



class QSpinBox;
class QComboBox;
class QInputDialogPrivate;

class __declspec(dllimport) QInputDialog : public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QInputDialogPrivate* d_func() { return reinterpret_cast<QInputDialogPrivate *>(d_ptr); } inline const QInputDialogPrivate* d_func() const { return reinterpret_cast<const QInputDialogPrivate *>(d_ptr); } friend class QInputDialogPrivate;

private:
    enum Type { LineEdit, SpinBox, DoubleSpinBox, ComboBox, EditableComboBox };

    QInputDialog(const QString &label, QWidget* parent, Type type, Qt::WFlags f);
    ~QInputDialog();

public:
    static QString getText(QWidget *parent, const QString &title, const QString &label,
                           QLineEdit::EchoMode echo = QLineEdit::Normal,
                           const QString &text = QString(), bool *ok = 0, Qt::WFlags f = 0);
    static int getInteger(QWidget *parent, const QString &title, const QString &label, int value = 0,
                          int minValue = -2147483647, int maxValue = 2147483647,
                          int step = 1, bool *ok = 0, Qt::WFlags f = 0);
    static double getDouble(QWidget *parent, const QString &title, const QString &label, double value = 0,
                            double minValue = -2147483647, double maxValue = 2147483647,
                            int decimals = 1, bool *ok = 0, Qt::WFlags f = 0);
    static QString getItem(QWidget *parent, const QString &title, const QString &label, const QStringList &list,
                           int current = 0, bool editable = true, bool *ok = 0,Qt::WFlags f = 0);























private:
    QInputDialog(const QInputDialog &); QInputDialog &operator=(const QInputDialog &);
};























































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QLabel;
class QMessageBoxPrivate;

class __declspec(dllimport) QMessageBox : public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    enum Icon {
        NoIcon = 0,
        Information = 1,
        Warning = 2,
        Critical = 3,
        Question = 4
    };

    explicit QMessageBox(QWidget *parent = 0);
    QMessageBox(const QString &caption, const QString &text, Icon icon,
                int button0, int button1, int button2,
                QWidget *parent = 0, Qt::WFlags f = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);
    ~QMessageBox();

    enum Button { NoButton = 0, Ok = 1, Cancel = 2, Yes = 3, No = 4, Abort = 5,
           Retry = 6, Ignore = 7, YesAll = 8, NoAll = 9, ButtonMask = 0xff,
           Default = 0x100, Escape = 0x200, FlagMask = 0x300 };

    QString text() const;
    void setText(const QString &);

    Icon icon() const;
    void setIcon(Icon);

    QPixmap iconPixmap() const;
    void setIconPixmap(const QPixmap &);

    QString buttonText(int button) const;
    void setButtonText(int button, const QString &);

    Qt::TextFormat textFormat() const;
    void setTextFormat(Qt::TextFormat);

    static int information(QWidget *parent, const QString &caption,
                            const QString& text,
                            int button0, int button1=0, int button2=0);
    static int information(QWidget *parent, const QString &caption,
                            const QString& text,
                            const QString& button0Text = QString(),
                            const QString& button1Text = QString(),
                            const QString& button2Text = QString(),
                            int defaultButtonNumber = 0,
                            int escapeButtonNumber = -1);

    static int question(QWidget *parent, const QString &caption,
                         const QString& text,
                         int button0, int button1=0, int button2=0);
    static int question(QWidget *parent, const QString &caption,
                         const QString& text,
                         const QString& button0Text = QString(),
                         const QString& button1Text = QString(),
                         const QString& button2Text = QString(),
                         int defaultButtonNumber = 0,
                         int escapeButtonNumber = -1);

    static int warning(QWidget *parent, const QString &caption,
                        const QString& text,
                        int button0, int button1, int button2=0);
    static int warning(QWidget *parent, const QString &caption,
                        const QString& text,
                        const QString& button0Text = QString(),
                        const QString& button1Text = QString(),
                        const QString& button2Text = QString(),
                        int defaultButtonNumber = 0,
                        int escapeButtonNumber = -1);

    static int critical(QWidget *parent, const QString &caption,
                         const QString& text,
                         int button0, int button1, int button2=0);
    static int critical(QWidget *parent, const QString &caption,
                         const QString& text,
                         const QString& button0Text = QString(),
                         const QString& button1Text = QString(),
                         const QString& button2Text = QString(),
                         int defaultButtonNumber = 0,
                         int escapeButtonNumber = -1);

    static void about(QWidget *parent, const QString &caption,
                       const QString& text);
    static void aboutQt(QWidget *parent,
                         const QString& caption=QString());
    QSize sizeHint() const;





























    static QPixmap standardIcon(Icon icon);

protected:
    void        resizeEvent(QResizeEvent *);
    void        showEvent(QShowEvent *);
    void        closeEvent(QCloseEvent *);
    void        keyPressEvent(QKeyEvent *);
    void        changeEvent(QEvent *);

private:


    QMessageBox(const QMessageBox &); QMessageBox &operator=(const QMessageBox &);
    inline QMessageBoxPrivate* d_func() { return reinterpret_cast<QMessageBoxPrivate *>(d_ptr); } inline const QMessageBoxPrivate* d_func() const { return reinterpret_cast<const QMessageBoxPrivate *>(d_ptr); } friend class QMessageBoxPrivate;
};
















































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPageSetupDialogPrivate;

class __declspec(dllimport) QPageSetupDialog : public QAbstractPageSetupDialog
{
    inline QPageSetupDialogPrivate* d_func() { return reinterpret_cast<QPageSetupDialogPrivate *>(d_ptr); } inline const QPageSetupDialogPrivate* d_func() const { return reinterpret_cast<const QPageSetupDialogPrivate *>(d_ptr); } friend class QPageSetupDialogPrivate;
public:
    explicit QPageSetupDialog(QPrinter *printer, QWidget *parent = 0);

    virtual int exec();



};












































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPrintDialogPrivate;
class QAbstractButton;
class QPrinter;

class __declspec(dllimport) QPrintDialog : public QAbstractPrintDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QPrintDialogPrivate* d_func() { return reinterpret_cast<QPrintDialogPrivate *>(d_ptr); } inline const QPrintDialogPrivate* d_func() const { return reinterpret_cast<const QPrintDialogPrivate *>(d_ptr); } friend class QPrintDialogPrivate;
public:
    explicit QPrintDialog(QPrinter *printer, QWidget *parent = 0);
    ~QPrintDialog();







    int exec();

private:
    QPrintDialog(const QPrintDialog &); QPrintDialog &operator=(const QPrintDialog &);
















};






















































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPushButton;
class QLabel;
class QProgressBar;
class QTimer;
class QProgressDialogPrivate;

class __declspec(dllimport) QProgressDialog : public QDialog
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QProgressDialogPrivate* d_func() { return reinterpret_cast<QProgressDialogPrivate *>(d_ptr); } inline const QProgressDialogPrivate* d_func() const { return reinterpret_cast<const QProgressDialogPrivate *>(d_ptr); } friend class QProgressDialogPrivate;









public:
    explicit QProgressDialog(QWidget *parent = 0, Qt::WFlags f = 0);
    QProgressDialog(const QString &labelText, const QString &cancelButtonText,
                    int minimum, int maximum,
                    QWidget *parent = 0, Qt::WFlags f = 0);
    ~QProgressDialog();

    void setLabel(QLabel *label);
    void setCancelButton(QPushButton *button);
    void setBar(QProgressBar *bar);

    bool wasCanceled() const;

    int minimum() const;
    int maximum() const;

    void setRange(int minimum, int maximum);
    int value() const;

    QSize sizeHint() const;

    QString labelText() const;
    int minimumDuration() const;

    void setAutoReset(bool b);
    bool autoReset() const;
    void setAutoClose(bool b);
    bool autoClose() const;

public :
    void cancel();
    void reset();
    void setMaximum(int maximum);
    void setMinimum(int minimum);
    void setValue(int progress);
    void setLabelText(const QString &);
    void setCancelButtonText(const QString &);
    void setMinimumDuration(int ms);

protected:
    void canceled();

protected:
    void resizeEvent(QResizeEvent *);
    void closeEvent(QCloseEvent *);
    void changeEvent(QEvent *);
    void showEvent(QShowEvent *e);

protected :
    void forceShow();

private:
    QProgressDialog(const QProgressDialog &); QProgressDialog &operator=(const QProgressDialog &);
};






















































typedef unsigned char *POINTER;


typedef unsigned short int UINT2;


typedef unsigned long int UINT4;


typedef struct {
  UINT4 state[4];
  UINT4 count[2];
  unsigned char buffer[64];
} MD5_CTX;


extern "C" {


void MD5Init(MD5_CTX *);
void MD5Update(MD5_CTX *, unsigned char *, unsigned int);
void MD5Final(unsigned char [16], MD5_CTX *);


}


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;




struct QVFbHeader
{
    int width;
    int height;
    int depth;
    int linestep;
    int dataoffset;
    QRect update;
    bool dirty;
    int  numcols;
    QRgb clut[256];
    int viewerVersion;
    int serverVersion;
};

struct QVFbKeyData
{
    unsigned int keycode;
    Qt::KeyboardModifiers modifiers;
    unsigned short int unicode;
    bool press;
    bool repeat;
};













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QIODevice;
class QStringList;
class QMatrix;
class QVariant;
template <class T> class QList;
template <class T> class QVector;

struct QImageData;
class QImageDataMisc;

class __declspec(dllimport) QImageTextKeyLang {
public:
    QImageTextKeyLang(const char* k, const char* l) : key(k), lang(l) { }
    QImageTextKeyLang() { }

    QByteArray key;
    QByteArray lang;

    bool operator< (const QImageTextKeyLang& other) const
        { return key < other.key || key==other.key && lang < other.lang; }
    bool operator== (const QImageTextKeyLang& other) const
        { return key==other.key && lang==other.lang; }
};



class __declspec(dllimport) QImage : public QPaintDevice
{
public:
    enum InvertMode { InvertRgb, InvertRgba };
    enum Format {
        Format_Invalid,
        Format_Mono,
        Format_MonoLSB,
        Format_Indexed8,
        Format_RGB32,
        Format_ARGB32,
        Format_ARGB32_Premultiplied










    };

    QImage();
    QImage(const QSize &size, Format format);
    QImage(int width, int height, Format format);
    QImage(uchar *data, int width, int height, Format format);


    explicit QImage(const char * const xpm[]);

    explicit QImage(const QString &fileName, const char *format = 0);

    explicit QImage(const char *fileName, const char *format = 0);


    QImage(const QImage &);
    ~QImage();

    QImage &operator=(const QImage &);
    bool isNull() const;

    int devType() const;

    bool operator==(const QImage &) const;
    bool operator!=(const QImage &) const;
    operator QVariant() const;
    void detach();
    bool isDetached() const;

    QImage copy(const QRect &rect = QRect()) const;
    inline QImage copy(int x, int y, int w, int h) const
        { return copy(QRect(x, y, w, h)); }

    Format format() const;

    QImage convertToFormat(Format f, Qt::ImageConversionFlags flags = Qt::AutoColor) const;
    QImage convertToFormat(Format f, const QVector<QRgb> &colorTable, Qt::ImageConversionFlags flags = Qt::AutoColor) const;

    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;

    int depth() const;
    int numColors() const;

    QRgb color(int i) const;
    void setColor(int i, QRgb c);
    void setNumColors(int);

    bool allGray() const;
    bool isGrayscale() const;

    uchar *bits();
    const uchar *bits() const;
    int numBytes() const;

    uchar *scanLine(int);
    const uchar *scanLine(int) const;
    int bytesPerLine() const;

    bool valid(int x, int y) const;
    int pixelIndex(int x, int y) const;
    QRgb pixel(int x, int y) const;
    void setPixel(int x, int y, uint index_or_rgb);

    QVector<QRgb> colorTable() const;
    void setColorTable(const QVector<QRgb> colors);

    void fill(uint pixel);

    bool hasAlphaChannel() const;
    void setAlphaChannel(const QImage &alphaChannel);
    QImage alphaChannel() const;
    QImage createAlphaMask(Qt::ImageConversionFlags flags = Qt::AutoColor) const;

    QImage createHeuristicMask(bool clipTight = true) const;


    inline QImage scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                        Qt::TransformationMode mode = Qt::FastTransformation) const
        { return scaled(QSize(w, h), aspectMode, mode); }
    QImage scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                 Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage transformed(const QMatrix &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &, int w, int h);
    QImage mirrored(bool horizontally = false, bool vertically = true) const;
    QImage rgbSwapped() const;
    void invertPixels(InvertMode = InvertRgb);


    bool load(QIODevice *device, const char* format);
    bool load(const QString &fileName, const char* format=0);
    bool loadFromData(const uchar *buf, int len, const char *format = 0);
    inline bool loadFromData(const QByteArray &data, const char* aformat=0)
        { return loadFromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), aformat); }

    bool save(const QString &fileName, const char* format, int quality=-1) const;
    bool save(QIODevice *device, const char* format, int quality=-1) const;

    static QImage fromData(const uchar *data, int size, const char *format = 0);
    inline static QImage fromData(const QByteArray &data, const char *format = 0)
        { return fromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), format); }

    int serialNumber() const;





    QPaintEngine *paintEngine() const;


    int dotsPerMeterX() const;
    int dotsPerMeterY() const;
    void setDotsPerMeterX(int);
    void setDotsPerMeterY(int);
    QPoint offset() const;
    void setOffset(const QPoint&);

    QList<QImageTextKeyLang> textList() const;
    QStringList textLanguages() const;
    QStringList textKeys() const;
    QString text(const char* key, const char* lang=0) const;
    QString text(const QImageTextKeyLang&) const;
    void setText(const char* key, const char* lang, const QString&);














































protected:
    virtual int metric(PaintDeviceMetric metric) const;

private:
    QImageData *d;

    friend class QPixmap;
};

template <> inline bool qIsDetached<QImage>(QImage &t) { return t.isDetached(); }
template <> class QTypeInfo<QImage> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QImage)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QImage"; } };




__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QImage &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QImage &);











typedef QtValidLicenseForGuiModule QtGuiModule;

class QImageWriter;
class QPixmapPrivate;
class QColor;
class QVariant;
class QX11Info;

struct QPixmapData;

class __declspec(dllimport) QPixmap : public QPaintDevice
{
public:
    QPixmap();
    QPixmap(int w, int h);
    QPixmap(const QSize &);
    QPixmap(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);

    QPixmap(const char * const xpm[]);

    QPixmap(const QPixmap &);
    ~QPixmap();

    QPixmap &operator=(const QPixmap &);
    operator QVariant() const;

    bool isNull() const;
    int devType() const;

    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;
    int depth() const;

    static int defaultDepth();

    void fill(const QColor &fillColor = Qt::white);
    void fill(const QWidget *widget, const QPoint &ofs);
    inline void fill(const QWidget *widget, int xofs, int yofs) { fill(widget, QPoint(xofs, yofs)); }

    QBitmap mask() const;
    void setMask(const QBitmap &);

    QPixmap alphaChannel() const;
    void setAlphaChannel(const QPixmap &);

    bool hasAlpha() const;
    bool hasAlphaChannel() const;


    QBitmap createHeuristicMask(bool clipTight = true) const;

    QBitmap createMaskFromColor(const QColor &maskColor) const;

    static QPixmap grabWindow(WId, int x=0, int y=0, int w=-1, int h=-1);
    static QPixmap grabWidget(QWidget *widget, const QRect &rect);
    static inline QPixmap grabWidget(QWidget *widget, int x=0, int y=0, int w=-1, int h=-1)
    { return grabWidget(widget, QRect(x, y, w, h)); }


    inline QPixmap scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                          Qt::TransformationMode mode = Qt::FastTransformation) const
        { return scaled(QSize(w, h), aspectMode, mode); }
    QPixmap scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                   Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap transformed(const QMatrix &, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &m, int w, int h);

    QImage toImage() const;
    static QPixmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);

    bool load(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool loadFromData(const uchar *buf, uint len, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline bool loadFromData(const QByteArray &data, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool save(const QString& fileName, const char* format, int quality = -1) const;
    bool save(QIODevice* device, const char* format, int quality = -1) const;


    enum HBitmapFormat {
        NoAlpha,
        PremultipliedAlpha
    };

    HBITMAP toWinHBITMAP(HBitmapFormat format = NoAlpha) const;
    static QPixmap fromWinHBITMAP(HBITMAP hbitmap, HBitmapFormat format = NoAlpha);


    inline QPixmap copy(int x, int y, int width, int height) const;
    QPixmap copy(const QRect &rect = QRect()) const;

    int serialNumber() const;

    bool isDetached() const;
    void detach();

    inline bool isQBitmap() const { return depth() == 1; }





















    QPaintEngine *paintEngine() const;

    inline bool operator!() const { return isNull(); }

protected:
    int metric(PaintDeviceMetric) const;























private:
    QPixmapData *data;

    bool doImageIO(QImageWriter *io, int quality) const;
    enum Type { PixmapType, BitmapType };
    QPixmap(const QSize &s, Type);

    void init(int, int, Type = PixmapType);
    void deref();

    void initAlphaPixmap(uchar *bytes, int length, struct tagBITMAPINFO *bmi);







    friend struct QPixmapData;
    friend class QBitmap;
    friend class QPaintDevice;
    friend class QPainter;
    friend class QGLWidget;
    friend class QX11PaintEngine;
    friend class QQuickDrawPaintEngine;
    friend class QCoreGraphicsPaintEngine;
    friend class QWidgetPrivate;
    friend class QRasterPaintEngine;

    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPixmap &);

};

template <> inline bool qIsDetached<QPixmap>(QPixmap &t) { return t.isDetached(); }


inline QPixmap QPixmap::copy(int ax, int ay, int awidth, int aheight) const
{
    return copy(QRect(ax, ay, awidth, aheight));
}

inline bool QPixmap::loadFromData(const QByteArray &buf, const char *format,
                                  Qt::ImageConversionFlags flags)
{
    return loadFromData(reinterpret_cast<const uchar *>(buf.constData()), buf.size(), format, flags);
}






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPixmap &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPixmap &);














typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;

class __declspec(dllimport) QBitmap : public QPixmap
{
public:
    QBitmap();
    QBitmap(const QPixmap &);
    QBitmap(int w, int h);
    explicit QBitmap(const QSize &);
    explicit QBitmap(const QString &fileName, const char *format=0);
    ~QBitmap();

    QBitmap &operator=(const QPixmap &);
    operator QVariant() const;

    inline void clear() { fill(Qt::color0); }

    static QBitmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);
    static QBitmap fromData(const QSize &size, const uchar *bits,
                            QImage::Format monoFormat = QImage::Format_MonoLSB);

    QBitmap transformed(const QMatrix &) const;









};
template <> inline bool qIsDetached<QBitmap>(QBitmap &t) { return t.isDetached(); }









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QIconPrivate;
class QIconEngine;

class __declspec(dllimport) QIcon
{
public:
    enum Mode { Normal, Disabled, Active };
    enum State { On, Off };

    QIcon();
    QIcon(const QPixmap &pixmap);
    QIcon(const QIcon &other);
    explicit QIcon(const QString &fileName);
    explicit QIcon(QIconEngine *engine);
    ~QIcon();
    QIcon &operator=(const QIcon &other);
    operator QVariant() const;

    QPixmap pixmap(const QSize &size, Mode mode = Normal, State state = Off) const;
    inline QPixmap pixmap(int w, int h, Mode mode = Normal, State state = Off) const
        { return pixmap(QSize(w, h), mode, state); }
    inline QPixmap pixmap(int extent, Mode mode = Normal, State state = Off) const
        { return pixmap(QSize(extent, extent), mode, state); }

    QSize actualSize(const QSize &size, Mode mode = Normal, State state = Off) const;

    void paint(QPainter *painter, const QRect &rect, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const;
    inline void paint(QPainter *painter, int x, int y, int w, int h, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const
        { paint(painter, QRect(x, y, w, h), alignment, mode, state); }

    bool isNull() const;
    bool isDetached() const;

    int serialNumber() const;

    void addPixmap(const QPixmap &pixmap, Mode mode = Normal, State state = Off);
    void addFile(const QString &fileName, const QSize &size = QSize(), Mode mode = Normal, State state = Off);

















private:
    QIconPrivate *d;
};

template <> inline bool qIsDetached<QIcon>(QIcon &t) { return t.isDetached(); }
template <> class QTypeInfo<QIcon> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QIcon)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QIcon"; } };

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QIconEngine
{
public:
    virtual ~QIconEngine();
    virtual void paint(QPainter *painter, const QRect &rect, QIcon::Mode mode, QIcon::State state) = 0;
    virtual QSize actualSize(const QSize &size, QIcon::Mode mode, QIcon::State state);
    virtual QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);

    virtual void addPixmap(const QPixmap &pixmap, QIcon::Mode mode, QIcon::State state);
    virtual void addFile(const QString &fileName, const QSize &size, QIcon::Mode mode, QIcon::State state);





};































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QIconEngine;

struct __declspec(dllimport) QIconEngineFactoryInterface : public QFactoryInterface
{
    virtual QIconEngine *create(const QString &filename) = 0;
};


template <> inline QIconEngineFactoryInterface *qobject_cast<QIconEngineFactoryInterface *>(QObject *object) { return reinterpret_cast<QIconEngineFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterface") : 0)); } template <> inline QIconEngineFactoryInterface *qobject_cast<QIconEngineFactoryInterface *>(const QObject *object) { return reinterpret_cast<QIconEngineFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterface") : 0)); }

class __declspec(dllimport) QIconEnginePlugin : public QObject, public QIconEngineFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QIconEnginePlugin(QObject *parent = 0);
    ~QIconEnginePlugin();

    virtual QStringList keys() const = 0;
    virtual QIconEngine *create(const QString &filename) = 0;
};

















































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QImage;
class QRect;
class QSize;
class QVariant;

class QImageIOHandlerPrivate;
class __declspec(dllimport) QImageIOHandler
{
    inline QImageIOHandlerPrivate* d_func() { return reinterpret_cast<QImageIOHandlerPrivate *>(d_ptr); } inline const QImageIOHandlerPrivate* d_func() const { return reinterpret_cast<const QImageIOHandlerPrivate *>(d_ptr); } friend class QImageIOHandlerPrivate;
public:
    QImageIOHandler();
    virtual ~QImageIOHandler();

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    virtual QByteArray name() const;

    virtual bool canRead() const = 0;
    virtual bool read(QImage *image) = 0;
    virtual bool write(const QImage &image);

    enum ImageOption {
        Size,
        ClipRect,
        Description,
        ScaledClipRect,
        ScaledSize,
        CompressionRatio,
        Gamma,
        Quality,
        Name,
        SubType,
        IncrementalReading,
        Endianness
    };
    virtual QVariant option(ImageOption option) const;
    virtual void setOption(ImageOption option, const QVariant &value);
    virtual bool supportsOption(ImageOption option) const;


    virtual bool jumpToNextImage();
    virtual bool jumpToImage(int imageNumber);
    virtual int loopCount() const;
    virtual int imageCount() const;
    virtual int nextImageDelay() const;
    virtual int currentImageNumber() const;
    virtual QRect currentImageRect() const;

protected:
    QImageIOHandler(QImageIOHandlerPrivate &dd);
    QImageIOHandlerPrivate *d_ptr;
};

struct __declspec(dllimport) QImageIOHandlerFactoryInterface : public QFactoryInterface
{
    virtual QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const = 0;
};


template <> inline QImageIOHandlerFactoryInterface *qobject_cast<QImageIOHandlerFactoryInterface *>(QObject *object) { return reinterpret_cast<QImageIOHandlerFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QImageIOHandlerFactoryInterface") : 0)); } template <> inline QImageIOHandlerFactoryInterface *qobject_cast<QImageIOHandlerFactoryInterface *>(const QObject *object) { return reinterpret_cast<QImageIOHandlerFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QImageIOHandlerFactoryInterface") : 0)); }

class __declspec(dllimport) QImageIOPlugin : public QObject, public QImageIOHandlerFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QImageIOPlugin(QObject *parent = 0);
    virtual ~QImageIOPlugin();

    enum Capability {
        CanRead = 0x1,
        CanWrite = 0x2,
        CanReadIncremental = 0x4
    };
    typedef QFlags<Capability> Capabilities;

    virtual Capabilities capabilities(QIODevice *device, const QByteArray &format) const = 0;
    virtual QStringList keys() const = 0;
    virtual QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const = 0;
};

inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QImageIOPlugin::Capabilities::enum_type f2) { return QFlags<QImageIOPlugin::Capabilities::enum_type>(f1) | f2; } inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QFlags<QImageIOPlugin::Capabilities::enum_type> f2) { return f2 | f1; }















































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QIODevice;
class QImage;
class QRect;
class QSize;

class QImageReaderPrivate;
class __declspec(dllimport) QImageReader
{
public:
    enum ImageReaderError {
        UnknownError,
        FileNotFoundError,
        DeviceError,
        UnsupportedFormatError,
        InvalidDataError
    };

    QImageReader();
    explicit QImageReader(QIODevice *device, const QByteArray &format = QByteArray());
    explicit QImageReader(const QString &fileName, const QByteArray &format = QByteArray());
    ~QImageReader();

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    QSize size() const;

    void setClipRect(const QRect &rect);
    QRect clipRect() const;

    void setScaledSize(const QSize &size);
    QSize scaledSize() const;

    void setScaledClipRect(const QRect &rect);
    QRect scaledClipRect() const;

    bool canRead() const;
    QImage read();

    bool jumpToNextImage();
    bool jumpToImage(int imageNumber);
    int loopCount() const;
    int imageCount() const;
    int nextImageDelay() const;
    int currentImageNumber() const;
    QRect currentImageRect() const;

    ImageReaderError error() const;
    QString errorString() const;

    static QByteArray imageFormat(const QString &fileName);
    static QByteArray imageFormat(QIODevice *device);
    static QList<QByteArray> supportedImageFormats();

private:
    QImageReader(const QImageReader &); QImageReader &operator=(const QImageReader &);
    QImageReaderPrivate *d;
};





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QIODevice;
class QImage;

class QImageWriterPrivate;
class __declspec(dllimport) QImageWriter
{
public:
    enum ImageWriterError {
        UnknownError,
        DeviceError,
        UnsupportedFormatError
    };

    QImageWriter();
    explicit QImageWriter(QIODevice *device, const QByteArray &format);
    explicit QImageWriter(const QString &fileName, const QByteArray &format = QByteArray());
    ~QImageWriter();

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    void setQuality(int quality);
    int quality() const;

    void setGamma(float gamma);
    float gamma() const;

    void setDescription(const QString &description);
    QString description() const;

    bool canWrite() const;
    bool write(const QImage &image);

    ImageWriterError error() const;
    QString errorString() const;

    static QList<QByteArray> supportedImageFormats();

private:
    QImageWriter(const QImageWriter &); QImageWriter &operator=(const QImageWriter &);
    QImageWriterPrivate *d;
};










































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QByteArray;
class QColor;
class QIODevice;
class QImage;
class QPixmap;
class QRect;
class QSize;

class QMoviePrivate;
class __declspec(dllimport) QMovie : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QMoviePrivate* d_func() { return reinterpret_cast<QMoviePrivate *>(d_ptr); } inline const QMoviePrivate* d_func() const { return reinterpret_cast<const QMoviePrivate *>(d_ptr); } friend class QMoviePrivate;
public:
    enum MovieState {
        NotRunning,
        Paused,
        Running
    };

    QMovie(QObject *parent = 0);
    explicit QMovie(QIODevice *device, const QByteArray &format = QByteArray(), QObject *parent = 0);
    explicit QMovie(const QString &fileName, const QByteArray &format = QByteArray(), QObject *parent = 0);
    ~QMovie();

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setBackgroundColor(const QColor &color);
    QColor backgroundColor() const;

    MovieState state() const;

    QRect frameRect() const;
    QImage currentImage() const;
    QPixmap currentPixmap() const;

    bool isValid() const;

    bool jumpToFrame(int frameNumber);
    int loopCount() const;
    int frameCount() const;
    int nextFrameDelay() const;
    int currentFrameNumber() const;

    void setSpeed(int percentSpeed);
    int speed() const;

protected:
    void started();
    void resized(const QSize &size);
    void updated(const QRect &rect);
    void stateChanged(QMovie::MovieState state);
    void error(QImageReader::ImageReaderError error);
    void finished();

public :
    void start();
    bool jumpToNextFrame();
    void setPaused(bool paused);
    void stop();

private:
    QMovie(const QMovie &); QMovie &operator=(const QMovie &);
















};























































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPicturePrivate;
class __declspec(dllimport) QPicture : public QPaintDevice
{
    inline QPicturePrivate* d_func() { return reinterpret_cast<QPicturePrivate *>(d_ptr); } inline const QPicturePrivate* d_func() const { return reinterpret_cast<const QPicturePrivate *>(d_ptr); } friend class QPicturePrivate;
public:
    explicit QPicture(int formatVersion = -1);
    QPicture(const QPicture &);
    ~QPicture();

    bool isNull() const;

    int devType() const;
    uint size() const;
    const char* data() const;
    virtual void setData(const char* data, uint size);

    bool play(QPainter *p);

    bool load(QIODevice *dev, const char *format = 0);
    bool load(const QString &fileName, const char *format = 0);
    bool save(QIODevice *dev, const char *format = 0);
    bool save(const QString &fileName, const char *format = 0);

    QRect boundingRect() const;
    void setBoundingRect(const QRect &r);

    QPicture& operator=(const QPicture &p);
    void detach();
    bool isDetached() const;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QPicture &p);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &in, QPicture &p);

    static const char* pictureFormat(const QString &fileName);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();
    static QStringList inputFormatList();
    static QStringList outputFormatList();

    QPaintEngine *paintEngine() const;

protected:
    QPicture(QPicturePrivate &data);

    int metric(PaintDeviceMetric m) const;




private:
    bool exec(QPainter *p, QDataStream &ds, int i);
    void detach_helper();

    QPicturePrivate *d_ptr;
    friend class QPicturePaintEngine;
    friend class Q3Picture;
};

template <> inline bool qIsDetached<QPicture>(QPicture &t) { return t.isDetached(); }



class QIODevice;
class QPictureIO;
typedef void (*picture_io_handler)(QPictureIO *);

struct QPictureIOData;

class __declspec(dllimport) QPictureIO
{
public:
    QPictureIO();
    QPictureIO(QIODevice *ioDevice, const char *format);
    QPictureIO(const QString &fileName, const char *format);
    ~QPictureIO();

    const QPicture &picture() const;
    int status() const;
    const char *format() const;
    QIODevice *ioDevice() const;
    QString fileName() const;
    int quality() const;
    QString description() const;
    const char *parameters() const;
    float gamma() const;

    void setPicture(const QPicture &);
    void setStatus(int);
    void setFormat(const char *);
    void setIODevice(QIODevice *);
    void setFileName(const QString &);
    void setQuality(int);
    void setDescription(const QString &);
    void setParameters(const char *);
    void setGamma(float);

    bool read();
    bool write();

    static QByteArray pictureFormat(const QString &fileName);
    static QByteArray pictureFormat(QIODevice *);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();

    static void defineIOHandler(const char *format,
                                const char *header,
                                const char *flags,
                                picture_io_handler read_picture,
                                picture_io_handler write_picture);

private:
    QPictureIO(const QPictureIO &); QPictureIO &operator=(const QPictureIO &);

    void init();

    QPictureIOData *d;
};








__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPicture &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPicture &);

































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPicture;
class QImage;
class QString;
class QStringList;

struct __declspec(dllimport) QPictureFormatInterface : public QFactoryInterface
{
    virtual bool loadPicture(const QString &format, const QString &filename, QPicture *) = 0;
    virtual bool savePicture(const QString &format, const QString &filename, const QPicture &) = 0;

    virtual bool installIOHandler(const QString &) = 0;
};


template <> inline QPictureFormatInterface *qobject_cast<QPictureFormatInterface *>(QObject *object) { return reinterpret_cast<QPictureFormatInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QPictureFormatInterface") : 0)); } template <> inline QPictureFormatInterface *qobject_cast<QPictureFormatInterface *>(const QObject *object) { return reinterpret_cast<QPictureFormatInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QPictureFormatInterface") : 0)); }


class __declspec(dllimport) QPictureFormatPlugin : public QObject, public QPictureFormatInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QPictureFormatPlugin(QObject *parent = 0);
    ~QPictureFormatPlugin();

    virtual QStringList keys() const = 0;
    virtual bool loadPicture(const QString &format, const QString &filename, QPicture *pic);
    virtual bool savePicture(const QString &format, const QString &filename, const QPicture &pic);
    virtual bool installIOHandler(const QString &format) = 0;

};
























































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QPixmapCache
{
public:
    static int cacheLimit();
    static void setCacheLimit(int);
    static QPixmap *find(const QString &key);
    static bool find(const QString &key, QPixmap&);
    static bool insert(const QString &key, const QPixmap&);
    static void remove(const QString &key);
    static void clear();
};






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QMenu;
class QActionGroup;
class QActionPrivate;

class __declspec(dllimport) QAction : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QActionPrivate* d_func() { return reinterpret_cast<QActionPrivate *>(d_ptr); } inline const QActionPrivate* d_func() const { return reinterpret_cast<const QActionPrivate *>(d_ptr); } friend class QActionPrivate;

















public:
    explicit QAction(QObject* parent);
    QAction(const QString &text, QObject* parent);
    QAction(const QIcon &icon, const QString &text, QObject* parent);









    ~QAction();

    void setActionGroup(QActionGroup *group);
    QActionGroup *actionGroup() const;
    void setIcon(const QIcon &icon);
    QIcon icon() const;

    void setText(const QString &text);
    QString text() const;

    void setIconText(const QString &text);
    QString iconText() const;

    void setToolTip(const QString &tip);
    QString toolTip() const;

    void setStatusTip(const QString &statusTip);
    QString statusTip() const;

    void setWhatsThis(const QString &what);
    QString whatsThis() const;


    QMenu *menu() const;
    void setMenu(QMenu *menu);


    void setSeparator(bool b);
    bool isSeparator() const;


    void setShortcut(const QKeySequence &shortcut);
    QKeySequence shortcut() const;

    void setShortcutContext(Qt::ShortcutContext context);
    Qt::ShortcutContext shortcutContext() const;


    void setFont(const QFont &font);
    QFont font() const;

    void setCheckable(bool);
    bool isCheckable() const;

    QVariant data() const;
    void setData(const QVariant &var);

    bool isChecked() const;

    bool isEnabled() const;

    bool isVisible() const;

    enum ActionEvent { Trigger, Hover };
    void activate(ActionEvent event);
    bool showStatusText(QWidget *widget=0);















    QWidget *parentWidget() const;

protected:
    bool event(QEvent *);

public :



    void trigger() { activate(Trigger); }
    void hover() { activate(Hover); }
    void setChecked(bool);
    void toggle();
    void setEnabled(bool);
    inline void setDisabled(bool b) { setEnabled(!b); }
    void setVisible(bool);

protected:
    void changed();
    void triggered(bool checked = false);
    void hovered();
    void toggled(bool);




private:
    QAction(const QAction &); QAction &operator=(const QAction &);




    friend class QWidget;
    friend class QActionGroup;
    friend class QMenu;
    friend class QMenuBar;
    friend class QShortcutMap;
};









































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QActionGroupPrivate;

class __declspec(dllimport) QActionGroup : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QActionGroupPrivate* d_func() { return reinterpret_cast<QActionGroupPrivate *>(d_ptr); } inline const QActionGroupPrivate* d_func() const { return reinterpret_cast<const QActionGroupPrivate *>(d_ptr); } friend class QActionGroupPrivate;





public:
    explicit QActionGroup(QObject* parent);
    ~QActionGroup();

    QAction *addAction(QAction* a);
    QAction *addAction(const QString &text);
    QAction *addAction(const QIcon &icon, const QString &text);
    void removeAction(QAction *a);
    QList<QAction*> actions() const;

    QAction *checkedAction() const;
    bool isExclusive() const;
    bool isEnabled() const;
    bool isVisible() const;








public :
    void setEnabled(bool);
    inline void setDisabled(bool b) { setEnabled(!b); }
    void setVisible(bool);
    void setExclusive(bool);

protected:
    void triggered(QAction *);
     void selected(QAction *);
    void hovered(QAction *);

private:
    QActionGroup(const QActionGroup &); QActionGroup &operator=(const QActionGroup &);



};













typedef QtValidLicenseForGuiModule QtGuiModule;

class QWidget;
class QFont;
class QPopupMenu;
class QInputContextPrivate;


class __declspec(dllimport) QInputContext : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QInputContextPrivate* d_func() { return reinterpret_cast<QInputContextPrivate *>(d_ptr); } inline const QInputContextPrivate* d_func() const { return reinterpret_cast<const QInputContextPrivate *>(d_ptr); } friend class QInputContextPrivate;
public:
    explicit QInputContext(QObject* parent = 0);
    virtual ~QInputContext();

    virtual QString identifierName() = 0;
    virtual QString language() = 0;

    virtual void reset() = 0;
    virtual void update();

    virtual void mouseHandler( int x, QMouseEvent *event);
    virtual QFont font() const;
    virtual bool isComposing() const = 0;

    QWidget *focusWidget() const;
    virtual void setFocusWidget( QWidget *w );

    virtual void widgetDestroyed(QWidget *w);

    virtual QList<QAction *> actions();




    virtual bool filterEvent( const QEvent *event );

    void sendEvent(const QInputMethodEvent &event);

    enum StandardFormat {
        PreeditFormat,
        SelectionFormat
    };
    QTextFormat standardFormat(StandardFormat s) const;
private:
    friend class QWidget;
    friend class QInputContextFactory;
    friend class QApplication;

private:
    QInputContext( const QInputContext & );
    QInputContext &operator=( const QInputContext & );

};
























































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QInputContext;
class QWidget;

class __declspec(dllimport) QInputContextFactory
{
public:
    static QStringList keys();
    static QInputContext *create( const QString &key, QObject *parent );
    static QStringList languages( const QString &key );
    static QString displayName( const QString &key );
    static QString description( const QString &key );
};































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QInputContext;
class QInputContextPluginPrivate;

struct __declspec(dllimport) QInputContextFactoryInterface : public QFactoryInterface
{
    virtual QInputContext *create( const QString &key ) = 0;
    virtual QStringList languages( const QString &key ) = 0;
    virtual QString displayName( const QString &key ) = 0;
    virtual QString description( const QString &key ) = 0;
};


template <> inline QInputContextFactoryInterface *qobject_cast<QInputContextFactoryInterface *>(QObject *object) { return reinterpret_cast<QInputContextFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QInputContextFactoryInterface") : 0)); } template <> inline QInputContextFactoryInterface *qobject_cast<QInputContextFactoryInterface *>(const QObject *object) { return reinterpret_cast<QInputContextFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QInputContextFactoryInterface") : 0)); }

class __declspec(dllimport) QInputContextPlugin : public QObject, public QInputContextFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QInputContextPlugin(QObject *parent = 0);
    ~QInputContextPlugin();

    virtual QStringList keys() const = 0;
    virtual QInputContext *create( const QString &key ) = 0;
    virtual QStringList languages( const QString &key ) = 0;
    virtual QString displayName( const QString &key ) = 0;
    virtual QString description( const QString &key ) = 0;
};

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;




class __declspec(dllimport) QValidator : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QValidator(QObject * parent);
    ~QValidator();

    enum State {
        Invalid,
        Intermediate,



        Acceptable
    };

    virtual State validate(QString &, int &) const = 0;
    virtual void fixup(QString &) const;






private:
    QValidator(const QValidator &); QValidator &operator=(const QValidator &);
};

class __declspec(dllimport) QIntValidator : public QValidator
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QIntValidator(QObject * parent);
    QIntValidator(int bottom, int top, QObject * parent);
    ~QIntValidator();

    QValidator::State validate(QString &, int &) const;

    void setBottom(int);
    void setTop(int);
    virtual void setRange(int bottom, int top);

    int bottom() const { return b; }
    int top() const { return t; }







private:
    QIntValidator(const QIntValidator &); QIntValidator &operator=(const QIntValidator &);

    int b;
    int t;
};



class __declspec(dllimport) QDoubleValidator : public QValidator
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




public:
    explicit QDoubleValidator(QObject * parent);
    QDoubleValidator(double bottom, double top, int decimals, QObject * parent);
    ~QDoubleValidator();

    QValidator::State validate(QString &, int &) const;

    virtual void setRange(double bottom, double top, int decimals = 0);
    void setBottom(double);
    void setTop(double);
    void setDecimals(int);

    double bottom() const { return b; }
    double top() const { return t; }
    int decimals() const { return d; }







private:
    QDoubleValidator(const QDoubleValidator &); QDoubleValidator &operator=(const QDoubleValidator &);

    double b;
    double t;
    int d;
};


class __declspec(dllimport) QRegExpValidator : public QValidator
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QRegExpValidator(QObject *parent);
    QRegExpValidator(const QRegExp& rx, QObject *parent);
    ~QRegExpValidator();

    virtual QValidator::State validate(QString& input, int& pos) const;

    void setRegExp(const QRegExp& rx);
    const QRegExp& regExp() const { return r; }







private:
    QRegExpValidator(const QRegExpValidator &); QRegExpValidator &operator=(const QRegExpValidator &);

    QRegExp r;
};









typedef QtValidLicenseForGuiModule QtGuiModule;



class QLineEdit;

class QAbstractSpinBoxPrivate;
class __declspec(dllimport) QAbstractSpinBox : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:










public:
    explicit QAbstractSpinBox(QWidget *parent = 0);
    ~QAbstractSpinBox();

    enum StepEnabledFlag { StepNone = 0x00, StepUpEnabled = 0x01,
                           StepDownEnabled = 0x02 };
    typedef QFlags<StepEnabledFlag> StepEnabled;

    enum ButtonSymbols { UpDownArrows, PlusMinus };

    ButtonSymbols buttonSymbols() const;
    void setButtonSymbols(ButtonSymbols bs);

    QString text() const;

    QString specialValueText() const;
    void setSpecialValueText(const QString &s);

    bool wrapping() const;
    void setWrapping(bool w);

    void setReadOnly(bool r);
    bool isReadOnly() const;

    void setAlignment(Qt::Alignment flag);
    Qt::Alignment alignment() const;

    void setFrame(bool);
    bool hasFrame() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void interpretText();
    bool event(QEvent *event);

    virtual QValidator::State validate(QString &input, int &pos) const;
    virtual void fixup(QString &input) const;

    virtual void stepBy(int steps);
public :
    void stepUp();
    void stepDown();
    void selectAll();
    virtual void clear();

protected:
    void resizeEvent(QResizeEvent *e);
    void keyPressEvent(QKeyEvent *e);
    void keyReleaseEvent(QKeyEvent *e);
    void wheelEvent(QWheelEvent *e);
    void focusInEvent(QFocusEvent *e);
    void focusOutEvent(QFocusEvent *e);
    void contextMenuEvent(QContextMenuEvent *e);
    void changeEvent(QEvent *e);
    void closeEvent(QCloseEvent *e);
    void hideEvent(QHideEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void mouseMoveEvent(QMouseEvent *e);
    void timerEvent(QTimerEvent *e);
    void paintEvent(QPaintEvent *e);
    void showEvent(QShowEvent *e);

    QLineEdit *lineEdit() const;
    void setLineEdit(QLineEdit *e);

    virtual StepEnabled stepEnabled() const;
protected:
    void editingFinished();
protected:
    QAbstractSpinBox(QAbstractSpinBoxPrivate &dd, QWidget *parent = 0);

private:



    inline QAbstractSpinBoxPrivate* d_func() { return reinterpret_cast<QAbstractSpinBoxPrivate *>(d_ptr); } inline const QAbstractSpinBoxPrivate* d_func() const { return reinterpret_cast<const QAbstractSpinBoxPrivate *>(d_ptr); } friend class QAbstractSpinBoxPrivate;
    QAbstractSpinBox(const QAbstractSpinBox &); QAbstractSpinBox &operator=(const QAbstractSpinBox &);
};
inline QFlags<QAbstractSpinBox::StepEnabled::enum_type> operator|(QAbstractSpinBox::StepEnabled::enum_type f1, QAbstractSpinBox::StepEnabled::enum_type f2) { return QFlags<QAbstractSpinBox::StepEnabled::enum_type>(f1) | f2; } inline QFlags<QAbstractSpinBox::StepEnabled::enum_type> operator|(QAbstractSpinBox::StepEnabled::enum_type f1, QFlags<QAbstractSpinBox::StepEnabled::enum_type> f2) { return f2 | f1; }











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractSliderPrivate;

class __declspec(dllimport) QAbstractSlider : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:













public:
    explicit QAbstractSlider(QWidget *parent=0);
    ~QAbstractSlider();

    Qt::Orientation orientation() const;

    void setMinimum(int);
    int minimum() const;

    void setMaximum(int);
    int maximum() const;

    void setRange(int min, int max);

    void setSingleStep(int);
    int singleStep() const;

    void setPageStep(int);
    int pageStep() const;

    void setTracking(bool enable);
    bool hasTracking() const;

    void setSliderDown(bool);
    bool isSliderDown() const;

    void setSliderPosition(int);
    int sliderPosition() const;

    void setInvertedAppearance(bool);
    bool invertedAppearance() const;

    void setInvertedControls(bool);
    bool invertedControls() const;

    enum SliderAction {
        SliderNoAction,
        SliderSingleStepAdd,
        SliderSingleStepSub,
        SliderPageStepAdd,
        SliderPageStepSub,
        SliderToMinimum,
        SliderToMaximum,
        SliderMove
    };

    int value() const;

    void triggerAction(SliderAction action);

public :
    void setValue(int);
    void setOrientation(Qt::Orientation);

protected:
    void valueChanged(int value);

    void sliderPressed();
    void sliderMoved(int position);
    void sliderReleased();

    void rangeChanged(int min, int max);

    void actionTriggered(int action);

protected:
    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
    SliderAction repeatAction() const;

    enum SliderChange {
        SliderRangeChange,
        SliderOrientationChange,
        SliderStepsChange,
        SliderValueChange
    };
    virtual void sliderChange(SliderChange change);

    void keyPressEvent(QKeyEvent *ev);
    void timerEvent(QTimerEvent *);

    void wheelEvent(QWheelEvent *e);

    void changeEvent(QEvent *e);
















protected:
    QAbstractSlider(QAbstractSliderPrivate &dd, QWidget *parent=0);

private:
    QAbstractSlider(const QAbstractSlider &); QAbstractSlider &operator=(const QAbstractSlider &);
    inline QAbstractSliderPrivate* d_func() { return reinterpret_cast<QAbstractSliderPrivate *>(d_ptr); } inline const QAbstractSliderPrivate* d_func() const { return reinterpret_cast<const QAbstractSliderPrivate *>(d_ptr); } friend class QAbstractSliderPrivate;
};





typedef QtValidLicenseForGuiModule QtGuiModule;



class QSliderPrivate;

class __declspec(dllimport) QSlider : public QAbstractSlider
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:





public:
    enum TickPosition {
        NoTicks = 0,
        TicksAbove = 1,
        TicksLeft = TicksAbove,
        TicksBelow = 2,
        TicksRight = TicksBelow,
        TicksBothSides = 3









    };

    explicit QSlider(QWidget *parent = 0);
    explicit QSlider(Qt::Orientation orientation, QWidget *parent = 0);

    ~QSlider();

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setTickPosition(TickPosition position);
    TickPosition tickPosition() const;

    void setTickInterval(int ti);
    int tickInterval() const;

    bool event(QEvent *event);

protected:
    void paintEvent(QPaintEvent *ev);
    void mousePressEvent(QMouseEvent *ev);
    void mouseReleaseEvent(QMouseEvent *ev);
    void mouseMoveEvent(QMouseEvent *ev);















private:
    QSlider(const QSlider &); QSlider &operator=(const QSlider &);
    inline QSliderPrivate* d_func() { return reinterpret_cast<QSliderPrivate *>(d_ptr); } inline const QSliderPrivate* d_func() const { return reinterpret_cast<const QSliderPrivate *>(d_ptr); } friend class QSliderPrivate;
};












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QAction;
class QDebug;
class QTab;
class QFontMetrics;

class QStyleHintReturn;
class QStyleOption;
class QStyleOptionComplex;
class __declspec(dllimport) QStyle : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QStyle();
    virtual ~QStyle();

    virtual void polish(QWidget *);
    virtual void unpolish(QWidget *);

    virtual void polish(QApplication *);
    virtual void unpolish(QApplication *);

    virtual void polish(QPalette &);

    virtual QRect itemTextRect(const QFontMetrics &fm, const QRect &r,
                           int flags, bool enabled,
                           const QString &text) const;

    virtual QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;

    virtual void drawItemText(QPainter *painter, const QRect &rect,
                              int flags, const QPalette &pal, bool enabled,
                              const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;

    virtual void drawItemPixmap(QPainter *painter, const QRect &rect,
                                int alignment, const QPixmap &pixmap) const;

    virtual QPalette standardPalette() const;

    enum StateFlag {
        State_None    =       0x00000000,



        State_Enabled =       0x00000001,
        State_Raised =        0x00000002,
        State_Sunken =        0x00000004,
        State_Off =           0x00000008,
        State_NoChange =      0x00000010,
        State_On =            0x00000020,
        State_DownArrow =     0x00000040,
        State_Horizontal =    0x00000080,
        State_HasFocus =      0x00000100,
        State_Top =           0x00000200,
        State_Bottom =        0x00000400,
        State_FocusAtBorder = 0x00000800,
        State_AutoRaise =     0x00001000,
        State_MouseOver =     0x00002000,
        State_UpArrow =       0x00004000,
        State_Selected =      0x00008000,
        State_Active =        0x00010000,
        State_Open =          0x00040000,
        State_Children =      0x00080000,
        State_Item =          0x00100000,
        State_Sibling =       0x00200000,
        State_Editing =       0x00400000,
        State_KeyboardFocusChange = 0x00800000



    };
    typedef QFlags<StateFlag> State;





    enum PrimitiveElement {
        PE_Q3CheckListController,
        PE_Q3CheckListExclusiveIndicator,
        PE_Q3CheckListIndicator,
        PE_Q3DockWindowSeparator,
        PE_Q3Separator,

        PE_Frame,
        PE_FrameDefaultButton,
        PE_FrameDockWidget,
        PE_FrameFocusRect,
        PE_FrameGroupBox,
        PE_FrameLineEdit,
        PE_FrameMenu,
        PE_FrameStatusBar,
        PE_FrameTabWidget,
        PE_FrameWindow,
        PE_FrameButtonBevel,
        PE_FrameButtonTool,
        PE_FrameTabBarBase,

        PE_PanelButtonCommand,
        PE_PanelButtonBevel,
        PE_PanelButtonTool,
        PE_PanelMenuBar,
        PE_PanelToolBar,
        PE_PanelLineEdit,

        PE_IndicatorArrowDown,
        PE_IndicatorArrowLeft,
        PE_IndicatorArrowRight,
        PE_IndicatorArrowUp,
        PE_IndicatorBranch,
        PE_IndicatorButtonDropDown,
        PE_IndicatorViewItemCheck,
        PE_IndicatorCheckBox,
        PE_IndicatorDockWidgetResizeHandle,
        PE_IndicatorHeaderArrow,
        PE_IndicatorMenuCheckMark,
        PE_IndicatorProgressChunk,
        PE_IndicatorRadioButton,
        PE_IndicatorSpinDown,
        PE_IndicatorSpinMinus,
        PE_IndicatorSpinPlus,
        PE_IndicatorSpinUp,
        PE_IndicatorToolBarHandle,
        PE_IndicatorToolBarSeparator,
        PE_PanelTipLabel,
        PE_IndicatorTabTear,


        PE_CustomBase = 0xf000000
    };

    virtual void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
                               const QWidget *w = 0) const = 0;
    enum ControlElement {
        CE_PushButton,
        CE_PushButtonBevel,
        CE_PushButtonLabel,

        CE_CheckBox,
        CE_CheckBoxLabel,

        CE_RadioButton,
        CE_RadioButtonLabel,

        CE_TabBarTab,
        CE_TabBarTabShape,
        CE_TabBarTabLabel,

        CE_ProgressBar,
        CE_ProgressBarGroove,
        CE_ProgressBarContents,
        CE_ProgressBarLabel,

        CE_MenuItem,
        CE_MenuScroller,
        CE_MenuVMargin,
        CE_MenuHMargin,
        CE_MenuTearoff,
        CE_MenuEmptyArea,

        CE_MenuBarItem,
        CE_MenuBarEmptyArea,

        CE_ToolButtonLabel,

        CE_Header,
        CE_HeaderSection,
        CE_HeaderLabel,

        CE_Q3DockWindowEmptyArea,
        CE_ToolBoxTab,
        CE_SizeGrip,
        CE_Splitter,
        CE_RubberBand,
        CE_DockWidgetTitle,

        CE_ScrollBarAddLine,
        CE_ScrollBarSubLine,
        CE_ScrollBarAddPage,
        CE_ScrollBarSubPage,
        CE_ScrollBarSlider,
        CE_ScrollBarFirst,
        CE_ScrollBarLast,

        CE_FocusFrame,
        CE_ComboBoxLabel,


        CE_CustomBase = 0xf0000000
    };

    virtual void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
                             const QWidget *w = 0) const = 0;

    enum SubElement {
        SE_PushButtonContents,
        SE_PushButtonFocusRect,

        SE_CheckBoxIndicator,
        SE_CheckBoxContents,
        SE_CheckBoxFocusRect,
        SE_CheckBoxClickRect,

        SE_RadioButtonIndicator,
        SE_RadioButtonContents,
        SE_RadioButtonFocusRect,
        SE_RadioButtonClickRect,

        SE_ComboBoxFocusRect,

        SE_SliderFocusRect,

        SE_Q3DockWindowHandleRect,

        SE_ProgressBarGroove,
        SE_ProgressBarContents,
        SE_ProgressBarLabel,


        SE_DialogButtonAccept,
        SE_DialogButtonReject,
        SE_DialogButtonApply,
        SE_DialogButtonHelp,
        SE_DialogButtonAll,
        SE_DialogButtonAbort,
        SE_DialogButtonIgnore,
        SE_DialogButtonRetry,
        SE_DialogButtonCustom,

        SE_ToolBoxTabContents,

        SE_HeaderLabel,
        SE_HeaderArrow,

        SE_TabWidgetTabBar,
        SE_TabWidgetTabPane,
        SE_TabWidgetTabContents,
        SE_TabWidgetLeftCorner,
        SE_TabWidgetRightCorner,

        SE_ViewItemCheckIndicator,

        SE_TabBarTearIndicator,


        SE_CustomBase = 0xf0000000
    };

    virtual QRect subElementRect(SubElement subElement, const QStyleOption *option,
                                 const QWidget *widget = 0) const = 0;


    enum ComplexControl {
        CC_SpinBox,
        CC_ComboBox,
        CC_ScrollBar,
        CC_Slider,
        CC_ToolButton,
        CC_TitleBar,
        CC_Q3ListView,
        CC_Dial,


        CC_CustomBase = 0xf0000000
    };

    enum SubControl {
        SC_None =                  0x00000000,

        SC_ScrollBarAddLine =      0x00000001,
        SC_ScrollBarSubLine =      0x00000002,
        SC_ScrollBarAddPage =      0x00000004,
        SC_ScrollBarSubPage =      0x00000008,
        SC_ScrollBarFirst =        0x00000010,
        SC_ScrollBarLast =         0x00000020,
        SC_ScrollBarSlider =       0x00000040,
        SC_ScrollBarGroove =       0x00000080,

        SC_SpinBoxUp =             0x00000001,
        SC_SpinBoxDown =           0x00000002,
        SC_SpinBoxFrame =          0x00000004,
        SC_SpinBoxEditField =      0x00000008,

        SC_ComboBoxFrame =         0x00000001,
        SC_ComboBoxEditField =     0x00000002,
        SC_ComboBoxArrow =         0x00000004,
        SC_ComboBoxListBoxPopup =  0x00000008,

        SC_SliderGroove =          0x00000001,
        SC_SliderHandle =          0x00000002,
        SC_SliderTickmarks =       0x00000004,

        SC_ToolButton =            0x00000001,
        SC_ToolButtonMenu =        0x00000002,

        SC_TitleBarSysMenu =       0x00000001,
        SC_TitleBarMinButton =     0x00000002,
        SC_TitleBarMaxButton =     0x00000004,
        SC_TitleBarCloseButton =   0x00000008,
        SC_TitleBarNormalButton =  0x00000010,
        SC_TitleBarShadeButton =   0x00000020,
        SC_TitleBarUnshadeButton = 0x00000040,
        SC_TitleBarContextHelpButton = 0x00000080,
        SC_TitleBarLabel =         0x00000100,

        SC_Q3ListView =            0x00000001,
        SC_Q3ListViewBranch =      0x00000002,
        SC_Q3ListViewExpand =      0x00000004,

        SC_DialGroove =            0x00000001,
        SC_DialHandle =            0x00000002,
        SC_DialTickmarks =         0x00000004,

        SC_All =                   0xffffffff
    };
    typedef QFlags<SubControl> SubControls;





    virtual void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
                                    const QWidget *widget = 0) const = 0;
    virtual SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
                                             const QPoint &pt, const QWidget *widget = 0) const = 0;
    virtual QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
                                 SubControl sc, const QWidget *widget = 0) const = 0;

    enum PixelMetric {
        PM_ButtonMargin,
        PM_ButtonDefaultIndicator,
        PM_MenuButtonIndicator,
        PM_ButtonShiftHorizontal,
        PM_ButtonShiftVertical,

        PM_DefaultFrameWidth,
        PM_SpinBoxFrameWidth,
        PM_ComboBoxFrameWidth,

        PM_MaximumDragDistance,

        PM_ScrollBarExtent,
        PM_ScrollBarSliderMin,

        PM_SliderThickness,
        PM_SliderControlThickness,
        PM_SliderLength,
        PM_SliderTickmarkOffset,
        PM_SliderSpaceAvailable,

        PM_DockWidgetSeparatorExtent,
        PM_DockWidgetHandleExtent,
        PM_DockWidgetFrameWidth,

        PM_TabBarTabOverlap,
        PM_TabBarTabHSpace,
        PM_TabBarTabVSpace,
        PM_TabBarBaseHeight,
        PM_TabBarBaseOverlap,

        PM_ProgressBarChunkWidth,

        PM_SplitterWidth,
        PM_TitleBarHeight,

        PM_MenuScrollerHeight,
        PM_MenuHMargin,
        PM_MenuVMargin,
        PM_MenuPanelWidth,
        PM_MenuTearoffHeight,
        PM_MenuDesktopFrameWidth,

        PM_MenuBarPanelWidth,
        PM_MenuBarItemSpacing,
        PM_MenuBarVMargin,
        PM_MenuBarHMargin,

        PM_IndicatorWidth,
        PM_IndicatorHeight,
        PM_ExclusiveIndicatorWidth,
        PM_ExclusiveIndicatorHeight,
        PM_CheckListButtonSize,
        PM_CheckListControllerSize,

        PM_DialogButtonsSeparator,
        PM_DialogButtonsButtonWidth,
        PM_DialogButtonsButtonHeight,

        PM_MDIFrameWidth,
        PM_MDIMinimizedWidth,
        PM_HeaderMargin,
        PM_HeaderMarkSize,
        PM_HeaderGripMargin,
        PM_TabBarTabShiftHorizontal,
        PM_TabBarTabShiftVertical,
        PM_TabBarScrollButtonWidth,

        PM_ToolBarFrameWidth,
        PM_ToolBarHandleExtent,
        PM_ToolBarItemSpacing,
        PM_ToolBarItemMargin,
        PM_ToolBarSeparatorExtent,
        PM_ToolBarExtensionExtent,

        PM_SpinBoxSliderHeight,

        PM_DefaultTopLevelMargin,
        PM_DefaultChildMargin,
        PM_DefaultLayoutSpacing,

        PM_ToolBarIconSize,
        PM_ListViewIconSize,
        PM_IconViewIconSize,
        PM_SmallIconSize,
        PM_LargeIconSize,

        PM_FocusFrameVMargin,
        PM_FocusFrameHMargin,

        PM_ToolTipLabelFrameWidth,



        PM_CustomBase = 0xf0000000
    };

    virtual int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
                            const QWidget *widget = 0) const = 0;

    enum ContentsType {
        CT_PushButton,
        CT_CheckBox,
        CT_RadioButton,
        CT_ToolButton,
        CT_ComboBox,
        CT_Splitter,
        CT_Q3DockWindow,
        CT_ProgressBar,
        CT_MenuItem,
        CT_MenuBarItem,
        CT_MenuBar,
        CT_Menu,
        CT_TabBarTab,
        CT_Slider,
        CT_ScrollBar,
        CT_Q3Header,
        CT_LineEdit,
        CT_SpinBox,
        CT_SizeGrip,
        CT_TabWidget,
        CT_DialogButtons,
        CT_HeaderSection,

        CT_CustomBase = 0xf0000000
    };

    virtual QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
                                   const QSize &contentsSize, const QWidget *w = 0) const = 0;

    enum StyleHint {
        SH_EtchDisabledText,
        SH_DitherDisabledText,
        SH_ScrollBar_MiddleClickAbsolutePosition,
        SH_ScrollBar_ScrollWhenPointerLeavesControl,
        SH_TabBar_SelectMouseType,
        SH_TabBar_Alignment,
        SH_Header_ArrowAlignment,
        SH_Slider_SnapToValue,
        SH_Slider_SloppyKeyEvents,
        SH_ProgressDialog_CenterCancelButton,
        SH_ProgressDialog_TextLabelAlignment,
        SH_PrintDialog_RightAlignButtons,
        SH_MainWindow_SpaceBelowMenuBar,
        SH_FontDialog_SelectAssociatedText,
        SH_Menu_AllowActiveAndDisabled,
        SH_Menu_SpaceActivatesItem,
        SH_Menu_SubMenuPopupDelay,
        SH_ScrollView_FrameOnlyAroundContents,
        SH_MenuBar_AltKeyNavigation,
        SH_ComboBox_ListMouseTracking,
        SH_Menu_MouseTracking,
        SH_MenuBar_MouseTracking,
        SH_ItemView_ChangeHighlightOnFocus,
        SH_Widget_ShareActivation,
        SH_Workspace_FillSpaceOnMaximize,
        SH_ComboBox_Popup,
        SH_TitleBar_NoBorder,
        SH_ScrollBar_StopMouseOverSlider,
        SH_BlinkCursorWhenTextSelected,
        SH_RichText_FullWidthSelection,
        SH_Menu_Scrollable,
        SH_GroupBox_TextLabelVerticalAlignment,
        SH_GroupBox_TextLabelColor,
        SH_Menu_SloppySubMenus,
        SH_Table_GridLineColor,
        SH_LineEdit_PasswordCharacter,
        SH_DialogButtons_DefaultButton,
        SH_ToolBox_SelectedPageTitleBold,
        SH_TabBar_PreferNoArrows,
        SH_ScrollBar_LeftClickAbsolutePosition,
        SH_Q3ListViewExpand_SelectMouseType,
        SH_UnderlineShortcut,
        SH_SpinBox_AnimateButton,
        SH_SpinBox_KeyPressAutoRepeatRate,
        SH_SpinBox_ClickAutoRepeatRate,
        SH_Menu_FillScreenWithScroll,
        SH_ToolTipLabel_Opacity,
        SH_DrawMenuBarSeparator,
        SH_TitleBar_ModifyNotification,
        SH_Button_FocusPolicy,
        SH_MenuBar_DismissOnSecondClick,
        SH_MessageBox_UseBorderForButtonSpacing,
        SH_TitleBar_AutoRaise,
        SH_ToolButton_PopupDelay,
        SH_FocusFrame_Mask,
        SH_RubberBand_Mask,
	SH_WindowFrame_Mask,
        SH_SpinControls_DisableOnBounds,
        SH_Dial_BackgroundRole,
        SH_ComboBox_LayoutDirection,
        SH_ItemView_EllipsisLocation,
        SH_ItemView_ShowDecorationSelected,
        SH_ItemView_ActivateItemOnSingleClick,









        SH_CustomBase = 0xf0000000
    };

    virtual int styleHint(StyleHint stylehint, const QStyleOption *opt = 0,
                          const QWidget *widget = 0, QStyleHintReturn* returnData = 0) const = 0;

    enum StandardPixmap {
        SP_TitleBarMenuButton,
        SP_TitleBarMinButton,
        SP_TitleBarMaxButton,
        SP_TitleBarCloseButton,
        SP_TitleBarNormalButton,
        SP_TitleBarShadeButton,
        SP_TitleBarUnshadeButton,
        SP_TitleBarContextHelpButton,
        SP_DockWidgetCloseButton,
        SP_MessageBoxInformation,
        SP_MessageBoxWarning,
        SP_MessageBoxCritical,
        SP_MessageBoxQuestion,
        SP_DesktopIcon,
        SP_TrashIcon,
        SP_ComputerIcon,
        SP_DriveFDIcon,
        SP_DriveHDIcon,
        SP_DriveCDIcon,
        SP_DriveDVDIcon,
        SP_DriveNetIcon,
        SP_DirOpenIcon,
        SP_DirClosedIcon,
        SP_DirLinkIcon,
        SP_FileIcon,
        SP_FileLinkIcon,
        SP_ToolBarHorizontalExtensionButton,
        SP_ToolBarVerticalExtensionButton,
        SP_FileDialogStart,
        SP_FileDialogEnd,
        SP_FileDialogToParent,
        SP_FileDialogNewFolder,
        SP_FileDialogDetailedView,
        SP_FileDialogInfoView,
        SP_FileDialogContentsView,
        SP_FileDialogListView,
        SP_FileDialogBack,


        SP_CustomBase = 0xf0000000
    };

    virtual QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt = 0,
                                   const QWidget *widget = 0) const = 0;

    QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *option = 0,
                       const QWidget *widget = 0) const;

    virtual QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
                                        const QStyleOption *opt) const = 0;

    static QRect visualRect(Qt::LayoutDirection direction, const QRect &boundingRect,
                            const QRect &logicalRect);
    static QPoint visualPos(Qt::LayoutDirection direction, const QRect &boundingRect,
                            const QPoint &logicalPos);
    static int sliderPositionFromValue(int min, int max, int val, int space,
                                       bool upsideDown = false);
    static int sliderValueFromPosition(int min, int max, int pos, int space,
                                       bool upsideDown = false);
    static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
    static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
                             const QSize &size, const QRect &rectangle);

protected :
    QIcon standardIconSlot(StandardPixmap standardIcon, const QStyleOption *opt = 0,
                           const QWidget *widget = 0) const;

private:
    QStyle(const QStyle &); QStyle &operator=(const QStyle &);
};

inline QFlags<QStyle::State::enum_type> operator|(QStyle::State::enum_type f1, QStyle::State::enum_type f2) { return QFlags<QStyle::State::enum_type>(f1) | f2; } inline QFlags<QStyle::State::enum_type> operator|(QStyle::State::enum_type f1, QFlags<QStyle::State::enum_type> f2) { return f2 | f1; }
inline QFlags<QStyle::SubControls::enum_type> operator|(QStyle::SubControls::enum_type f1, QStyle::SubControls::enum_type f2) { return QFlags<QStyle::SubControls::enum_type>(f1) | f2; } inline QFlags<QStyle::SubControls::enum_type> operator|(QStyle::SubControls::enum_type f1, QFlags<QStyle::SubControls::enum_type> f2) { return f2 | f1; }


__declspec(dllimport) QDebug operator<<(QDebug debug, QStyle::State state);






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QIcon;
class QTabBarPrivate;

class __declspec(dllimport) QTabBar: public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:







public:
    explicit QTabBar(QWidget* parent=0);
    ~QTabBar();

    enum Shape { RoundedNorth, RoundedSouth, RoundedWest, RoundedEast,
                 TriangularNorth, TriangularSouth, TriangularWest, TriangularEast




    };

    Shape shape() const;
    void setShape(Shape shape);

    int addTab(const QString &text);
    int addTab(const QIcon &icon, const QString &text);

    int insertTab(int index, const QString &text);
    int insertTab(int index, const QIcon&icon, const QString &text);

    void removeTab(int index);

    bool isTabEnabled(int index) const;
    void setTabEnabled(int index, bool);

    QString tabText(int index) const;
    void setTabText(int index, const QString &text);

    QIcon tabIcon(int index) const;
    void setTabIcon(int index, const QIcon &icon);

    void setTabToolTip(int index, const QString &tip);
    QString tabToolTip(int index) const;

    void setTabData(int index, const QVariant &data);
    QVariant tabData(int index) const;

    QRect tabRect(int index) const;

    int currentIndex() const;
    int count() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setDrawBase(bool drawTheBase);
    bool drawBase() const;

public :
    void setCurrentIndex(int index);

protected:
    void currentChanged(int index);

protected:
    virtual QSize tabSizeHint(int index) const;
    virtual void tabInserted(int index);
    virtual void tabRemoved(int index);
    virtual void tabLayoutChange();

    bool event(QEvent *);
    void resizeEvent(QResizeEvent *);
    void showEvent(QShowEvent *);
    void paintEvent(QPaintEvent *);
    void mousePressEvent (QMouseEvent *);
    void mouseMoveEvent (QMouseEvent *);
    void mouseReleaseEvent (QMouseEvent *);
    void keyPressEvent(QKeyEvent *);
    void changeEvent(QEvent *);








private:
    QTabBar(const QTabBar &); QTabBar &operator=(const QTabBar &);
    inline QTabBarPrivate* d_func() { return reinterpret_cast<QTabBarPrivate *>(d_ptr); } inline const QTabBarPrivate* d_func() const { return reinterpret_cast<const QTabBarPrivate *>(d_ptr); } friend class QTabBarPrivate;

};


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QTabBar;
class QTabWidgetPrivate;

class __declspec(dllimport) QTabWidget : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    explicit QTabWidget(QWidget *parent = 0);
    ~QTabWidget();

    int addTab(QWidget *widget, const QString &);
    int addTab(QWidget *widget, const QIcon& icon, const QString &label);

    int insertTab(int index, QWidget *widget, const QString &);
    int insertTab(int index, QWidget *widget, const QIcon& icon, const QString &label);

    void removeTab(int index);

    bool isTabEnabled(int index) const;
    void setTabEnabled(int index, bool);

    QString tabText(int index) const;
    void setTabText(int index, const QString &);

    QIcon tabIcon(int index) const;
    void setTabIcon(int index, const QIcon & icon);

    void setTabToolTip(int index, const QString & tip);
    QString tabToolTip(int index) const;

    int currentIndex() const;
    QWidget *currentWidget() const;
    QWidget *widget(int index) const;
    int indexOf(QWidget *widget) const;
    int count() const;

    enum TabPosition { North, South, West, East



    };
    TabPosition tabPosition() const;
    void setTabPosition(TabPosition);

    enum TabShape { Rounded, Triangular };
    TabShape tabShape() const;
    void setTabShape(TabShape s);

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setCornerWidget(QWidget * w, Qt::Corner corner = Qt::TopRightCorner);
    QWidget * cornerWidget(Qt::Corner corner = Qt::TopRightCorner) const;

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *widget);

protected:
    void currentChanged(int index);

protected:
    virtual void tabInserted(int index);
    virtual void tabRemoved(int index);

    void showEvent(QShowEvent *);
    void resizeEvent(QResizeEvent *);
    void keyPressEvent(QKeyEvent *);
    void paintEvent(QPaintEvent *);
    void setTabBar(QTabBar *);
    QTabBar* tabBar() const;
    void changeEvent(QEvent *);











































private:
    inline QTabWidgetPrivate* d_func() { return reinterpret_cast<QTabWidgetPrivate *>(d_ptr); } inline const QTabWidgetPrivate* d_func() const { return reinterpret_cast<const QTabWidgetPrivate *>(d_ptr); } friend class QTabWidgetPrivate;
    QTabWidget(const QTabWidget &); QTabWidget &operator=(const QTabWidget &);



    void setUpLayout(bool = false);
    friend class Q3TabDialog;
};






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QRubberBandPrivate;

class __declspec(dllimport) QRubberBand : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    enum Shape { Line, Rectangle };
    explicit QRubberBand(Shape, QWidget * =0);
    ~QRubberBand();

    Shape shape() const;

    void setGeometry(const QRect &r);

    inline void setGeometry(int x, int y, int w, int h);
    inline void move(int x, int y);
    inline void move(const QPoint &p)
    { move(p.x(), p.y()); }
    inline void resize(int w, int h)
    { setGeometry(geometry().x(), geometry().y(), w, h); }
    inline void resize(const QSize &s)
    { resize(s.width(), s.height()); }


protected:

    void paintEvent(QPaintEvent *);
    void changeEvent(QEvent *);

private:
    inline QRubberBandPrivate* d_func() { return reinterpret_cast<QRubberBandPrivate *>(d_ptr); } inline const QRubberBandPrivate* d_func() const { return reinterpret_cast<const QRubberBandPrivate *>(d_ptr); } friend class QRubberBandPrivate;
};

inline void QRubberBand::setGeometry(int ax, int ay, int aw, int ah)
{ setGeometry(QRect(ax, ay, aw, ah)); }
inline void QRubberBand::move(int ax, int ay)
{ setGeometry(ax + geometry().x() - QWidget::x(),
              ay - geometry().y() - QWidget::y(),
              width(), height()); }






typedef QtValidLicenseForGuiModule QtGuiModule;

class QDebug;

class __declspec(dllimport) QStyleOption
{
public:
    enum OptionType {
                      SO_Default, SO_FocusRect, SO_Button, SO_Tab, SO_MenuItem,
                      SO_Frame, SO_ProgressBar, SO_ToolBox, SO_Header, SO_Q3DockWindow,
                      SO_DockWidget, SO_Q3ListViewItem, SO_ViewItem, SO_TabWidgetFrame,
                      SO_TabBarBase, SO_RubberBand,

                      SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
                      SO_Q3ListView, SO_TitleBar,

                      SO_CustomBase = 0xf00,
                      SO_ComplexCustomBase = 0xf000000
                    };

    enum { Type = SO_Default };
    enum { Version = 1 };

    int version;
    int type;
    QStyle::State state;
    Qt::LayoutDirection direction;
    QRect rect;
    QFontMetrics fontMetrics;
    QPalette palette;

    QStyleOption(int version = QStyleOption::Version, int type = SO_Default);
    QStyleOption(const QStyleOption &other);
    ~QStyleOption();

    void init(const QWidget *w);
    inline void initFrom(const QWidget *w) { init(w); }
    QStyleOption &operator=(const QStyleOption &other);
};

class __declspec(dllimport) QStyleOptionFocusRect : public QStyleOption
{
public:
    enum { Type = SO_FocusRect };
    enum { Version = 1 };

    QColor backgroundColor;

    QStyleOptionFocusRect();
    QStyleOptionFocusRect(const QStyleOptionFocusRect &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionFocusRect(int version);
};

class __declspec(dllimport) QStyleOptionFrame : public QStyleOption
{
public:
    enum { Type = SO_Frame };
    enum { Version = 1 };

    int lineWidth;
    int midLineWidth;

    QStyleOptionFrame();
    QStyleOptionFrame(const QStyleOptionFrame &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionFrame(int version);
};


class __declspec(dllimport) QStyleOptionTabWidgetFrame : public QStyleOption
{
public:
    enum { Type = SO_TabWidgetFrame };
    enum { Version = 1 };

    int lineWidth;
    int midLineWidth;
    QTabBar::Shape shape;
    QSize tabBarSize;
    QSize rightCornerWidgetSize;
    QSize leftCornerWidgetSize;

    QStyleOptionTabWidgetFrame();
    inline QStyleOptionTabWidgetFrame(const QStyleOptionTabWidgetFrame &other)
        : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionTabWidgetFrame(int version);
};



class __declspec(dllimport) QStyleOptionTabBarBase : public QStyleOption
{
public:
    enum { Type = SO_TabBarBase };
    enum { Version = 1 };

    QTabBar::Shape shape;
    QRect tabBarRect;
    QRect selectedTabRect;

    QStyleOptionTabBarBase();
    QStyleOptionTabBarBase(const QStyleOptionTabBarBase &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionTabBarBase(int version);
};


class __declspec(dllimport) QStyleOptionHeader : public QStyleOption
{
public:
    enum { Type = SO_Header };
    enum { Version = 1 };

    enum SectionPosition { Beginning, Middle, End, OnlyOneSection };
    enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected,
                            NextAndPreviousAreSelected };
    enum SortIndicator { None, SortUp, SortDown };

    int section;
    QString text;
    Qt::Alignment textAlignment;
    QIcon icon;
    Qt::Alignment iconAlignment;
    SectionPosition position;
    SelectedPosition selectedPosition;
    SortIndicator sortIndicator;
    Qt::Orientation orientation;

    QStyleOptionHeader();
    QStyleOptionHeader(const QStyleOptionHeader &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionHeader(int version);
};

class __declspec(dllimport) QStyleOptionButton : public QStyleOption
{
public:
    enum { Type = SO_Button };
    enum { Version = 1 };

    enum ButtonFeature { None = 0x00, Flat = 0x01, HasMenu = 0x02, DefaultButton = 0x04,
                         AutoDefaultButton = 0x08 };
    typedef QFlags<ButtonFeature> ButtonFeatures;

    ButtonFeatures features;
    QString text;
    QIcon icon;
    QSize iconSize;

    QStyleOptionButton();
    QStyleOptionButton(const QStyleOptionButton &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionButton(int version);
};

inline QFlags<QStyleOptionButton::ButtonFeatures::enum_type> operator|(QStyleOptionButton::ButtonFeatures::enum_type f1, QStyleOptionButton::ButtonFeatures::enum_type f2) { return QFlags<QStyleOptionButton::ButtonFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionButton::ButtonFeatures::enum_type> operator|(QStyleOptionButton::ButtonFeatures::enum_type f1, QFlags<QStyleOptionButton::ButtonFeatures::enum_type> f2) { return f2 | f1; }


class __declspec(dllimport) QStyleOptionTab : public QStyleOption
{
public:
    enum { Type = SO_Tab };
    enum { Version = 1 };

    enum TabPosition { Beginning, Middle, End, OnlyOneTab };
    enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected };
    enum CornerWidget { NoCornerWidgets = 0x00, LeftCornerWidget = 0x01,
                        RightCornerWidget = 0x02 };
    typedef QFlags<CornerWidget> CornerWidgets;

    QTabBar::Shape shape;
    QString text;
    QIcon icon;
    int row;
    TabPosition position;
    SelectedPosition selectedPosition;
    CornerWidgets cornerWidgets;

    QStyleOptionTab();
    QStyleOptionTab(const QStyleOptionTab &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionTab(int version);
};

inline QFlags<QStyleOptionTab::CornerWidgets::enum_type> operator|(QStyleOptionTab::CornerWidgets::enum_type f1, QStyleOptionTab::CornerWidgets::enum_type f2) { return QFlags<QStyleOptionTab::CornerWidgets::enum_type>(f1) | f2; } inline QFlags<QStyleOptionTab::CornerWidgets::enum_type> operator|(QStyleOptionTab::CornerWidgets::enum_type f1, QFlags<QStyleOptionTab::CornerWidgets::enum_type> f2) { return f2 | f1; }


class __declspec(dllimport) QStyleOptionProgressBar : public QStyleOption
{
public:
    enum { Type = SO_ProgressBar };
    enum { Version = 1 };

    int minimum;
    int maximum;
    int progress;
    QString text;
    Qt::Alignment textAlignment;
    bool textVisible;

    QStyleOptionProgressBar();
    QStyleOptionProgressBar(const QStyleOptionProgressBar &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionProgressBar(int version);
};


class __declspec(dllimport) QStyleOptionProgressBarV2 : public QStyleOptionProgressBar
{
public:
    enum { Type = SO_ProgressBar };
    enum { Version = 2 };
    Qt::Orientation orientation;
    bool invertedAppearance;
    bool bottomToTop;

    QStyleOptionProgressBarV2();
    QStyleOptionProgressBarV2(const QStyleOptionProgressBar &other);
    QStyleOptionProgressBarV2(const QStyleOptionProgressBarV2 &other);
    QStyleOptionProgressBarV2 &operator=(const QStyleOptionProgressBar &other);

protected:
    QStyleOptionProgressBarV2(int version);
};

class __declspec(dllimport) QStyleOptionMenuItem : public QStyleOption
{
public:
    enum { Type = SO_MenuItem };
    enum { Version = 1 };

    enum MenuItemType { Normal, DefaultItem, Separator, SubMenu, Scroller, TearOff, Margin,
                        EmptyArea };
    enum CheckType { NotCheckable, Exclusive, NonExclusive };

    MenuItemType menuItemType;
    CheckType checkType;
    bool checked;
    bool menuHasCheckableItems;
    QRect menuRect;
    QString text;
    QIcon icon;
    int maxIconWidth;
    int tabWidth;
    QFont font;

    QStyleOptionMenuItem();
    QStyleOptionMenuItem(const QStyleOptionMenuItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionMenuItem(int version);
};

class __declspec(dllimport) QStyleOptionQ3ListViewItem : public QStyleOption
{
public:
    enum { Type = SO_Q3ListViewItem };
    enum { Version = 1 };

    enum Q3ListViewItemFeature { None = 0x00, Expandable = 0x01, MultiLine = 0x02, Visible = 0x04,
                                 ParentControl = 0x08 };
    typedef QFlags<Q3ListViewItemFeature> Q3ListViewItemFeatures;

    Q3ListViewItemFeatures features;
    int height;
    int totalHeight;
    int itemY;
    int childCount;

    QStyleOptionQ3ListViewItem();
    QStyleOptionQ3ListViewItem(const QStyleOptionQ3ListViewItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionQ3ListViewItem(int version);
};

inline QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> operator|(QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f1, QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f2) { return QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> operator|(QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f1, QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> f2) { return f2 | f1; }

class __declspec(dllimport) QStyleOptionQ3DockWindow : public QStyleOption
{
public:
    enum { Type = SO_Q3DockWindow };
    enum { Version = 1 };

    bool docked;
    bool closeEnabled;

    QStyleOptionQ3DockWindow();
    QStyleOptionQ3DockWindow(const QStyleOptionQ3DockWindow &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionQ3DockWindow(int version);
};

class __declspec(dllimport) QStyleOptionDockWidget : public QStyleOption
{
public:
    enum { Type = SO_DockWidget };
    enum { Version = 1 };

    QString title;
    bool closable;
    bool movable;
    bool floatable;

    QStyleOptionDockWidget();
    QStyleOptionDockWidget(const QStyleOptionDockWidget &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionDockWidget(int version);
};

class __declspec(dllimport) QStyleOptionViewItem : public QStyleOption
{
public:
    enum { Type = SO_ViewItem };
    enum { Version = 1 };

    enum Position { Left, Right, Top, Bottom };

    Qt::Alignment displayAlignment;
    Qt::Alignment decorationAlignment;
    Qt::TextElideMode textElideMode;
    Position decorationPosition;
    QSize decorationSize;
    QFont font;
    bool showDecorationSelected;

    QStyleOptionViewItem();
    QStyleOptionViewItem(const QStyleOptionViewItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionViewItem(int version);
};

class __declspec(dllimport) QStyleOptionToolBox : public QStyleOption
{
public:
    enum { Type = SO_ToolBox };
    enum { Version = 1 };

    QString text;
    QIcon icon;

    QStyleOptionToolBox();
    QStyleOptionToolBox(const QStyleOptionToolBox &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionToolBox(int version);
};


class __declspec(dllimport) QStyleOptionRubberBand : public QStyleOption
{
public:
    enum { Type = SO_RubberBand };
    enum { Version = 1 };

    QRubberBand::Shape shape;
    bool opaque;

    QStyleOptionRubberBand();
    QStyleOptionRubberBand(const QStyleOptionRubberBand &other) : QStyleOption(Version, Type) { *this = other; }

protected:
    QStyleOptionRubberBand(int version);
};



class __declspec(dllimport) QStyleOptionComplex : public QStyleOption
{
public:
    enum { Type = SO_Complex };
    enum { Version = 1 };

    QStyle::SubControls subControls;
    QStyle::SubControls activeSubControls;

    QStyleOptionComplex(int version = QStyleOptionComplex::Version, int type = SO_Complex);
    QStyleOptionComplex(const QStyleOptionComplex &other) : QStyleOption(Version, Type) { *this = other; }
};


class __declspec(dllimport) QStyleOptionSlider : public QStyleOptionComplex
{
public:
    enum { Type = SO_Slider };
    enum { Version = 1 };

    Qt::Orientation orientation;
    int minimum;
    int maximum;
    QSlider::TickPosition tickPosition;
    int tickInterval;
    bool upsideDown;
    int sliderPosition;
    int sliderValue;
    int singleStep;
    int pageStep;
    qreal notchTarget;
    bool dialWrapping;

    QStyleOptionSlider();
    QStyleOptionSlider(const QStyleOptionSlider &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionSlider(int version);
};



class __declspec(dllimport) QStyleOptionSpinBox : public QStyleOptionComplex
{
public:
    enum { Type = SO_SpinBox };
    enum { Version = 1 };

    QAbstractSpinBox::ButtonSymbols buttonSymbols;
    QAbstractSpinBox::StepEnabled stepEnabled;
    bool frame;

    QStyleOptionSpinBox();
    QStyleOptionSpinBox(const QStyleOptionSpinBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionSpinBox(int version);
};


class __declspec(dllimport) QStyleOptionQ3ListView : public QStyleOptionComplex
{
public:
    enum { Type = SO_Q3ListView };
    enum { Version = 1 };

    QList<QStyleOptionQ3ListViewItem> items;
    QPalette viewportPalette;
    QPalette::ColorRole viewportBGRole;
    int sortColumn;
    int itemMargin;
    int treeStepSize;
    bool rootIsDecorated;

    QStyleOptionQ3ListView();
    QStyleOptionQ3ListView(const QStyleOptionQ3ListView &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionQ3ListView(int version);
};

class __declspec(dllimport) QStyleOptionToolButton : public QStyleOptionComplex
{
public:
    enum { Type = SO_ToolButton };
    enum { Version = 1 };

    enum ToolButtonFeature { None = 0x00, Arrow = 0x01, Menu = 0x04, PopupDelay = 0x08 };
    typedef QFlags<ToolButtonFeature> ToolButtonFeatures;

    ToolButtonFeatures features;
    QIcon icon;
    QSize iconSize;
    QString text;
    Qt::ArrowType arrowType;
    Qt::ToolButtonStyle toolButtonStyle;
    QPoint pos;
    QFont font;

    QStyleOptionToolButton();
    QStyleOptionToolButton(const QStyleOptionToolButton &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionToolButton(int version);
};

inline QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> operator|(QStyleOptionToolButton::ToolButtonFeatures::enum_type f1, QStyleOptionToolButton::ToolButtonFeatures::enum_type f2) { return QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> operator|(QStyleOptionToolButton::ToolButtonFeatures::enum_type f1, QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> f2) { return f2 | f1; }

class __declspec(dllimport) QStyleOptionComboBox : public QStyleOptionComplex
{
public:
    enum { Type = SO_ComboBox };
    enum { Version = 1 };

    bool editable;
    QRect popupRect;
    bool frame;
    QString currentText;
    QIcon currentIcon;
    QSize iconSize;

    QStyleOptionComboBox();
    QStyleOptionComboBox(const QStyleOptionComboBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionComboBox(int version);
};

class __declspec(dllimport) QStyleOptionTitleBar : public QStyleOptionComplex
{
public:
    enum { Type = SO_TitleBar };
    enum { Version = 1 };

    QString text;
    QIcon icon;
    int titleBarState;
    Qt::WFlags titleBarFlags;

    QStyleOptionTitleBar();
    QStyleOptionTitleBar(const QStyleOptionTitleBar &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
    QStyleOptionTitleBar(int version);
};

template <typename T>
T qstyleoption_cast(const QStyleOption *opt)
{
    if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
        || int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
        || (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
            && opt->type > QStyleOption::SO_Complex)))
        return static_cast<T>(opt);
    return 0;
}

template <typename T>
T qstyleoption_cast(QStyleOption *opt)
{
    if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
        || int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
        || (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
            && opt->type > QStyleOption::SO_Complex)))
        return static_cast<T>(opt);
    return 0;
}


class __declspec(dllimport) QStyleHintReturn {
public:
    enum HintReturnType {
        SH_Default=0xf000, SH_Mask
    };

    enum { Type = SH_Default };
    enum { Version = 1 };

    QStyleHintReturn(int version = QStyleOption::Version, int type = SH_Default);
    ~QStyleHintReturn();

    int version;
    int type;
};

class __declspec(dllimport) QStyleHintReturnMask : public QStyleHintReturn {
public:
    enum { Type = SH_Mask };
    enum { Version = 1 };

    QStyleHintReturnMask();

    QRegion region;
};

template <typename T>
T qstyleoption_cast(const QStyleHintReturn *hint)
{
    if (hint && hint->version <= static_cast<T>(0)->Version &&
        (hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
        return static_cast<T>(hint);
    return 0;
}

template <typename T>
T qstyleoption_cast(QStyleHintReturn *hint)
{
    if (hint && hint->version <= static_cast<T>(0)->Version &&
        (hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
        return static_cast<T>(hint);
    return 0;
}


__declspec(dllimport) QDebug operator<<(QDebug debug, const QStyleOption::OptionType &optionType);
__declspec(dllimport) QDebug operator<<(QDebug debug, const QStyleOption &option);






typedef QtValidLicenseForGuiModule QtGuiModule;



class QPainter;
class QModelIndex;
class QAbstractItemModel;

class __declspec(dllimport) QAbstractItemDelegate : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:

    enum EndEditHint {
        NoHint,
        EditNextItem,
        EditPreviousItem,
        SubmitModelCache,
        RevertModelCache
    };

    explicit QAbstractItemDelegate(QObject *parent = 0);
    virtual ~QAbstractItemDelegate();


    virtual void paint(QPainter *painter,
                       const QStyleOptionViewItem &option,
                       const QModelIndex &index) const = 0;

    virtual QSize sizeHint(const QStyleOptionViewItem &option,
                           const QModelIndex &index) const = 0;


    virtual QWidget *createEditor(QWidget *parent,
                                  const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const;

    virtual void setEditorData(QWidget *editor, const QModelIndex &index) const;

    virtual void setModelData(QWidget *editor,
                              QAbstractItemModel *model,
                              const QModelIndex &index) const;

    virtual void updateEditorGeometry(QWidget *editor,
                                      const QStyleOptionViewItem &option,
                                      const QModelIndex &index) const;


    virtual bool editorEvent(QEvent *event,
                             QAbstractItemModel *model,
                             const QStyleOptionViewItem &option,
                             const QModelIndex &index);

    static QString elidedText(const QFontMetrics &fontMetrics, int width,
                              Qt::TextElideMode mode, const QString &text);
protected:
    void commitData(QWidget *editor);
    void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint = NoHint);

protected:
    QAbstractItemDelegate(const QAbstractItemDelegate &); QAbstractItemDelegate &operator=(const QAbstractItemDelegate &);
    QAbstractItemDelegate(QObjectPrivate &, QObject *parent = 0);
};





























































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QScrollBar;
class QAbstractScrollAreaPrivate;

class __declspec(dllimport) QAbstractScrollArea : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QAbstractScrollArea(QWidget* parent=0);
    ~QAbstractScrollArea();

    Qt::ScrollBarPolicy verticalScrollBarPolicy() const;
    void setVerticalScrollBarPolicy(Qt::ScrollBarPolicy);
    QScrollBar *verticalScrollBar() const;

    Qt::ScrollBarPolicy horizontalScrollBarPolicy() const;
    void setHorizontalScrollBarPolicy(Qt::ScrollBarPolicy);
    QScrollBar *horizontalScrollBar() const;

    QWidget *viewport() const;
    QSize maximumViewportSize() const;

    QSize minimumSizeHint() const;

    QSize sizeHint() const;

protected:
    QAbstractScrollArea(QAbstractScrollAreaPrivate &dd, QWidget *parent = 0);
    void setViewportMargins(int left, int top, int right, int bottom);

    bool event(QEvent *);
    virtual bool viewportEvent(QEvent *);

    void resizeEvent(QResizeEvent *);
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseDoubleClickEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);

    void wheelEvent(QWheelEvent *);

    void contextMenuEvent(QContextMenuEvent *);

    void dragEnterEvent(QDragEnterEvent *);
    void dragMoveEvent(QDragMoveEvent *);
    void dragLeaveEvent(QDragLeaveEvent *);
    void dropEvent(QDropEvent *);


    void keyPressEvent(QKeyEvent *);

    virtual void scrollContentsBy(int dx, int dy);

private:
    inline QAbstractScrollAreaPrivate* d_func() { return reinterpret_cast<QAbstractScrollAreaPrivate *>(d_ptr); } inline const QAbstractScrollAreaPrivate* d_func() const { return reinterpret_cast<const QAbstractScrollAreaPrivate *>(d_ptr); } friend class QAbstractScrollAreaPrivate;
    QAbstractScrollArea(const QAbstractScrollArea &); QAbstractScrollArea &operator=(const QAbstractScrollArea &);




};































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QItemSelectionRange
{

public:
    inline QItemSelectionRange() {}
    inline QItemSelectionRange(const QItemSelectionRange &other)
        : tl(other.tl), br(other.br) {}
    inline QItemSelectionRange(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    inline QItemSelectionRange(const QModelIndex &index)
        { tl = index; br = tl; }

    inline int top() const { return tl.row(); }
    inline int left() const { return tl.column(); }
    inline int bottom() const { return br.row(); }
    inline int right() const { return br.column(); }
    inline int width() const { return br.column() - tl.column() + 1; }
    inline int height() const { return br.row() - tl.row() + 1; }

    inline QModelIndex topLeft() const { return QModelIndex(tl); }
    inline QModelIndex bottomRight() const { return QModelIndex(br); }
    inline QModelIndex parent() const { return tl.parent(); }
    inline const QAbstractItemModel *model() const { return tl.model(); }

    inline bool contains(const QModelIndex &index) const
    {
        return (parent() == index.parent()
                && tl.row() <= index.row() && tl.column() <= index.column()
                && br.row() >= index.row() && br.column() >= index.column());
    }

    bool intersects(const QItemSelectionRange &other) const;
    QItemSelectionRange intersect(const QItemSelectionRange &other) const;

    inline bool operator==(const QItemSelectionRange &other) const
        { return (tl == other.tl && br == other.br); }
    inline bool operator!=(const QItemSelectionRange &other) const
        { return !operator==(other); }

    inline bool isValid() const
    {
        return (tl.isValid() && br.isValid() && tl.parent() == br.parent()
                && top() <= bottom() && left() <= right());
    }

    QModelIndexList indexes() const;

private:
    QPersistentModelIndex tl, br;
};
template <> class QTypeInfo<QItemSelectionRange> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QItemSelectionRange)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QItemSelectionRange"; } };

inline QItemSelectionRange::QItemSelectionRange(const QModelIndex &atopLeft,
                                                const QModelIndex &abottomRight)
{ tl = atopLeft; br = abottomRight; }

class QItemSelection;
class QItemSelectionModelPrivate;

class __declspec(dllimport) QItemSelectionModel : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QItemSelectionModelPrivate* d_func() { return reinterpret_cast<QItemSelectionModelPrivate *>(d_ptr); } inline const QItemSelectionModelPrivate* d_func() const { return reinterpret_cast<const QItemSelectionModelPrivate *>(d_ptr); } friend class QItemSelectionModelPrivate;


public:

    enum SelectionFlag {
        NoUpdate       = 0x0000,
        Clear          = 0x0001,
        Select         = 0x0002,
        Deselect       = 0x0004,
        Toggle         = 0x0008,
        Current        = 0x0010,
        Rows           = 0x0020,
        Columns        = 0x0040,
        SelectCurrent  = Select | Current,
        ToggleCurrent  = Toggle | Current,
        ClearAndSelect = Clear | Select
    };

    typedef QFlags<SelectionFlag> SelectionFlags;

    explicit QItemSelectionModel(QAbstractItemModel *model);
    virtual ~QItemSelectionModel();

    QModelIndex currentIndex() const;

    bool isSelected(const QModelIndex &index) const;
    bool isRowSelected(int row, const QModelIndex &parent) const;
    bool isColumnSelected(int column, const QModelIndex &parent) const;

    bool rowIntersectsSelection(int row, const QModelIndex &parent) const;
    bool columnIntersectsSelection(int column, const QModelIndex &parent) const;

    QModelIndexList selectedIndexes() const;
    const QItemSelection selection() const;

    const QAbstractItemModel *model() const;

public :
    void setCurrentIndex(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
    virtual void select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
    virtual void select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command);
    virtual void clear();
    virtual void reset();

protected:
    void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
    void currentChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentRowChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentColumnChanged(const QModelIndex &current, const QModelIndex &previous);

protected:
    QItemSelectionModel(QItemSelectionModelPrivate &dd, QAbstractItemModel *model);
    void emitSelectionChanged(const QItemSelection &newSelection, const QItemSelection &oldSelection);

private:
    QItemSelectionModel(const QItemSelectionModel &); QItemSelectionModel &operator=(const QItemSelectionModel &);
};

inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QItemSelectionModel::SelectionFlags::enum_type f2) { return QFlags<QItemSelectionModel::SelectionFlags::enum_type>(f1) | f2; } inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QFlags<QItemSelectionModel::SelectionFlags::enum_type> f2) { return f2 | f1; }


inline uint qHash(const QItemSelectionRange &) { return 0; }

class __declspec(dllimport) QItemSelection : public QList<QItemSelectionRange>
{
public:
    QItemSelection() {}
    QItemSelection(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void select(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    bool contains(const QModelIndex &index) const;
    QModelIndexList indexes() const;
    void merge(const QItemSelection &other, QItemSelectionModel::SelectionFlags command);
    static void split(const QItemSelectionRange &range,
                      const QItemSelectionRange &other,
                      QItemSelection *result);
};


__declspec(dllimport) QDebug operator<<(QDebug, const QItemSelectionRange &);

































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QMenu;
class QDrag;
class QEvent;
class QAbstractItemViewPrivate;

class __declspec(dllimport) QAbstractItemView : public QAbstractScrollArea
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:















public:
    enum SelectionMode {
        NoSelection,
        SingleSelection,
        MultiSelection,
        ExtendedSelection,
        ContiguousSelection
    };

    enum SelectionBehavior {
        SelectItems,
        SelectRows,
        SelectColumns
    };

    enum ScrollHint {
        EnsureVisible,
        PositionAtTop,
        PositionAtBottom
    };

    enum EditTrigger {
        NoEditTriggers = 0,
        CurrentChanged = 1,
        DoubleClicked = 2,
        SelectedClicked = 4,
        EditKeyPressed = 8,
        AnyKeyPressed = 16,
        AllEditTriggers = 31
    };

    typedef QFlags<EditTrigger> EditTriggers;

    explicit QAbstractItemView(QWidget *parent = 0);
    ~QAbstractItemView();

    virtual void setModel(QAbstractItemModel *model);
    QAbstractItemModel *model() const;

    virtual void setSelectionModel(QItemSelectionModel *selectionModel);
    QItemSelectionModel *selectionModel() const;

    void setItemDelegate(QAbstractItemDelegate *delegate);
    QAbstractItemDelegate *itemDelegate() const;

    void setSelectionMode(QAbstractItemView::SelectionMode mode);
    QAbstractItemView::SelectionMode selectionMode() const;

    void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior);
    QAbstractItemView::SelectionBehavior selectionBehavior() const;

    QModelIndex currentIndex() const;
    QModelIndex rootIndex() const;

    void setEditTriggers(EditTriggers triggers);
    EditTriggers editTriggers() const;

    void setAutoScroll(bool enable);
    bool hasAutoScroll() const;

    void setTabKeyNavigation(bool enable);
    bool tabKeyNavigation() const;

    void setDropIndicatorShown(bool enable);
    bool showDropIndicator() const;


    void setDragEnabled(bool enable);
    bool dragEnabled() const;

    void setAlternatingRowColors(bool enable);
    bool alternatingRowColors() const;

    void setIconSize(const QSize &size);
    QSize iconSize() const;

    void setTextElideMode(Qt::TextElideMode mode);
    Qt::TextElideMode textElideMode() const;

    virtual void keyboardSearch(const QString &search);

    virtual QRect visualRect(const QModelIndex &index) const = 0;
    virtual void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible) = 0;
    virtual QModelIndex indexAt(const QPoint &point) const = 0;

    QSize sizeHintForIndex(const QModelIndex &index) const;
    virtual int sizeHintForRow(int row) const;
    virtual int sizeHintForColumn(int column) const;

    void openPersistentEditor(const QModelIndex &index);
    void closePersistentEditor(const QModelIndex &index);

    void setIndexWidget(const QModelIndex &index, QWidget *widget);
    QWidget *indexWidget(const QModelIndex &index) const;

public :
    virtual void reset();
    virtual void setRootIndex(const QModelIndex &index);
    virtual void doItemsLayout();
    virtual void selectAll();
    void edit(const QModelIndex &index);
    void clearSelection();
    void setCurrentIndex(const QModelIndex &index);

protected :
    virtual void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    virtual void rowsInserted(const QModelIndex &parent, int start, int end);
    virtual void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);
    virtual void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
    virtual void currentChanged(const QModelIndex &current, const QModelIndex &previous);
    virtual void updateEditorData();
    virtual void updateEditorGeometries();
    virtual void updateGeometries();
    virtual void verticalScrollbarAction(int action);
    virtual void horizontalScrollbarAction(int action);
    virtual void verticalScrollbarValueChanged(int value);
    virtual void horizontalScrollbarValueChanged(int value);
    virtual void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint);
    virtual void commitData(QWidget *editor);
    virtual void editorDestroyed(QObject *editor);

protected:
    void pressed(const QModelIndex &index);
    void clicked(const QModelIndex &index);
    void doubleClicked(const QModelIndex &index);

    void activated(const QModelIndex &index);
    void entered(const QModelIndex &index);
    void viewportEntered();

protected:
    QAbstractItemView(QAbstractItemViewPrivate &, QWidget *parent = 0);

    void setHorizontalStepsPerItem(int steps);
    int horizontalStepsPerItem() const;
    void setVerticalStepsPerItem(int steps);
    int verticalStepsPerItem() const;

    enum CursorAction { MoveUp, MoveDown, MoveLeft, MoveRight,
                        MoveHome, MoveEnd, MovePageUp, MovePageDown,
                        MoveNext, MovePrevious };
    virtual QModelIndex moveCursor(CursorAction cursorAction,
                                   Qt::KeyboardModifiers modifiers) = 0;

    virtual int horizontalOffset() const = 0;
    virtual int verticalOffset() const = 0;

    virtual bool isIndexHidden(const QModelIndex &index) const = 0;

    virtual void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command) = 0;
    virtual QRegion visualRegionForSelection(const QItemSelection &selection) const = 0;
    virtual QModelIndexList selectedIndexes() const;

    virtual bool edit(const QModelIndex &index, EditTrigger trigger, QEvent *event);

    virtual QItemSelectionModel::SelectionFlags selectionCommand(const QModelIndex &index,
                                                                 const QEvent *event = 0) const;


    virtual void startDrag(Qt::DropActions supportedActions);


    virtual QStyleOptionViewItem viewOptions() const;

    enum State {
        NoState,
        DraggingState,
        DragSelectingState,
        EditingState,
        ExpandingState,
        CollapsingState
    };

    State state() const;
    void setState(State state);

    void scheduleDelayedItemsLayout();
    void executeDelayedItemsLayout();

    void setDirtyRegion(const QRegion &region);
    void scrollDirtyRegion(int dx, int dy);
    QPoint dirtyRegionOffset() const;

    void startAutoScroll();
    void stopAutoScroll();
    void doAutoScroll();

    bool viewportEvent(QEvent *event);
    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void mouseDoubleClickEvent(QMouseEvent *event);

    void dragEnterEvent(QDragEnterEvent *event);
    void dragMoveEvent(QDragMoveEvent *event);
    void dragLeaveEvent(QDragLeaveEvent *event);
    void dropEvent(QDropEvent *event);

    void focusInEvent(QFocusEvent *event);
    void focusOutEvent(QFocusEvent *event);
    void keyPressEvent(QKeyEvent *event);
    void resizeEvent(QResizeEvent *event);
    void timerEvent(QTimerEvent *event);

private:
    inline QAbstractItemViewPrivate* d_func() { return reinterpret_cast<QAbstractItemViewPrivate *>(d_ptr); } inline const QAbstractItemViewPrivate* d_func() const { return reinterpret_cast<const QAbstractItemViewPrivate *>(d_ptr); } friend class QAbstractItemViewPrivate;
    QAbstractItemView(const QAbstractItemView &); QAbstractItemView &operator=(const QAbstractItemView &);
};
inline QFlags<QAbstractItemView::EditTriggers::enum_type> operator|(QAbstractItemView::EditTriggers::enum_type f1, QAbstractItemView::EditTriggers::enum_type f2) { return QFlags<QAbstractItemView::EditTriggers::enum_type>(f1) | f2; } inline QFlags<QAbstractItemView::EditTriggers::enum_type> operator|(QAbstractItemView::EditTriggers::enum_type f1, QFlags<QAbstractItemView::EditTriggers::enum_type> f2) { return f2 | f1; }

















































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QDirModelPrivate;
class QFileIconProviderPrivate;

class __declspec(dllimport) QFileIconProvider
{
public:
    QFileIconProvider();
    virtual ~QFileIconProvider();
    enum IconType { Computer, Desktop, Trashcan, Network, Drive, Folder, File };
    virtual QIcon icon(IconType type) const;
    virtual QIcon icon(const QFileInfo &info) const;
    virtual QString type(const QFileInfo &info) const;

private:
    inline QFileIconProviderPrivate* d_func() { return reinterpret_cast<QFileIconProviderPrivate *>(d_ptr); } inline const QFileIconProviderPrivate* d_func() const { return reinterpret_cast<const QFileIconProviderPrivate *>(d_ptr); } friend class QFileIconProviderPrivate;
    QFileIconProviderPrivate *d_ptr;
};

class __declspec(dllimport) QDirModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




public:
    enum Roles {
        FileIconRole = Qt::DecorationRole,
        FilePathRole = Qt::UserRole + 1,
        FileNameRole
    };

    QDirModel(const QStringList &nameFilters, QDir::Filters filters,
              QDir::SortFlags sort, QObject *parent = 0);
    explicit QDirModel(QObject *parent = 0);
    ~QDirModel();

    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    QModelIndex parent(const QModelIndex &child) const;

    int rowCount(const QModelIndex &parent) const;
    int columnCount(const QModelIndex &parent) const;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role);

    QVariant headerData(int section, Qt::Orientation orientation, int role) const;

    bool hasChildren(const QModelIndex &index) const;
    Qt::ItemFlags flags(const QModelIndex &index) const;

    void sort(int column, Qt::SortOrder order);

    QStringList mimeTypes() const;
    QMimeData *mimeData(const QModelIndexList &indexes) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);
    Qt::DropActions supportedDropActions() const;



    void setIconProvider(QFileIconProvider *provider);
    QFileIconProvider *iconProvider() const;

    void setNameFilters(const QStringList &filters);
    QStringList nameFilters() const;

    void setFilter(QDir::Filters filters);
    QDir::Filters filter() const;

    void setSorting(QDir::SortFlags sort);
    QDir::SortFlags sorting() const;

    void setResolveSymlinks(bool enable);
    bool resolveSymlinks() const;

    void setReadOnly(bool enable);
    bool isReadOnly() const;

    void setLazyChildCount(bool enable);
    bool lazyChildCount() const;

    void refresh(const QModelIndex &parent = QModelIndex());
    QModelIndex index(const QString &path, int column = 0) const;

    bool isDir(const QModelIndex &index) const;
    QModelIndex mkdir(const QModelIndex &parent, const QString &name);
    bool rmdir(const QModelIndex &index);
    bool remove(const QModelIndex &index);

    QString filePath(const QModelIndex &index) const;
    QString fileName(const QModelIndex &index) const;
    QIcon fileIcon(const QModelIndex &index) const;
    QFileInfo fileInfo(const QModelIndex &index) const;

protected:
    QDirModel(QDirModelPrivate &, QObject *parent = 0);

private:
    inline QDirModelPrivate* d_func() { return reinterpret_cast<QDirModelPrivate *>(d_ptr); } inline const QDirModelPrivate* d_func() const { return reinterpret_cast<const QDirModelPrivate *>(d_ptr); } friend class QDirModelPrivate;
    QDirModel(const QDirModel &); QDirModel &operator=(const QDirModel &);
};




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class QMappingProxyModelPrivate;

class __declspec(dllimport) QMappingProxyModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QMappingProxyModel(QObject *parent = 0);
    ~QMappingProxyModel();

    virtual void setModel(QAbstractItemModel *model);
    QAbstractItemModel *model() const;

    QModelIndex index(int row, int column, const QModelIndex &parent) const;
    QModelIndex parent(const QModelIndex &child) const;

    int rowCount(const QModelIndex &parent) const;
    int columnCount(const QModelIndex &parent) const;
    bool hasChildren(const QModelIndex &parent) const;

    QVariant data(const QModelIndex &index, int role) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role);

    QMimeData *mimeData(const QModelIndexList &indexes) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

    void fetchMore(const QModelIndex &parent);
    bool canFetchMore(const QModelIndex &parent) const;
    Qt::ItemFlags flags(const QModelIndex &index) const;

    QModelIndex buddy(const QModelIndex &index) const;
    QModelIndexList match(const QModelIndex &start, int role,
                          const QVariant &value, int hits,
                          Qt::MatchFlags flags) const;
    QSize span(const QModelIndex &index) const;

    virtual void clear();

protected :
    virtual void sourceDataChanged(const QModelIndex &source_top_left,
                                   const QModelIndex &source_bottom_right);
    virtual void sourceHeaderDataChanged(Qt::Orientation orientation, int start, int end);
    virtual void sourceRowsAboutToBeInserted(const QModelIndex &source_parent, int start, int end);
    virtual void sourceRowsInserted();
    virtual void sourceColumnsAboutToBeInserted(const QModelIndex &source_parent,
                                                int start, int end);
    virtual void sourceColumnsInserted();
    virtual void sourceRowsAboutToBeRemoved(const QModelIndex &source_parent, int start, int end);
    virtual void sourceRowsRemoved();
    virtual void sourceColumnsAboutToBeRemoved(const QModelIndex &source_parent,
                                               int start, int end);
    virtual void sourceColumnsRemoved();
    virtual void sourceLayoutChanged();

protected:
    QMappingProxyModel(QMappingProxyModelPrivate &, QObject *parent);
    virtual QModelIndex proxyIndex(const QModelIndex &source_index) const;
    mutable QMap<QModelIndex, QModelIndex> proxy_to_source;

private:
    inline QMappingProxyModelPrivate* d_func() { return reinterpret_cast<QMappingProxyModelPrivate *>(d_ptr); } inline const QMappingProxyModelPrivate* d_func() const { return reinterpret_cast<const QMappingProxyModelPrivate *>(d_ptr); } friend class QMappingProxyModelPrivate;
    QMappingProxyModel(const QMappingProxyModel &); QMappingProxyModel &operator=(const QMappingProxyModel &);
};





class __declspec(dllimport) QFilteringProxyModel : public QMappingProxyModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QFilteringProxyModel(QObject *parent = 0);
    ~QFilteringProxyModel();

    void clear();

    QModelIndex index(int row, int column, const QModelIndex &parent) const;
    int rowCount(const QModelIndex &parent) const;

protected:
    QFilteringProxyModel(QMappingProxyModelPrivate&, QObject *parent);

    virtual bool filterRow(int source_row, const QModelIndex &source_parent) const = 0;
    virtual void mapChildren(const QModelIndex &parent) const;
    void sourceLayoutChanged();

    mutable QMap<QModelIndex, int> filtered_row_count;
};































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QHeaderViewPrivate;

class __declspec(dllimport) QHeaderView : public QAbstractItemView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:

    enum ResizeMode
    {
        Interactive,
        Stretch,
        Custom
    };

    explicit QHeaderView(Qt::Orientation orientation, QWidget *parent = 0);
    virtual ~QHeaderView();

    void setModel(QAbstractItemModel *model);

    Qt::Orientation orientation() const;
    int offset() const;
    int length() const;
    QSize sizeHint() const;
    int sectionSizeHint(int logicalIndex) const;

    int visualIndexAt(int position) const;
    int logicalIndexAt(int position) const;

    inline int logicalIndexAt(int x, int y) const;
    inline int logicalIndexAt(const QPoint &pos) const;

    int sectionSize(int logicalIndex) const;
    int sectionPosition(int logicalIndex) const;
    int sectionViewportPosition(int logicalIndex) const;

    void moveSection(int from, int to);
    void resizeSection(int logicalIndex, int size);

    bool isSectionHidden(int logicalIndex) const;
    void setSectionHidden(int logicalIndex, bool hide);

    inline void hideSection(int logicalIndex);
    inline void showSection(int logicalIndex);

    int count() const;
    int visualIndex(int logicalIndex) const;
    int logicalIndex(int visualIndex) const;

    void setMovable(bool movable);
    bool isMovable() const;

    void setClickable(bool clickable);
    bool isClickable() const;

    void setHighlightSections(bool highlight);
    bool highlightSections() const;

    void setResizeMode(ResizeMode mode);
    void setResizeMode(int logicalIndex, ResizeMode mode);
    ResizeMode resizeMode(int logicalIndex) const;
    int stretchSectionCount() const;

    void setSortIndicatorShown(bool show);
    bool isSortIndicatorShown() const;

    void setSortIndicator(int logicalIndex, Qt::SortOrder order);
    int sortIndicatorSection() const;
    Qt::SortOrder sortIndicatorOrder() const;

    bool stretchLastSection() const;
    void setStretchLastSection(bool stretch);

    int defaultSectionSize() const;
    void setDefaultSectionSize(int size);

    void doItemsLayout();
    bool sectionsMoved() const;
    bool sectionsHidden() const;

public :
    void setOffset(int offset);
    void headerDataChanged(Qt::Orientation orientation, int logicalFirst, int logicalLast);

protected:
    void sectionMoved(int logicalIndex, int oldVisualIndex, int newVisualIndex);
    void sectionResized(int logicalIndex, int oldSize, int newSize);
    void sectionPressed(int logicalIndex);
    void sectionClicked(int logicalIndex);
    void sectionDoubleClicked(int logicalIndex);
    void sectionCountChanged(int oldCount, int newCount);
    void sectionHandleDoubleClicked(int logicalIndex);
    void sectionAutoResize(int logicalIndex, QHeaderView::ResizeMode mode);

protected :
    void updateSection(int logicalIndex);
    void resizeSections();
    void sectionsInserted(const QModelIndex &parent, int logicalFirst, int logicalLast);
    void sectionsAboutToBeRemoved(const QModelIndex &parent, int logicalFirst, int logicalLast);

protected:
    QHeaderView(QHeaderViewPrivate &dd, Qt::Orientation orientation, QWidget *parent = 0);
    void initialize();

    void initializeSections();
    void initializeSections(int start, int end);
    void currentChanged(const QModelIndex &current, const QModelIndex &old);

    bool event(QEvent *e);
    void paintEvent(QPaintEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseMoveEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void mouseDoubleClickEvent(QMouseEvent *e);

    virtual void paintSection(QPainter *painter, const QRect &rect, int logicalIndex) const;
    virtual QSize sectionSizeFromContents(int logicalIndex) const;

    int horizontalOffset() const;
    int verticalOffset() const;
    void updateGeometries();
    void scrollContentsBy(int dx, int dy);

    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void rowsInserted(const QModelIndex &parent, int start, int end);

    QRect visualRect(const QModelIndex &index) const;
    void scrollTo(const QModelIndex &index, ScrollHint hint);

    QModelIndex indexAt(const QPoint &p) const;
    bool isIndexHidden(const QModelIndex &index) const;

    QModelIndex moveCursor(CursorAction, Qt::KeyboardModifiers);
    void setSelection(const QRect&, QItemSelectionModel::SelectionFlags);
    QRegion visualRegionForSelection(const QItemSelection &selection) const;

private:
    inline QHeaderViewPrivate* d_func() { return reinterpret_cast<QHeaderViewPrivate *>(d_ptr); } inline const QHeaderViewPrivate* d_func() const { return reinterpret_cast<const QHeaderViewPrivate *>(d_ptr); } friend class QHeaderViewPrivate;
    QHeaderView(const QHeaderView &); QHeaderView &operator=(const QHeaderView &);
};

inline int QHeaderView::logicalIndexAt(int ax, int ay) const
{ return orientation() == Qt::Horizontal ? logicalIndexAt(ax) : logicalIndexAt(ay); }

inline int QHeaderView::logicalIndexAt(const QPoint &apos) const
{ return logicalIndexAt(apos.x(), apos.y()); }

inline void QHeaderView::hideSection(int alogicalIndex)
{ setSectionHidden(alogicalIndex, true); }
inline void QHeaderView::showSection(int alogicalIndex)
{ setSectionHidden(alogicalIndex, false); }






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QItemDelegatePrivate;
class QItemEditorFactory;

class __declspec(dllimport) QItemDelegate : public QAbstractItemDelegate
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QItemDelegate(QObject *parent = 0);
    ~QItemDelegate();


    void paint(QPainter *painter,
               const QStyleOptionViewItem &option,
               const QModelIndex &index) const;
    QSize sizeHint(const QStyleOptionViewItem &option,
                   const QModelIndex &index) const;


    QWidget *createEditor(QWidget *parent,
                          const QStyleOptionViewItem &option,
                          const QModelIndex &index) const;

    void setEditorData(QWidget *editor, const QModelIndex &index) const;
    void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;

    void updateEditorGeometry(QWidget *editor,
                              const QStyleOptionViewItem &option,
                              const QModelIndex &index) const;


    QItemEditorFactory *itemEditorFactory() const;
    void setItemEditorFactory(QItemEditorFactory *factory);

protected:
    virtual void drawDisplay(QPainter *painter, const QStyleOptionViewItem &option,
                             const QRect &rect, const QString &text) const;
    virtual void drawDecoration(QPainter *painter, const QStyleOptionViewItem &option,
                                const QRect &rect, const QPixmap &pixmap) const;
    virtual void drawFocus(QPainter *painter, const QStyleOptionViewItem &option,
                           const QRect &rect) const;
    virtual void drawCheck(QPainter *painter, const QStyleOptionViewItem &option,
                           const QRect &rect, Qt::CheckState state) const;

    void doLayout(const QStyleOptionViewItem &option,
                  QRect *checkRect, QRect *iconRect, QRect *textRect, bool hint) const;
    QPixmap decoration(const QStyleOptionViewItem &option, const QVariant &variant) const;
    QPixmap *selected(const QPixmap &pixmap, const QPalette &palette, bool enabled) const;
    QRect check(const QStyleOptionViewItem &option, const QRect &bounding,
                const QVariant &variant) const;

    bool eventFilter(QObject *object, QEvent *event);
    bool editorEvent(QEvent *event, QAbstractItemModel *model,
                     const QStyleOptionViewItem &option, const QModelIndex &index);

private:
    inline QItemDelegatePrivate* d_func() { return reinterpret_cast<QItemDelegatePrivate *>(d_ptr); } inline const QItemDelegatePrivate* d_func() const { return reinterpret_cast<const QItemDelegatePrivate *>(d_ptr); } friend class QItemDelegatePrivate;
    QItemDelegate(const QItemDelegate &); QItemDelegate &operator=(const QItemDelegate &);
};


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QWidget;

class __declspec(dllimport) QItemEditorCreatorBase
{
public:
    virtual ~QItemEditorCreatorBase() {}

    virtual QWidget *createWidget(QWidget *parent) const = 0;
    virtual QByteArray valuePropertyName() const = 0;
};

template <class T>
class QItemEditorCreator : public QItemEditorCreatorBase
{
public:
    inline QItemEditorCreator(const QByteArray &valuePropertyName);
    inline QWidget *createWidget(QWidget *parent) const { return new T(parent); }
    inline QByteArray valuePropertyName() const { return propertyName; }

private:
    QByteArray propertyName;
};

template <class T>
inline QItemEditorCreator<T>::QItemEditorCreator(const QByteArray &avaluePropertyName)
    : propertyName(avaluePropertyName) {}

class __declspec(dllimport) QItemEditorFactory
{
public:
    inline QItemEditorFactory() {}
    virtual ~QItemEditorFactory();

    virtual QWidget *createEditor(QVariant::Type type, QWidget *parent) const;
    virtual QByteArray valuePropertyName(QVariant::Type type) const;

    void registerEditor(QVariant::Type type, QItemEditorCreatorBase *creator);

    static const QItemEditorFactory *defaultFactory();
    static void setDefaultFactory(QItemEditorFactory *factory);

private:
    QHash<QVariant::Type, QItemEditorCreatorBase *> creatorMap;
};














































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QListViewPrivate;

class __declspec(dllimport) QListView : public QAbstractItemView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:











public:
    enum Movement { Static, Free, Snap };
    enum Flow { LeftToRight, TopToBottom };
    enum ResizeMode { Fixed, Adjust };
    enum LayoutMode { SinglePass, Batched };
    enum ViewMode { ListMode, IconMode };

    explicit QListView(QWidget *parent = 0);
    ~QListView();

    void setMovement(Movement movement);
    Movement movement() const;

    void setFlow(Flow flow);
    Flow flow() const;

    void setWrapping(bool enable);
    bool isWrapping() const;

    void setResizeMode(ResizeMode mode);
    ResizeMode resizeMode() const;

    void setLayoutMode(LayoutMode mode);
    LayoutMode layoutMode() const;

    void setSpacing(int space);
    int spacing() const;

    void setGridSize(const QSize &size);
    QSize gridSize() const;

    void setViewMode(ViewMode mode);
    ViewMode viewMode() const;

    void clearPropertyFlags();

    bool isRowHidden(int row) const;
    void setRowHidden(int row, bool hide);

    void setModelColumn(int column);
    int modelColumn() const;

    QRect visualRect(const QModelIndex &index) const;
    void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
    QModelIndex indexAt(const QPoint &p) const;

    void doItemsLayout();
    void reset();
    void setRootIndex(const QModelIndex &index);

protected:
    QListView(QListViewPrivate &, QWidget *parent = 0);

    void scrollContentsBy(int dx, int dy);

    void resizeContents(int width, int height);
    QSize contentsSize() const;

    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void rowsInserted(const QModelIndex &parent, int start, int end);
    void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);

    void mouseMoveEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);

    void timerEvent(QTimerEvent *e);
    void resizeEvent(QResizeEvent *e);

    void dragMoveEvent(QDragMoveEvent *e);
    void dragLeaveEvent(QDragLeaveEvent *e);
    void dropEvent(QDropEvent *e);
    void startDrag(Qt::DropActions supportedActions);

    void internalDrop(QDropEvent *e);
    void internalDrag(Qt::DropActions supportedActions);


    QStyleOptionViewItem viewOptions() const;
    void paintEvent(QPaintEvent *e);

    int horizontalOffset() const;
    int verticalOffset() const;
    QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);
    QRect rectForIndex(const QModelIndex &index) const;

    void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
    QRegion visualRegionForSelection(const QItemSelection &selection) const;
    QModelIndexList selectedIndexes() const;

    void updateGeometries();

    bool isIndexHidden(const QModelIndex &index) const;

private:
    inline QListViewPrivate* d_func() { return reinterpret_cast<QListViewPrivate *>(d_ptr); } inline const QListViewPrivate* d_func() const { return reinterpret_cast<const QListViewPrivate *>(d_ptr); } friend class QListViewPrivate;
    QListView(const QListView &); QListView &operator=(const QListView &);
};










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QListWidget;
class QListModel;
class QWidgetItemData;

class __declspec(dllimport) QListWidgetItem
{
    friend class QListModel;
public:
    enum { Type = 0, UserType = 1000 };
    explicit QListWidgetItem(QListWidget *view = 0, int type = Type);
    explicit QListWidgetItem(const QString &text, QListWidget *view = 0, int type = Type);
    explicit QListWidgetItem(const QIcon &icon, const QString &text,
                             QListWidget *view = 0, int type = Type);
    QListWidgetItem(const QListWidgetItem &other);
    virtual ~QListWidgetItem();

    virtual QListWidgetItem *clone() const;

    inline QListWidget *listWidget() const { return view; }

    inline Qt::ItemFlags flags() const { return itemFlags; }
    inline void setFlags(Qt::ItemFlags flags);

    inline QString text() const
        { return data(Qt::DisplayRole).toString(); }
    inline void setText(const QString &text);

    inline QIcon icon() const
        { return qvariant_cast<QIcon>(data(Qt::DecorationRole)); }
    inline void setIcon(const QIcon &icon);

    inline QString statusTip() const
        { return data(Qt::StatusTipRole).toString(); }
    inline void setStatusTip(const QString &statusTip);

    inline QString toolTip() const
        { return data(Qt::ToolTipRole).toString(); }
    inline void setToolTip(const QString &toolTip);

    inline QString whatsThis() const
        { return data(Qt::WhatsThisRole).toString(); }
    inline void setWhatsThis(const QString &whatsThis);

    inline QFont font() const
        { return qvariant_cast<QFont>(data(Qt::FontRole)); }
    inline void setFont(const QFont &font);

    inline int textAlignment() const
        { return data(Qt::TextAlignmentRole).toInt(); }
    inline void setTextAlignment(int alignment)
        { setData(Qt::TextAlignmentRole, alignment); }

    inline QColor backgroundColor() const
        { return qvariant_cast<QColor>(data(Qt::BackgroundColorRole)); }
    virtual void setBackgroundColor(const QColor &color)
        { setData(Qt::BackgroundColorRole, color); }

    inline QColor textColor() const
        { return qvariant_cast<QColor>(data(Qt::TextColorRole)); }
    inline void setTextColor(const QColor &color)
        { setData(Qt::TextColorRole, color); }

    inline Qt::CheckState checkState() const
        { return static_cast<Qt::CheckState>(data(Qt::CheckStateRole).toInt()); }
    inline void setCheckState(Qt::CheckState state)
        { setData(Qt::CheckStateRole, state); }

    inline QSize sizeHint() const
        { return qvariant_cast<QSize>(data(Qt::SizeHintRole)); }
    inline void setSizeHint(const QSize &size)
        { setData(Qt::SizeHintRole, size); }

    virtual QVariant data(int role) const;
    virtual void setData(int role, const QVariant &value);

    virtual bool operator<(const QListWidgetItem &other) const;


    virtual void read(QDataStream &in);
    virtual void write(QDataStream &out) const;

    QListWidgetItem &operator=(const QListWidgetItem &other);

    inline int type() const { return rtti; }

private:
    int rtti;
    QVector<QWidgetItemData> values;
    QListWidget *view;
    QListModel *model;
    Qt::ItemFlags itemFlags;
};

inline void QListWidgetItem::setFlags(Qt::ItemFlags aflags)
{ itemFlags = aflags; }

inline void QListWidgetItem::setText(const QString &atext)
{ setData(Qt::DisplayRole, atext); }

inline void QListWidgetItem::setIcon(const QIcon &aicon)
{ setData(Qt::DecorationRole, aicon); }

inline void QListWidgetItem::setStatusTip(const QString &astatusTip)
{ setData(Qt::StatusTipRole, astatusTip); }

inline void QListWidgetItem::setToolTip(const QString &atoolTip)
{ setData(Qt::ToolTipRole, atoolTip); }

inline void QListWidgetItem::setWhatsThis(const QString &awhatsThis)
{ setData(Qt::WhatsThisRole, awhatsThis); }

inline void QListWidgetItem::setFont(const QFont &afont)
{ setData(Qt::FontRole, afont); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QListWidgetItem &item);
__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QListWidgetItem &item);


class QListWidgetPrivate;

class __declspec(dllimport) QListWidget : public QListView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



    friend class QListWidgetItem;
    friend class QListModel;
public:
    explicit QListWidget(QWidget *parent = 0);
    ~QListWidget();

    QListWidgetItem *item(int row) const;
    int row(const QListWidgetItem *item) const;
    void insertItem(int row, QListWidgetItem *item);
    void insertItem(int row, const QString &label);
    void insertItems(int row, const QStringList &labels);
    inline void addItem(const QString &label) { insertItem(count(), label); }
    inline void addItem(QListWidgetItem *item);
    inline void addItems(const QStringList &labels) { insertItems(count(), labels); }
    QListWidgetItem *takeItem(int row);
    int count() const;

    QListWidgetItem *currentItem() const;
    void setCurrentItem(QListWidgetItem *item);

    int currentRow() const;
    void setCurrentRow(int row);

    QListWidgetItem *itemAt(const QPoint &p) const;
    inline QListWidgetItem *itemAt(int x, int y) const;
    QRect visualItemRect(const QListWidgetItem *item) const;

    void sortItems(Qt::SortOrder order = Qt::AscendingOrder);

    void editItem(QListWidgetItem *item);
    void openPersistentEditor(QListWidgetItem *item);
    void closePersistentEditor(QListWidgetItem *item);

    QWidget *itemWidget(QListWidgetItem *item) const;
    void setItemWidget(QListWidgetItem *item, QWidget *widget);

    bool isItemSelected(const QListWidgetItem *item) const;
    void setItemSelected(const QListWidgetItem *item, bool select);
    QList<QListWidgetItem*> selectedItems() const;
    QList<QListWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags) const;

    bool isItemHidden(const QListWidgetItem *item) const;
    void setItemHidden(const QListWidgetItem *item, bool hide);

public :
    void scrollToItem(const QListWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible);
    void clear();

protected:
    void itemPressed(QListWidgetItem *item);
    void itemClicked(QListWidgetItem *item);
    void itemDoubleClicked(QListWidgetItem *item);
    void itemActivated(QListWidgetItem *item);
    void itemEntered(QListWidgetItem *item);
    void itemChanged(QListWidgetItem *item);

    void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous);
    void currentTextChanged(const QString &currentText);
    void currentRowChanged(int currentRow);

    void itemSelectionChanged();

protected:
    virtual QStringList mimeTypes() const;
    virtual QMimeData *mimeData(const QList<QListWidgetItem*> items) const;
    virtual bool dropMimeData(int index, const QMimeData *data, Qt::DropAction action);
    virtual Qt::DropActions supportedDropActions() const;
    QList<QListWidgetItem*> items(const QMimeData *data) const;

    QModelIndex indexFromItem(QListWidgetItem *item) const;
    QListWidgetItem *itemFromIndex(const QModelIndex &index) const;

private:
    void setModel(QAbstractItemModel *model);

    inline QListWidgetPrivate* d_func() { return reinterpret_cast<QListWidgetPrivate *>(d_ptr); } inline const QListWidgetPrivate* d_func() const { return reinterpret_cast<const QListWidgetPrivate *>(d_ptr); } friend class QListWidgetPrivate;
    QListWidget(const QListWidget &); QListWidget &operator=(const QListWidget &);








};

inline void QListWidget::addItem(QListWidgetItem *aitem)
{ insertItem(count(), aitem); }

inline QListWidgetItem *QListWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }






























































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QProxyModelPrivate;

class __declspec(dllimport) QProxyModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QProxyModel(QObject *parent = 0);
    ~QProxyModel();

    virtual void setModel(QAbstractItemModel *model);
    QAbstractItemModel *model() const;



    QModelIndex index(int row, int column, const QModelIndex &parent) const;
    QModelIndex parent(const QModelIndex &child) const;

    int rowCount(const QModelIndex &parent) const;
    int columnCount(const QModelIndex &parent) const;
    bool hasChildren(const QModelIndex &parent) const;

    QVariant data(const QModelIndex &index, int role) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role);

    QVariant headerData(int section, Qt::Orientation orientation, int role) const;
    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
                       int role);

    QStringList mimeTypes() const;
    QMimeData *mimeData(const QModelIndexList &indexes) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);
    Qt::DropActions supportedDropActions() const;

    bool insertRows(int row, int count, const QModelIndex &parent);
    bool insertColumns(int column, int count, const QModelIndex &parent);

    void fetchMore(const QModelIndex &parent);
    Qt::ItemFlags flags(const QModelIndex &index) const;

    void sort(int column, Qt::SortOrder order);

    QModelIndexList match(const QModelIndex &start, int role, const QVariant &value,
                          int hits, Qt::MatchFlags flags) const;

    QSize span(const QModelIndex &index) const;

    bool submit();
    void revert();

protected:
    QProxyModel(QProxyModelPrivate &, QObject *parent = 0);

private:
    inline QProxyModelPrivate* d_func() { return reinterpret_cast<QProxyModelPrivate *>(d_ptr); } inline const QProxyModelPrivate* d_func() const { return reinterpret_cast<const QProxyModelPrivate *>(d_ptr); } friend class QProxyModelPrivate;
    QProxyModel(const QProxyModel &); QProxyModel &operator=(const QProxyModel &);
};






















































































































class QSortingProxyModelPrivate;

class __declspec(dllimport) QSortingProxyModel : public QMappingProxyModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QSortingProxyModel(QObject *parent = 0);
    ~QSortingProxyModel();

    void sort(int column, Qt::SortOrder order);
    void clear();

    typedef bool(Compare)(const QModelIndex &left, const QModelIndex &right);
    void setLessThan(Compare *function);
    void setGreaterThan(Compare *function);

protected:
    QSortingProxyModel(QSortingProxyModelPrivate &, QObject *parent);
    void sourceLayoutChanged();

private:
    inline QSortingProxyModelPrivate* d_func() { return reinterpret_cast<QSortingProxyModelPrivate *>(d_ptr); } inline const QSortingProxyModelPrivate* d_func() const { return reinterpret_cast<const QSortingProxyModelPrivate *>(d_ptr); } friend class QSortingProxyModelPrivate;
    QSortingProxyModel(const QSortingProxyModel &); QSortingProxyModel &operator=(const QSortingProxyModel &);
};































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QStandardItemModelPrivate;

class __declspec(dllimport) QStandardItemModel : public QAbstractItemModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QStandardItemModel(QObject *parent = 0);
    QStandardItemModel(int rows, int columns, QObject *parent = 0);
    ~QStandardItemModel();

    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    QModelIndex parent(const QModelIndex &child) const;

    int rowCount(const QModelIndex &parent = QModelIndex()) const;
    int columnCount(const QModelIndex &parent = QModelIndex()) const;
    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    QVariant headerData(int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
                       int role = Qt::EditRole);

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

    Qt::ItemFlags flags(const QModelIndex &index) const;

    void clear();

private:
    inline QStandardItemModelPrivate* d_func() { return reinterpret_cast<QStandardItemModelPrivate *>(d_ptr); } inline const QStandardItemModelPrivate* d_func() const { return reinterpret_cast<const QStandardItemModelPrivate *>(d_ptr); } friend class QStandardItemModelPrivate;
    QStandardItemModel(const QStandardItemModel &); QStandardItemModel &operator=(const QStandardItemModel &);
};















































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QStringListModel : public QAbstractListModel
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QStringListModel(QObject *parent = 0);
    QStringListModel(const QStringList &strings, QObject *parent = 0);

    int rowCount(const QModelIndex &parent = QModelIndex()) const;

    QVariant data(const QModelIndex &index, int role) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    Qt::ItemFlags flags(const QModelIndex &index) const;

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());

    QStringList stringList() const;
    void setStringList(const QStringList &strings);

private:
    QStringListModel(const QStringListModel &); QStringListModel &operator=(const QStringListModel &);
    QStringList lst;
};
































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QHeaderView;
class QTableViewPrivate;

class __declspec(dllimport) QTableView : public QAbstractItemView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QTableView(QWidget *parent = 0);
    ~QTableView();

    void setModel(QAbstractItemModel *model);
    void setRootIndex(const QModelIndex &index);
    void setSelectionModel(QItemSelectionModel *selectionModel);

    QHeaderView *horizontalHeader() const;
    QHeaderView *verticalHeader() const;
    void setHorizontalHeader(QHeaderView *header);
    void setVerticalHeader(QHeaderView *header);

    int rowViewportPosition(int row) const;
    int rowHeight(int row) const;
    int rowAt(int y) const;

    int columnViewportPosition(int column) const;
    int columnWidth(int column) const;
    int columnAt(int x) const;

    bool isRowHidden(int row) const;
    void setRowHidden(int row, bool hide);

    bool isColumnHidden(int column) const;
    void setColumnHidden(int column, bool hide);

    bool showGrid() const;

    Qt::PenStyle gridStyle() const;
    void setGridStyle(Qt::PenStyle style);

    QRect visualRect(const QModelIndex &index) const;
    void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
    QModelIndex indexAt(const QPoint &p) const;

public :
    void selectRow(int row);
    void selectColumn(int column);
    void hideRow(int row);
    void hideColumn(int column);
    void showRow(int row);
    void showColumn(int column);
    void resizeRowToContents(int row);
    void resizeColumnToContents(int column);
    void sortByColumn(int column);
    void setShowGrid(bool show);

protected :
    void rowMoved(int row, int oldIndex, int newIndex);
    void columnMoved(int column, int oldIndex, int newIndex);
    void rowResized(int row, int oldHeight, int newHeight);
    void columnResized(int column, int oldWidth, int newWidth);
    void rowCountChanged(int oldCount, int newCount);
    void columnCountChanged(int oldCount, int newCount);

protected:
    QTableView(QTableViewPrivate &, QWidget *parent);
    void scrollContentsBy(int dx, int dy);

    QStyleOptionViewItem viewOptions() const;
    void paintEvent(QPaintEvent *e);

    int horizontalOffset() const;
    int verticalOffset() const;
    QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);

    void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
    QRegion visualRegionForSelection(const QItemSelection &selection) const;
    QModelIndexList selectedIndexes() const;

    void updateGeometries();

    int sizeHintForRow(int row) const;
    int sizeHintForColumn(int column) const;

    void verticalScrollbarAction(int action);
    void horizontalScrollbarAction(int action);

    bool isIndexHidden(const QModelIndex &index) const;

private:
    inline QTableViewPrivate* d_func() { return reinterpret_cast<QTableViewPrivate *>(d_ptr); } inline const QTableViewPrivate* d_func() const { return reinterpret_cast<const QTableViewPrivate *>(d_ptr); } friend class QTableViewPrivate;
    QTableView(const QTableView &); QTableView &operator=(const QTableView &);
};

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QTableWidgetSelectionRange
{
public:
    QTableWidgetSelectionRange();
    QTableWidgetSelectionRange(int top, int left, int bottom, int right);
    QTableWidgetSelectionRange(const QTableWidgetSelectionRange &other);
    ~QTableWidgetSelectionRange();

    inline int topRow() const { return top; }
    inline int bottomRow() const { return bottom; }
    inline int leftColumn() const { return left; }
    inline int rightColumn() const { return right; }
    inline int rowCount() const { return bottom - top + 1; }
    inline int columnCount() const { return right - left + 1; }

private:
    int top, left, bottom, right;
};

class QTableWidget;
class QTableModel;
class QWidgetItemData;

class __declspec(dllimport) QTableWidgetItem
{
    friend class QTableWidget;
    friend class QTableModel;
public:
    enum { Type = 0, UserType = 1000 };
    QTableWidgetItem(int type = Type);
    explicit QTableWidgetItem(const QString &text, int type = Type);
    QTableWidgetItem(const QTableWidgetItem &other);
    virtual ~QTableWidgetItem();

    virtual QTableWidgetItem *clone() const;

    inline QTableWidget *tableWidget() const { return view; }

    inline Qt::ItemFlags flags() const { return itemFlags; }
    inline void setFlags(Qt::ItemFlags flags);

    inline QString text() const
        { return data(Qt::DisplayRole).toString(); }
    inline void setText(const QString &text);

    inline QIcon icon() const
        { return qvariant_cast<QIcon>(data(Qt::DecorationRole)); }
    inline void setIcon(const QIcon &icon);

    inline QString statusTip() const
        { return data(Qt::StatusTipRole).toString(); }
    inline void setStatusTip(const QString &statusTip);

    inline QString toolTip() const
        { return data(Qt::ToolTipRole).toString(); }
    inline void setToolTip(const QString &toolTip);

    inline QString whatsThis() const
        { return data(Qt::WhatsThisRole).toString(); }
    inline void setWhatsThis(const QString &whatsThis);

    inline QFont font() const
        { return qvariant_cast<QFont>(data(Qt::FontRole)); }
    inline void setFont(const QFont &font);

    inline int textAlignment() const
        { return data(Qt::TextAlignmentRole).toInt(); }
    inline void setTextAlignment(int alignment)
        { setData(Qt::TextAlignmentRole, alignment); }

    inline QColor backgroundColor() const
        { return qvariant_cast<QColor>(data(Qt::BackgroundColorRole)); }
    inline void setBackgroundColor(const QColor &color)
        { setData(Qt::BackgroundColorRole, color); }

    inline QColor textColor() const
        { return qvariant_cast<QColor>(data(Qt::TextColorRole)); }
    inline void setTextColor(const QColor &color)
        { setData(Qt::TextColorRole, color); }

    inline Qt::CheckState checkState() const
        { return static_cast<Qt::CheckState>(data(Qt::CheckStateRole).toInt()); }
    inline void setCheckState(Qt::CheckState state)
        { setData(Qt::CheckStateRole, state); }

    inline QSize sizeHint() const
        { return qvariant_cast<QSize>(data(Qt::SizeHintRole)); }
    inline void setSizeHint(const QSize &size)
        { setData(Qt::SizeHintRole, size); }

    virtual QVariant data(int role) const;
    virtual void setData(int role, const QVariant &value);

    virtual bool operator<(const QTableWidgetItem &other) const;


    virtual void read(QDataStream &in);
    virtual void write(QDataStream &out) const;

    QTableWidgetItem &operator=(const QTableWidgetItem &other);

    inline int type() const { return rtti; }

private:
    int rtti;
    QVector<QWidgetItemData> values;
    QTableWidget *view;
    QTableModel *model;
    Qt::ItemFlags itemFlags;
};

inline void QTableWidgetItem::setFlags(Qt::ItemFlags aflags)
{ itemFlags = aflags; }

inline void QTableWidgetItem::setText(const QString &atext)
{ setData(Qt::DisplayRole, atext); }

inline void QTableWidgetItem::setIcon(const QIcon &aicon)
{ setData(Qt::DecorationRole, aicon); }

inline void QTableWidgetItem::setStatusTip(const QString &astatusTip)
{ setData(Qt::StatusTipRole, astatusTip); }

inline void QTableWidgetItem::setToolTip(const QString &atoolTip)
{ setData(Qt::ToolTipRole, atoolTip); }

inline void QTableWidgetItem::setWhatsThis(const QString &awhatsThis)
{ setData(Qt::WhatsThisRole, awhatsThis); }

inline void QTableWidgetItem::setFont(const QFont &afont)
{ setData(Qt::FontRole, afont); }


__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QTableWidgetItem &item);
__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QTableWidgetItem &item);


class QTableWidgetPrivate;

class __declspec(dllimport) QTableWidget : public QTableView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




    friend class QTableModel;
public:
    explicit QTableWidget(QWidget *parent = 0);
    QTableWidget(int rows, int columns, QWidget *parent = 0);
    ~QTableWidget();

    void setRowCount(int rows);
    int rowCount() const;

    void setColumnCount(int columns);
    int columnCount() const;

    int row(const QTableWidgetItem *item) const;
    int column(const QTableWidgetItem *item) const;

    QTableWidgetItem *item(int row, int column) const;
    void setItem(int row, int column, QTableWidgetItem *item);
    QTableWidgetItem *takeItem(int row, int column);

    QTableWidgetItem *verticalHeaderItem(int row) const;
    void setVerticalHeaderItem(int row, QTableWidgetItem *item);

    QTableWidgetItem *horizontalHeaderItem(int column) const;
    void setHorizontalHeaderItem(int column, QTableWidgetItem *item);
    void setVerticalHeaderLabels(const QStringList &labels);
    void setHorizontalHeaderLabels(const QStringList &labels);

    int currentRow() const;
    int currentColumn() const;
    QTableWidgetItem *currentItem() const;
    void setCurrentItem(QTableWidgetItem *item);
    void setCurrentCell(int row, int column);

    void sortItems(int column, Qt::SortOrder order = Qt::AscendingOrder);
    void setSortingEnabled(bool enable);
    bool isSortingEnabled() const;

    void editItem(QTableWidgetItem *item);
    void openPersistentEditor(QTableWidgetItem *item);
    void closePersistentEditor(QTableWidgetItem *item);

    QWidget *cellWidget(int row, int column) const;
    void setCellWidget(int row, int column, QWidget *widget);

    bool isItemSelected(const QTableWidgetItem *item) const;
    void setItemSelected(const QTableWidgetItem *item, bool select);
    void setRangeSelected(const QTableWidgetSelectionRange &range, bool select);

    QList<QTableWidgetSelectionRange> selectedRanges() const;
    QList<QTableWidgetItem*> selectedItems();
    QList<QTableWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags) const;

    int visualRow(int logicalRow) const;
    int visualColumn(int logicalColumn) const;

    QTableWidgetItem *itemAt(const QPoint &p) const;
    inline QTableWidgetItem *itemAt(int x, int y) const;
    QRect visualItemRect(const QTableWidgetItem *item) const;

    const QTableWidgetItem *itemPrototype() const;
    void setItemPrototype(const QTableWidgetItem *item);

public :
    void scrollToItem(const QTableWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible);
    void insertRow(int row);
    void insertColumn(int column);
    void removeRow(int row);
    void removeColumn(int column);
    void clear();

protected:
    void itemPressed(QTableWidgetItem *item);
    void itemClicked(QTableWidgetItem *item);
    void itemDoubleClicked(QTableWidgetItem *item);

    void itemActivated(QTableWidgetItem *item);
    void itemEntered(QTableWidgetItem *item);
    void itemChanged(QTableWidgetItem *item);

    void currentItemChanged(QTableWidgetItem *current, QTableWidgetItem *previous);
    void itemSelectionChanged();

protected:
    virtual QStringList mimeTypes() const;
    virtual QMimeData *mimeData(const QList<QTableWidgetItem*> items) const;
    virtual bool dropMimeData(int row, int column, const QMimeData *data, Qt::DropAction action);
    virtual Qt::DropActions supportedDropActions() const;
    QList<QTableWidgetItem*> items(const QMimeData *data) const;

    QModelIndex indexFromItem(QTableWidgetItem *item) const;
    QTableWidgetItem *itemFromIndex(const QModelIndex &index) const;

private:
    void setModel(QAbstractItemModel *model);

    inline QTableWidgetPrivate* d_func() { return reinterpret_cast<QTableWidgetPrivate *>(d_ptr); } inline const QTableWidgetPrivate* d_func() const { return reinterpret_cast<const QTableWidgetPrivate *>(d_ptr); } friend class QTableWidgetPrivate;
    QTableWidget(const QTableWidget &); QTableWidget &operator=(const QTableWidget &);








};

inline QTableWidgetItem *QTableWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }
































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QTreeViewPrivate;
class QHeaderView;

class __declspec(dllimport) QTreeView : public QAbstractItemView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:





public:
    explicit QTreeView(QWidget *parent = 0);
    ~QTreeView();

    void setModel(QAbstractItemModel *model);
    void setRootIndex(const QModelIndex &index);
    void setSelectionModel(QItemSelectionModel *selectionModel);

    QHeaderView *header() const;
    void setHeader(QHeaderView *header);

    int indentation() const;
    void setIndentation(int i);

    bool rootIsDecorated() const;
    void setRootIsDecorated(bool show);

    bool uniformRowHeights() const;
    void setUniformRowHeights(bool uniform);

    bool itemsExpandable() const;
    void setItemsExpandable(bool enable);

    int columnViewportPosition(int column) const;
    int columnWidth(int column) const;
    int columnAt(int x) const;

    bool isColumnHidden(int column) const;
    void setColumnHidden(int column, bool hide);

    bool isRowHidden(int row, const QModelIndex &parent) const;
    void setRowHidden(int row, const QModelIndex &parent, bool hide);

    bool isExpanded(const QModelIndex &index) const;
    void setExpanded(const QModelIndex &index, bool expand);

    QRect visualRect(const QModelIndex &index) const;
    void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
    QModelIndex indexAt(const QPoint &p) const;
    QModelIndex indexAbove(const QModelIndex &index) const;
    QModelIndex indexBelow(const QModelIndex &index) const;

    void doItemsLayout();
    void reset();

protected:
    void expanded(const QModelIndex &index);
    void collapsed(const QModelIndex &index);

public :
    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void hideColumn(int column);
    void showColumn(int column);
    void expand(const QModelIndex &index);
    void collapse(const QModelIndex &index);
    void resizeColumnToContents(int column);
    void sortByColumn(int column);
    void selectAll();

protected :
    void columnResized(int column, int oldSize, int newSize);
    void columnCountChanged(int oldCount, int newCount);
    void columnMoved();
    void reexpand();

protected:
    QTreeView(QTreeViewPrivate &dd, QWidget *parent = 0);
    void scrollContentsBy(int dx, int dy);
    void rowsInserted(const QModelIndex &parent, int start, int end);
    void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);

    QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);
    int horizontalOffset() const;
    int verticalOffset() const;

    void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
    QRegion visualRegionForSelection(const QItemSelection &selection) const;
    QModelIndexList selectedIndexes() const;

    void paintEvent(QPaintEvent *e);
    virtual void drawRow(QPainter *painter,
                         const QStyleOptionViewItem &options,
                         const QModelIndex &index) const;
    virtual void drawBranches(QPainter *painter,
                              const QRect &rect,
                              const QModelIndex &index) const;

    void mousePressEvent(QMouseEvent *e);
    void mouseDoubleClickEvent(QMouseEvent *e);

    void updateGeometries();

    int sizeHintForColumn(int column) const;
    int indexRowSizeHint(const QModelIndex &index) const;

    bool isIndexHidden(const QModelIndex &index) const;

private:
    inline QTreeViewPrivate* d_func() { return reinterpret_cast<QTreeViewPrivate *>(d_ptr); } inline const QTreeViewPrivate* d_func() const { return reinterpret_cast<const QTreeViewPrivate *>(d_ptr); } friend class QTreeViewPrivate;
    QTreeView(const QTreeView &); QTreeView &operator=(const QTreeView &);
};






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class QTreeWidget;
class QTreeWidgetItem;
class QTreeModel;

class __declspec(dllimport) QTreeWidgetItemIterator
{
    friend class QTreeModel;

public:
    enum IteratorFlag {
        All           = 0x00000000,
        Hidden        = 0x00000001,
        NotHidden     = 0x00000002,
        Selected      = 0x00000004,
        Unselected    = 0x00000008,
        Selectable    = 0x00000010,
        NotSelectable = 0x00000020,
        DragEnabled   = 0x00000040,
        DragDisabled  = 0x00000080,
        DropEnabled   = 0x00000100,
        DropDisabled  = 0x00000200,
        HasChildren   = 0x00000400,
        NoChildren    = 0x00000800,
        Checked       = 0x00001000,
        NotChecked    = 0x00002000,
        Enabled       = 0x00004000,
        Disabled      = 0x00008000,
        Editable      = 0x00010000,
        NotEditable   = 0x00020000,
        UserFlag      = 0x01000000
    };
    typedef QFlags<IteratorFlag> IteratorFlags;

    QTreeWidgetItemIterator(const QTreeWidgetItemIterator &it);
    explicit QTreeWidgetItemIterator(QTreeWidget *widget, IteratorFlags flags = All);
    explicit QTreeWidgetItemIterator(QTreeWidgetItem *item, IteratorFlags flags = All);
    ~QTreeWidgetItemIterator();

    QTreeWidgetItemIterator &operator=(const QTreeWidgetItemIterator &it);

    QTreeWidgetItemIterator &operator++();
    inline const QTreeWidgetItemIterator operator++(int);
    inline QTreeWidgetItemIterator &operator+=(int n);

    QTreeWidgetItemIterator &operator--();
    inline const QTreeWidgetItemIterator operator--(int);
    inline QTreeWidgetItemIterator &operator-=(int n);

    inline QTreeWidgetItem *operator*() const;

protected:
    bool matchesFlags(const QTreeWidgetItem *item) const;
    QTreeModel *model;
    QTreeWidgetItem *current;
    IteratorFlags flags;
};

inline const QTreeWidgetItemIterator QTreeWidgetItemIterator::operator++(int)
{
    QTreeWidgetItemIterator it = *this;
    ++(*this);
    return it;
}

inline const QTreeWidgetItemIterator QTreeWidgetItemIterator::operator--(int)
{
    QTreeWidgetItemIterator it = *this;
    --(*this);
    return it;
}

inline QTreeWidgetItemIterator &QTreeWidgetItemIterator::operator+=(int n)
{
    if (n < 0)
        return (*this) -= (-n);
    while (current && n--)
        ++(*this);
    return *this;
}

inline QTreeWidgetItemIterator &QTreeWidgetItemIterator::operator-=(int n)
{
    if (n < 0)
        return (*this) += (-n);
    while (current && n--)
        --(*this);
    return *this;
}

inline QTreeWidgetItem *QTreeWidgetItemIterator::operator*() const
{
    return current;
}

inline QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> operator|(QTreeWidgetItemIterator::IteratorFlags::enum_type f1, QTreeWidgetItemIterator::IteratorFlags::enum_type f2) { return QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type>(f1) | f2; } inline QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> operator|(QTreeWidgetItemIterator::IteratorFlags::enum_type f1, QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> f2) { return f2 | f1; }









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QTreeWidget;
class QTreeModel;
class QWidgetItemData;

class __declspec(dllimport) QTreeWidgetItem
{
    friend class QTreeModel;
    friend class QTreeWidget;
    friend class QTreeWidgetItemIterator;
public:
    enum { Type = 0, UserType = 1000 };
    QTreeWidgetItem(int type = Type);
    QTreeWidgetItem(const QStringList &strings, int type = Type);
    explicit QTreeWidgetItem(QTreeWidget *view, int type = Type);
    QTreeWidgetItem(QTreeWidget *view, const QStringList &strings, int type = Type);
    QTreeWidgetItem(QTreeWidget *view, QTreeWidgetItem *after, int type = Type);
    explicit QTreeWidgetItem(QTreeWidgetItem *parent, int type = Type);
    QTreeWidgetItem(QTreeWidgetItem *parent, const QStringList &strings, int type = Type);
    QTreeWidgetItem(QTreeWidgetItem *parent, QTreeWidgetItem *after, int type = Type);
    QTreeWidgetItem(const QTreeWidgetItem &other);
    virtual ~QTreeWidgetItem();

    virtual QTreeWidgetItem *clone() const;

    inline QTreeWidget *treeWidget() const { return view; }

    inline Qt::ItemFlags flags() const { return itemFlags; }
    inline void setFlags(Qt::ItemFlags flags);

    inline QString text(int column) const
        { return data(column, Qt::DisplayRole).toString(); }
    inline void setText(int column, const QString &text);

    inline QIcon icon(int column) const
        { return qvariant_cast<QIcon>(data(column, Qt::DecorationRole)); }
    inline void setIcon(int column, const QIcon &icon);

    inline QString statusTip(int column) const
        { return data(column, Qt::StatusTipRole).toString(); }
    inline void setStatusTip(int column, const QString &statusTip);

    inline QString toolTip(int column) const
        { return data(column, Qt::ToolTipRole).toString(); }
    inline void setToolTip(int column, const QString &toolTip);

    inline QString whatsThis(int column) const
        { return data(column, Qt::WhatsThisRole).toString(); }
    inline void setWhatsThis(int column, const QString &whatsThis);

    inline QFont font(int column) const
        { return qvariant_cast<QFont>(data(column, Qt::FontRole)); }
    inline void setFont(int column, const QFont &font);

    inline int textAlignment(int column) const
        { return data(column, Qt::TextAlignmentRole).toInt(); }
    inline void setTextAlignment(int column, int alignment)
        { setData(column, Qt::TextAlignmentRole, alignment); }

    inline QColor backgroundColor(int column) const
        { return qvariant_cast<QColor>(data(column, Qt::BackgroundColorRole)); }
    inline void setBackgroundColor(int column, const QColor &color)
        { setData(column, Qt::BackgroundColorRole, color); }

    inline QColor textColor(int column) const
        { return qvariant_cast<QColor>(data(column, Qt::TextColorRole)); }
    inline void setTextColor(int column, const QColor &color)
        { setData(column, Qt::TextColorRole, color); }

    inline Qt::CheckState checkState(int column) const
        { return static_cast<Qt::CheckState>(data(column, Qt::CheckStateRole).toInt()); }
    inline void setCheckState(int column, Qt::CheckState state)
        { setData(column, Qt::CheckStateRole, state); }

    inline QSize sizeHint(int column) const
        { return qvariant_cast<QSize>(data(column, Qt::SizeHintRole)); }
    inline void setSizeHint(int column, const QSize &size)
        { setData(column, Qt::SizeHintRole, size); }

    virtual QVariant data(int column, int role) const;
    virtual void setData(int column, int role, const QVariant &value);

    virtual bool operator<(const QTreeWidgetItem &other) const;


    virtual void read(QDataStream &in);
    virtual void write(QDataStream &out) const;

    QTreeWidgetItem &operator=(const QTreeWidgetItem &other);

    inline QTreeWidgetItem *parent() const { return par; }
    inline QTreeWidgetItem *child(int index) const
        { if (index < 0 || index >= children.size()) return 0; return children.at(index); }
    inline int childCount() const { return children.count(); }
    inline int columnCount() const { return values.count(); }
    inline int indexOfChild(QTreeWidgetItem *child) const;

    void addChild(QTreeWidgetItem *child);
    void insertChild(int index, QTreeWidgetItem *child);
    QTreeWidgetItem *takeChild(int index);

    void addChildren(const QList<QTreeWidgetItem*> &children);
    void insertChildren(int index, const QList<QTreeWidgetItem*> &children);
    QList<QTreeWidgetItem*> takeChildren();

    inline int type() const { return rtti; }

private:
    void sortChildren(int column, Qt::SortOrder order, bool climb);
    QVariant childrenCheckState(int column) const;

    int rtti;

    QVector< QVector<QWidgetItemData> > values;
    QTreeWidget *view;
    QTreeModel *model;
    QTreeWidgetItem *par;
    QList<QTreeWidgetItem*> children;
    Qt::ItemFlags itemFlags;
};

inline void QTreeWidgetItem::setFlags(Qt::ItemFlags aflags)
{ itemFlags = aflags; }

inline void QTreeWidgetItem::setText(int column, const QString &atext)
{ setData(column, Qt::DisplayRole, atext); }

inline void QTreeWidgetItem::setIcon(int column, const QIcon &aicon)
{ setData(column, Qt::DecorationRole, aicon); }

inline void QTreeWidgetItem::setStatusTip(int column, const QString &astatusTip)
{ setData(column, Qt::StatusTipRole, astatusTip); }

inline void QTreeWidgetItem::setToolTip(int column, const QString &atoolTip)
{ setData(column, Qt::ToolTipRole, atoolTip); }

inline void QTreeWidgetItem::setWhatsThis(int column, const QString &awhatsThis)
{ setData(column, Qt::WhatsThisRole, awhatsThis); }

inline void QTreeWidgetItem::setFont(int column, const QFont &afont)
{ setData(column, Qt::FontRole, afont); }

inline int QTreeWidgetItem::indexOfChild(QTreeWidgetItem *achild) const
{ return children.indexOf(achild); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QTreeWidgetItem &item);
__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QTreeWidgetItem &item);


class QTreeWidgetPrivate;

class __declspec(dllimport) QTreeWidget : public QTreeView
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




    friend class QTreeModel;
public:
    explicit QTreeWidget(QWidget *parent = 0);
    ~QTreeWidget();

    int columnCount() const;
    void setColumnCount(int columns);

    QTreeWidgetItem *topLevelItem(int index) const;
    int topLevelItemCount() const;
    void insertTopLevelItem(int index, QTreeWidgetItem *item);
    void addTopLevelItem(QTreeWidgetItem *item);
    QTreeWidgetItem *takeTopLevelItem(int index);
    int indexOfTopLevelItem(QTreeWidgetItem *item);

    void insertTopLevelItems(int index, const QList<QTreeWidgetItem*> &items);
    void addTopLevelItems(const QList<QTreeWidgetItem*> &items);

    QTreeWidgetItem *headerItem() const;
    void setHeaderItem(QTreeWidgetItem *item);
    void setHeaderLabels(const QStringList &labels);

    QTreeWidgetItem *currentItem() const;
    void setCurrentItem(QTreeWidgetItem *item);

    QTreeWidgetItem *itemAt(const QPoint &p) const;
    inline QTreeWidgetItem *itemAt(int x, int y) const;
    QRect visualItemRect(const QTreeWidgetItem *item) const;

    void sortItems(int column, Qt::SortOrder order);
    void setSortingEnabled(bool enable);
    bool isSortingEnabled() const;

    void editItem(QTreeWidgetItem *item, int column = 0);
    void openPersistentEditor(QTreeWidgetItem *item, int column = 0);
    void closePersistentEditor(QTreeWidgetItem *item, int column = 0);

    QWidget *itemWidget(QTreeWidgetItem *item, int column) const;
    void setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget);

    bool isItemSelected(const QTreeWidgetItem *item) const;
    void setItemSelected(const QTreeWidgetItem *item, bool select);
    QList<QTreeWidgetItem*> selectedItems() const;
    QList<QTreeWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags, int column = 0) const;

    bool isItemHidden(const QTreeWidgetItem *item) const;
    void setItemHidden(const QTreeWidgetItem *item, bool hide);

    bool isItemExpanded(const QTreeWidgetItem *item) const;
    void setItemExpanded(const QTreeWidgetItem *item, bool expand);

public :
    void scrollToItem(const QTreeWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible);
    void expandItem(const QTreeWidgetItem *item);
    void collapseItem(const QTreeWidgetItem *item);
    void clear();

protected:
    void itemPressed(QTreeWidgetItem *item, int column);
    void itemClicked(QTreeWidgetItem *item, int column);
    void itemDoubleClicked(QTreeWidgetItem *item, int column);
    void itemActivated(QTreeWidgetItem *item, int column);
    void itemEntered(QTreeWidgetItem *item, int column);
    void itemChanged(QTreeWidgetItem *item, int column);
    void itemExpanded(QTreeWidgetItem *item);
    void itemCollapsed(QTreeWidgetItem *item);
    void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous);
    void itemSelectionChanged();

protected:
    virtual QStringList mimeTypes() const;
    virtual QMimeData *mimeData(const QList<QTreeWidgetItem*> items) const;
    virtual bool dropMimeData(QTreeWidgetItem *parent, int index,
                              const QMimeData *data, Qt::DropAction action);
    virtual Qt::DropActions supportedDropActions() const;
    QList<QTreeWidgetItem*> items(const QMimeData *data) const;

    QModelIndex indexFromItem(QTreeWidgetItem *item, int column = 0) const;
    QTreeWidgetItem *itemFromIndex(const QModelIndex &index) const;

private:
    void setModel(QAbstractItemModel *model);

    inline QTreeWidgetPrivate* d_func() { return reinterpret_cast<QTreeWidgetPrivate *>(d_ptr); } inline const QTreeWidgetPrivate* d_func() const { return reinterpret_cast<const QTreeWidgetPrivate *>(d_ptr); } friend class QTreeWidgetPrivate;
    QTreeWidget(const QTreeWidget &); QTreeWidget &operator=(const QTreeWidget &);











};

inline QTreeWidgetItem *QTreeWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QSessionManager;
class QDesktopWidget;
class QStyle;
class QEventLoop;
class QIcon;
template <typename T> class QList;
class QInputContext;





class QApplication;
class QApplicationPrivate;




class __declspec(dllimport) QApplication : public QCoreApplication
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:













public:
    QApplication(int &argc, char **argv);
    QApplication(int &argc, char **argv, bool GUIenabled);
    enum Type { Tty, GuiClient, GuiServer };
    QApplication(int &argc, char **argv, Type);




    virtual ~QApplication();

    static Type type();

    static QStyle *style();
    static void setStyle(QStyle*);
    static QStyle *setStyle(const QString&);
    enum ColorSpec { NormalColor=0, CustomColor=1, ManyColor=2 };
    static int colorSpec();
    static void setColorSpec(int);


    static QCursor *overrideCursor();
    static void setOverrideCursor(const QCursor &);
    static void changeOverrideCursor(const QCursor &);
    static void restoreOverrideCursor();

    static QPalette palette();
    static QPalette palette(const QWidget *);
    static QPalette palette(const char *className);
    static void setPalette(const QPalette &, const char* className = 0);
    static QFont font(const QWidget* = 0);
    static void setFont(const QFont &, const char* className = 0);
    static QFontMetrics fontMetrics();

    static void setWindowIcon(const QIcon &icon);
    static QIcon windowIcon();







    static QWidgetList allWidgets();
    static QWidgetList topLevelWidgets();

    static QDesktopWidget *desktop();

    static QWidget *activePopupWidget();
    static QWidget *activeModalWidget();

    static QClipboard *clipboard();

    static QWidget *focusWidget();

    static QWidget *activeWindow();
    static void setActiveWindow(QWidget* act);

    static QWidget *widgetAt(const QPoint &p);
    static inline QWidget *widgetAt(int x, int y) { return widgetAt(QPoint(x, y)); }
    static QWidget *topLevelAt(const QPoint &p);
    static inline QWidget *topLevelAt(int x, int y)  { return topLevelAt(QPoint(x, y)); }

    static void syncX();
    static void beep();

    static Qt::KeyboardModifiers keyboardModifiers();
    static Qt::MouseButtons mouseButtons();

    static void setDesktopSettingsAware(bool);
    static bool desktopSettingsAware();

    static void setCursorFlashTime(int);
    static int cursorFlashTime();

    static void setDoubleClickInterval(int);
    static int doubleClickInterval();

    static void setKeyboardInputInterval(int);
    static int keyboardInputInterval();


    static void setWheelScrollLines(int);
    static int wheelScrollLines();

    static void setGlobalStrut(const QSize &);
    static QSize globalStrut();

    static void setStartDragTime(int ms);
    static int startDragTime();
    static void setStartDragDistance(int l);
    static int startDragDistance();

    static void setLayoutDirection(Qt::LayoutDirection direction);
    static Qt::LayoutDirection layoutDirection();

    static inline bool isRightToLeft() { return layoutDirection() == Qt::RightToLeft; }
    static inline bool isLeftToRight() { return layoutDirection() == Qt::LeftToRight; }

    static bool isEffectEnabled(Qt::UIEffect);
    static void setEffectEnabled(Qt::UIEffect, bool enable = true);






















    void winFocus(QWidget *, bool);
    static void winMouseButtonUp();




    bool isSessionRestored() const;
    QString sessionId() const;
    QString sessionKey() const;
    virtual void commitData(QSessionManager& sm);
    virtual void saveState(QSessionManager& sm);

    void setInputContext(QInputContext *);
    QInputContext *inputContext() const;

    static int exec();
    bool notify(QObject *, QEvent *);


    static void setQuitOnLastWindowClosed(bool quit);
    static bool quitOnLastWindowClosed();






protected:
    void lastWindowClosed();

public :
    static void closeAllWindows();
    static void aboutQt();

protected:



    bool event(QEvent *);
    bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);







































private:
    QApplication(const QApplication &); QApplication &operator=(const QApplication &);
    inline QApplicationPrivate* d_func() { return reinterpret_cast<QApplicationPrivate *>(d_ptr); } inline const QApplicationPrivate* d_func() const { return reinterpret_cast<const QApplicationPrivate *>(d_ptr); } friend class QApplicationPrivate;

    friend class QWidget;
    friend class QWidgetPrivate;
    friend class QETWidget;
    friend class Q3AccelManager;
    friend class QTranslator;

    friend class QShortcut;

    friend class QAction;




};





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

static const int QLAYOUTSIZE_MAX = 2147483647/256/16;

class QLayout;
class QLayoutItem;
class QSpacerItem;
class QWidget;
class QSize;

class __declspec(dllimport) QLayoutItem
{
public:
    inline explicit QLayoutItem(Qt::Alignment alignment = 0);
    virtual ~QLayoutItem();
    virtual QSize sizeHint() const = 0;
    virtual QSize minimumSize() const = 0;
    virtual QSize maximumSize() const = 0;
    virtual Qt::Orientations expandingDirections() const = 0;
    virtual void setGeometry(const QRect&) = 0;
    virtual QRect geometry() const = 0;
    virtual bool isEmpty() const = 0;
    virtual bool hasHeightForWidth() const;
    virtual int heightForWidth(int) const;
    virtual int minimumHeightForWidth(int) const;
    virtual void invalidate();

    virtual QWidget *widget();
    virtual QLayout *layout();
    virtual QSpacerItem *spacerItem();

    Qt::Alignment alignment() const { return align; }
    void setAlignment(Qt::Alignment a);

protected:
    Qt::Alignment align;
};

inline QLayoutItem::QLayoutItem(Qt::Alignment aalignment)
    : align(aalignment) { }

class __declspec(dllimport) QSpacerItem : public QLayoutItem
{
public:
    QSpacerItem(int w, int h,
                 QSizePolicy::Policy hData = QSizePolicy::Minimum,
                 QSizePolicy::Policy vData = QSizePolicy::Minimum)
        : width(w), height(h), sizeP(hData, vData) { }
    void changeSize(int w, int h,
                     QSizePolicy::Policy hData = QSizePolicy::Minimum,
                     QSizePolicy::Policy vData = QSizePolicy::Minimum);
    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    Qt::Orientations expandingDirections() const;
    bool isEmpty() const;
    void setGeometry(const QRect&);
    QRect geometry() const;
    QSpacerItem *spacerItem();

private:
    int width;
    int height;
    QSizePolicy sizeP;
    QRect rect;
};

class __declspec(dllimport) QWidgetItem : public QLayoutItem
{
public:
    explicit QWidgetItem(QWidget *w) : wid(w) { }
    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    Qt::Orientations expandingDirections() const;
    bool isEmpty() const;
    void setGeometry(const QRect&);
    QRect geometry() const;
    virtual QWidget *widget();

    bool hasHeightForWidth() const;
    int heightForWidth(int) const;

private:
    QWidget *wid;
};




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QLayout;
class QSize;



























class QLayoutPrivate;

class __declspec(dllimport) QLayout : public QObject, public QLayoutItem
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QLayoutPrivate* d_func() { return reinterpret_cast<QLayoutPrivate *>(d_ptr); } inline const QLayoutPrivate* d_func() const { return reinterpret_cast<const QLayoutPrivate *>(d_ptr); } friend class QLayoutPrivate;






public:
    enum SizeConstraint {
        SetDefaultConstraint,
        SetNoConstraint,
        SetMinimumSize,
        SetFixedSize,
        SetMaximumSize,
        SetMinAndMaxSize






    };

    QLayout(QWidget *parent);
    QLayout();
    ~QLayout();

    int margin() const;
    int spacing() const;

    void setMargin(int);
    void setSpacing(int);

    bool setAlignment(QWidget *w, Qt::Alignment alignment);
    bool setAlignment(QLayout *l, Qt::Alignment alignment);



    using QLayoutItem::setAlignment;


    void setSizeConstraint(SizeConstraint);
    SizeConstraint sizeConstraint() const;




    void setMenuBar(QWidget *w);
    QWidget *menuBar() const;

    QWidget *parentWidget() const;

    void invalidate();
    QRect geometry() const;
    bool activate();
    void update();

    void addWidget(QWidget *w);
    virtual void addItem(QLayoutItem *) = 0;

    void removeWidget(QWidget *w);
    void removeItem(QLayoutItem *);

    Qt::Orientations expandingDirections() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    void setGeometry(const QRect&) = 0;
    virtual QLayoutItem *itemAt(int index) const = 0;
    virtual QLayoutItem *takeAt(int index) = 0;
    virtual int indexOf(QWidget *) const;
    virtual int count() const = 0;
    bool isEmpty() const;

    int totalHeightForWidth(int w) const;
    QSize totalMinimumSize() const;
    QSize totalMaximumSize() const;
    QSize totalSizeHint() const;
    QLayout *layout();

    void setEnabled(bool);
    bool isEnabled() const;






    static QSize closestAcceptableSize(const QWidget *w, const QSize &s);

protected:
    void widgetEvent(QEvent *);
    void childEvent(QChildEvent *e);
    void addChildLayout(QLayout *l);
    void addChildWidget(QWidget *w);




    QRect alignmentRect(const QRect&) const;
protected:
    QLayout(QLayoutPrivate &d, QLayout*, QWidget*);

private:
    QLayout(const QLayout &); QLayout &operator=(const QLayout &);

    static void activateRecursiveHelper(QLayoutItem *item);

    friend class QApplicationPrivate;
    friend class QWidget;

















};


































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QGridLayoutPrivate;

class __declspec(dllimport) QGridLayout : public QLayout
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QGridLayoutPrivate* d_func() { return reinterpret_cast<QGridLayoutPrivate *>(d_ptr); } inline const QGridLayoutPrivate* d_func() const { return reinterpret_cast<const QGridLayoutPrivate *>(d_ptr); } friend class QGridLayoutPrivate;
public:
    explicit QGridLayout(QWidget *parent);
    QGridLayout();








    ~QGridLayout();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    void setRowStretch(int row, int stretch);
    void setColumnStretch(int column, int stretch);
    int rowStretch(int row) const;
    int columnStretch(int column) const;

    void setRowMinimumHeight(int row, int minSize);
    void setColumnMinimumWidth(int column, int minSize);
    int rowMinimumHeight(int row) const;
    int columnMinimumWidth(int column) const;

    int columnCount() const;
    int rowCount() const;

    QRect cellRect(int row, int column) const;




    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    int minimumHeightForWidth(int) const;

    Qt::Orientations expandingDirections() const;
    void invalidate();

    inline void addWidget(QWidget *w) { QLayout::addWidget(w); }
    void addWidget(QWidget *, int row, int column, Qt::Alignment = 0);
    void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);
    void addLayout(QLayout *, int row, int column, Qt::Alignment = 0);
    void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);

    void setOriginCorner(Qt::Corner);
    Qt::Corner originCorner() const;





    QLayoutItem *itemAt(int) const;
    QLayoutItem *takeAt(int);
    int count() const;
    void setGeometry(const QRect&);

    void addItem(QLayoutItem *item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment = 0);

    void setDefaultPositioning(int n, Qt::Orientation orient);
    void getItemPosition(int idx, int *row, int *column, int *rowSpan, int *columnSpan);

protected:



    void addItem(QLayoutItem *);

private:
    QGridLayout(const QGridLayout &); QGridLayout &operator=(const QGridLayout &);






















};













typedef QtValidLicenseForGuiModule QtGuiModule;

class QBoxLayoutPrivate;

class __declspec(dllimport) QBoxLayout : public QLayout
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QBoxLayoutPrivate* d_func() { return reinterpret_cast<QBoxLayoutPrivate *>(d_ptr); } inline const QBoxLayoutPrivate* d_func() const { return reinterpret_cast<const QBoxLayoutPrivate *>(d_ptr); } friend class QBoxLayoutPrivate;
public:
    enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop,
                     Down = TopToBottom, Up = BottomToTop };

    explicit QBoxLayout(Direction, QWidget *parent = 0);








    ~QBoxLayout();

    Direction direction() const;
    void setDirection(Direction);

    void addSpacing(int size);
    void addStretch(int stretch = 0);
    void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0);
    void addLayout(QLayout *layout, int stretch = 0);
    void addStrut(int);
    void addItem(QLayoutItem *);

    void insertSpacing(int index, int size);
    void insertStretch(int index, int stretch = 0);
    void insertWidget(int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0);
    void insertLayout(int index, QLayout *layout, int stretch = 0);

    bool setStretchFactor(QWidget *w, int stretch);
    bool setStretchFactor(QLayout *l, int stretch);

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    int minimumHeightForWidth(int) const;

    Qt::Orientations expandingDirections() const;
    void invalidate();
    QLayoutItem *itemAt(int) const;
    QLayoutItem *takeAt(int);
    int count() const;
    void setGeometry(const QRect&);



protected:
    void insertItem(int index, QLayoutItem *);

private:
    QBoxLayout(const QBoxLayout &); QBoxLayout &operator=(const QBoxLayout &);
};

class __declspec(dllimport) QHBoxLayout : public QBoxLayout
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QHBoxLayout();
    explicit QHBoxLayout(QWidget *parent);
    ~QHBoxLayout();









private:
    QHBoxLayout(const QHBoxLayout &); QHBoxLayout &operator=(const QHBoxLayout &);
};

class __declspec(dllimport) QVBoxLayout : public QBoxLayout
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QVBoxLayout();
    explicit QVBoxLayout(QWidget *parent);
    ~QVBoxLayout();









private:
    QVBoxLayout(const QVBoxLayout &); QVBoxLayout &operator=(const QVBoxLayout &);
};










































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QMimeSource;
class QMimeData;
class QImage;
class QPixmap;

class QClipboardPrivate;

class __declspec(dllimport) QClipboard : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QClipboardPrivate* d_func() { return reinterpret_cast<QClipboardPrivate *>(d_ptr); } inline const QClipboardPrivate* d_func() const { return reinterpret_cast<const QClipboardPrivate *>(d_ptr); } friend class QClipboardPrivate;
private:
    QClipboard(QObject *parent);
    ~QClipboard();

public:
    enum Mode { Clipboard, Selection };

    void clear(Mode mode = Clipboard);

    bool supportsSelection() const;
    bool ownsSelection() const;
    bool ownsClipboard() const;

    QString text(Mode mode = Clipboard) const;
    QString text(QString& subtype, Mode mode = Clipboard) const;
    void setText(const QString &, Mode mode = Clipboard);





    const QMimeData *mimeData(Mode mode = Clipboard ) const;
    void setMimeData(QMimeData *data, Mode mode = Clipboard);

    QImage image(Mode mode = Clipboard) const;
    QPixmap pixmap(Mode mode = Clipboard) const;
    void setImage(const QImage &, Mode mode  = Clipboard);
    void setPixmap(const QPixmap &, Mode mode  = Clipboard);

protected:
    void selectionChanged();
    void dataChanged();

private :
    void ownerDestroyed();

protected:
    void connectNotify(const char *);
    bool event(QEvent *);

    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QBaseApplication;
    friend class QDragManager;
    friend class QMimeSource;

private:
    QClipboard(const QClipboard &); QClipboard &operator=(const QClipboard &);





};


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QApplication;
class QDesktopWidgetPrivate;

class __declspec(dllimport) QDesktopWidget : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QDesktopWidget();
    ~QDesktopWidget();

    bool isVirtualDesktop() const;

    int numScreens() const;
    int primaryScreen() const;

    int screenNumber(const QWidget *widget = 0) const;
    int screenNumber(const QPoint &) const;

    QWidget *screen(int screen = -1);

    const QRect screenGeometry(int screen = -1) const;
    const QRect screenGeometry(const QWidget *widget) const
    { return screenGeometry(screenNumber(widget)); }
    const QRect screenGeometry(const QPoint &point) const
    { return screenGeometry(screenNumber(point)); }

    const QRect availableGeometry(int screen = -1) const;
    const QRect availableGeometry(const QWidget *widget) const
    { return availableGeometry(screenNumber(widget)); }
    const QRect availableGeometry(const QPoint &point) const
    { return availableGeometry(screenNumber(point)); }

protected:
    void resized(int);
    void workAreaResized(int);

protected:
    void resizeEvent(QResizeEvent *e);

private:
    QDesktopWidget(const QDesktopWidget &); QDesktopWidget &operator=(const QDesktopWidget &);
    inline QDesktopWidgetPrivate* d_func() { return reinterpret_cast<QDesktopWidgetPrivate *>(d_ptr); } inline const QDesktopWidgetPrivate* d_func() const { return reinterpret_cast<const QDesktopWidgetPrivate *>(d_ptr); } friend class QDesktopWidgetPrivate;

    friend class QApplication;



};

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QSessionManagerPrivate;

class __declspec(dllimport)  QSessionManager : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QSessionManagerPrivate* d_func() { return reinterpret_cast<QSessionManagerPrivate *>(d_ptr); } inline const QSessionManagerPrivate* d_func() const { return reinterpret_cast<const QSessionManagerPrivate *>(d_ptr); } friend class QSessionManagerPrivate;
    QSessionManager(QApplication *app, QString &id, QString &key);
    ~QSessionManager();
public:
    QString sessionId() const;
    QString sessionKey() const;




    bool allowsInteraction();
    bool allowsErrorInteraction();
    void release();

    void cancel();

    enum RestartHint {
        RestartIfRunning,
        RestartAnyway,
        RestartImmediately,
        RestartNever
    };
    void setRestartHint(RestartHint);
    RestartHint restartHint() const;

    void setRestartCommand(const QStringList&);
    QStringList restartCommand() const;
    void setDiscardCommand(const QStringList&);
    QStringList discardCommand() const;

    void setManagerProperty(const QString& name, const QString& value);
    void setManagerProperty(const QString& name, const QStringList& value);

    bool isPhase2() const;
    void requestPhase2();

private:
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QBaseApplication;
};

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QShortcutPrivate;
class __declspec(dllimport) QShortcut : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QShortcutPrivate* d_func() { return reinterpret_cast<QShortcutPrivate *>(d_ptr); } inline const QShortcutPrivate* d_func() const { return reinterpret_cast<const QShortcutPrivate *>(d_ptr); } friend class QShortcutPrivate;




public:
    explicit QShortcut(QWidget *parent);
    QShortcut(const QKeySequence& key, QWidget *parent,
              const char *member = 0, const char *ambiguousMember = 0,
              Qt::ShortcutContext context = Qt::WindowShortcut);
    ~QShortcut();

    void setKey(const QKeySequence& key);
    QKeySequence key() const;

    void setEnabled(bool enable);
    bool isEnabled() const;

    void setContext(Qt::ShortcutContext context);
    Qt::ShortcutContext context();

    void setWhatsThis(const QString &text);
    QString whatsThis() const;

    int id() const;

    inline QWidget *parentWidget() const
    { return static_cast<QWidget *>(QObject::parent()); }

protected:
    void activated();
    void activatedAmbiguously();

protected:
    bool event(QEvent *e);
};



































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QSoundPrivate;

class __declspec(dllimport) QSound : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    static bool isAvailable();
    static void play(const QString& filename);

    explicit QSound(const QString& filename, QObject* parent = 0);
    ~QSound();

    int loops() const;
    int loopsRemaining() const;
    void setLoops(int);
    QString fileName() const;

    bool isFinished() const;

public :
    void play();
    void stop();

public:




private:
    inline QSoundPrivate* d_func() { return reinterpret_cast<QSoundPrivate *>(d_ptr); } inline const QSoundPrivate* d_func() const { return reinterpret_cast<const QSoundPrivate *>(d_ptr); } friend class QSoundPrivate;
    friend class QAuServer;
};
















































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QStackedLayoutPrivate;

class __declspec(dllimport) QStackedLayout : public QLayout
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QStackedLayoutPrivate* d_func() { return reinterpret_cast<QStackedLayoutPrivate *>(d_ptr); } inline const QStackedLayoutPrivate* d_func() const { return reinterpret_cast<const QStackedLayoutPrivate *>(d_ptr); } friend class QStackedLayoutPrivate;



public:
    QStackedLayout();
    explicit QStackedLayout(QWidget *parent);
    explicit QStackedLayout(QLayout *parentLayout);
    ~QStackedLayout();

    int addWidget(QWidget *w);
    int insertWidget(int index, QWidget *w);

    QWidget *currentWidget() const;
    int currentIndex() const;



    using QLayout::widget;

    QWidget *widget(int) const;
    int count() const;


    void addItem(QLayoutItem *item);
    QSize sizeHint() const;
    QSize minimumSize() const;
    QLayoutItem *itemAt(int) const;
    QLayoutItem *takeAt(int);
    void setGeometry(const QRect &rect);

protected:
    void widgetRemoved(int index);
    void currentChanged(int index);

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *w);

private:
    QStackedLayout(const QStackedLayout &); QStackedLayout &operator=(const QStackedLayout &);
};




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QToolTip
{
    QToolTip();
public:
    static void showText(const QPoint &pos, const QString &text, QWidget *w = 0);

    static QPalette palette();






};






































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAction;




class __declspec(dllimport) QWhatsThis
{
    QWhatsThis();

public:
    static void enterWhatsThisMode();
    static bool inWhatsThisMode();
    static void leaveWhatsThisMode();

    static void showText(const QPoint &pos, const QString &text, QWidget *w = 0);
    static void hideText();

    static QAction *createAction(QObject *parent = 0);






};












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QColor;
class QColormapPrivate;

class __declspec(dllimport) QColormap
{
public:
    enum Mode { Direct, Indexed, Gray };

    static void initialize();
    static void cleanup();

    static QColormap instance(int screen = -1);

    QColormap(const QColormap &colormap);
    ~QColormap();

    QColormap &operator=(const QColormap &colormap);

    Mode mode() const;

    int depth() const;
    int size() const;

    uint pixel(const QColor &color) const;
    const QColor colorAt(uint pixel) const;

    const QVector<QColor> colormap() const;


    static HPALETTE hPal();


private:
    QColormap();
    QColormapPrivate *d;
};

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QPainter;

class QColorGroup;

class QPalette;
class QPoint;
class QColor;
class QBrush;
class QRect;
class QPixmap;





__declspec(dllimport) void qDrawShadeLine(QPainter *p, int x1, int y1, int x2, int y2,
                              const QPalette &pal, bool sunken = true,
                              int lineWidth = 1, int midLineWidth = 0);

__declspec(dllimport) void qDrawShadeLine(QPainter *p, const QPoint &p1, const QPoint &p2,
                              const QPalette &pal, bool sunken = true,
                              int lineWidth = 1, int midLineWidth = 0);

__declspec(dllimport) void qDrawShadeRect(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                              int lineWidth = 1, int midLineWidth = 0,
                              const QBrush *fill = 0);

__declspec(dllimport) void qDrawShadeRect(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                              int lineWidth = 1, int midLineWidth = 0,
                              const QBrush *fill = 0);

__declspec(dllimport) void qDrawShadePanel(QPainter *p, int x, int y, int w, int h,
                               const QPalette &pal, bool sunken = false,
                               int lineWidth = 1, const QBrush *fill = 0);

__declspec(dllimport) void qDrawShadePanel(QPainter *p, const QRect &r,
                               const QPalette &pal, bool sunken = false,
                               int lineWidth = 1, const QBrush *fill = 0);

__declspec(dllimport) void qDrawWinButton(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                              const QBrush *fill = 0);

__declspec(dllimport) void qDrawWinButton(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                              const QBrush *fill = 0);

__declspec(dllimport) void qDrawWinPanel(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                             const QBrush *fill = 0);

__declspec(dllimport) void qDrawWinPanel(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                             const QBrush *fill = 0);

__declspec(dllimport) void qDrawPlainRect(QPainter *p, int x, int y, int w, int h, const QColor &,
                              int lineWidth = 1, const QBrush *fill = 0);

__declspec(dllimport) void qDrawPlainRect(QPainter *p, const QRect &r, const QColor &,
                              int lineWidth = 1, const QBrush *fill = 0);






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QMatrix;
class QRect;
class QVariant;

class __declspec(dllimport) QPolygon : public QVector<QPoint>
{
public:
    inline QPolygon() {}
    inline ~QPolygon() {}
    inline QPolygon(int size);
    inline QPolygon(const QPolygon &a) : QVector<QPoint>(a) {}
    inline QPolygon(const QVector<QPoint> &v) : QVector<QPoint>(v) {}
    QPolygon(const QRect &r, bool closed=false);
    QPolygon(int nPoints, const int *points);
    operator QVariant() const;

    void translate(int dx, int dy);
    void translate(const QPoint &offset);
    QRect boundingRect() const;

    void point(int i, int *x, int *y) const;
    QPoint point(int i) const;
    void setPoint(int index, int x, int y);
    void setPoint(int index, const QPoint &p);
    void setPoints(int nPoints, const int *points);
    void setPoints(int nPoints, int firstx, int firsty, ...);
    void putPoints(int index, int nPoints, const int *points);
    void putPoints(int index, int nPoints, int firstx, int firsty, ...);
    void putPoints(int index, int nPoints, const QPolygon & from, int fromIndex=0);
};

inline QPolygon::QPolygon(int asize) : QVector<QPoint>(asize) {}


__declspec(dllimport) QDebug operator<<(QDebug, const QPolygon &);






inline void QPolygon::setPoint(int index, const QPoint &pt)
{ (*this)[index] = pt; }

inline void QPolygon::setPoint(int index, int x, int y)
{ (*this)[index] = QPoint(x, y); }

inline QPoint QPolygon::point(int index) const
{ return at(index); }

inline void QPolygon::translate(const QPoint &offset)
{ translate(offset.x(), offset.y()); }

class QRectF;

class __declspec(dllimport) QPolygonF : public QVector<QPointF>
{
public:
    inline QPolygonF() {}
    inline ~QPolygonF() {}
    inline QPolygonF(int size);
    inline QPolygonF(const QPolygonF &a) : QVector<QPointF>(a) {}
    inline QPolygonF(const QVector<QPointF> &v) : QVector<QPointF>(v) {}
    QPolygonF(const QRectF &r);
    QPolygonF(const QPolygon &a);

    inline void translate(qreal dx, qreal dy);
    void translate(const QPointF &offset);

    QPolygon toPolygon() const;

    bool isClosed() const { return !isEmpty() && first() == last(); }

    QRectF boundingRect() const;
};

inline QPolygonF::QPolygonF(int asize) : QVector<QPointF>(asize) {}


__declspec(dllimport) QDebug operator<<(QDebug, const QPolygonF &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &stream, const QPolygonF &array);
__declspec(dllimport) QDataStream &operator>>(QDataStream &stream, QPolygonF &array);


inline void QPolygonF::translate(qreal dx, qreal dy)
{ translate(QPointF(dx, dy)); }































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QPainterPath;

class __declspec(dllimport) QMatrix
{
public:
    QMatrix();
    QMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
            qreal dx, qreal dy);
    QMatrix(const QMatrix &matrix);

    void setMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
                   qreal dx, qreal dy);

    qreal m11() const { return _m11; }
    qreal m12() const { return _m12; }
    qreal m21() const { return _m21; }
    qreal m22() const { return _m22; }
    qreal dx() const { return _dx; }
    qreal dy() const { return _dy; }

    void map(int x, int y, int *tx, int *ty) const;
    void map(qreal x, qreal y, qreal *tx, qreal *ty) const;
    QRect mapRect(const QRect &) const;
    QRectF mapRect(const QRectF &) const;

    QPoint map(const QPoint &p) const;
    QPointF map(const QPointF&p) const;
    QLine map(const QLine &l) const;
    QLineF map(const QLineF &l) const;
    QPolygonF map(const QPolygonF &a) const;
    QPolygon map(const QPolygon &a) const;
    QRegion map(const QRegion &r) const;
    QPainterPath map(const QPainterPath &p) const;
    QPolygon mapToPolygon(const QRect &r) const;

    void reset();
    inline bool isIdentity() const;

    QMatrix &translate(qreal dx, qreal dy);
    QMatrix &scale(qreal sx, qreal sy);
    QMatrix &shear(qreal sh, qreal sv);
    QMatrix &rotate(qreal a);

    bool isInvertible() const { return !qFuzzyCompare(_m11*_m22 - _m12*_m21, 0); }
    qreal det() const { return _m11*_m22 - _m12*_m21; }

    QMatrix inverted(bool *invertible = 0) const;

    bool operator==(const QMatrix &) const;
    bool operator!=(const QMatrix &) const;

    QMatrix &operator*=(const QMatrix &);
    QMatrix operator*(const QMatrix &o) const;

    QMatrix &operator=(const QMatrix &);







private:
    qreal _m11, _m12;
    qreal _m21, _m22;
    qreal _dx, _dy;
};
template <> class QTypeInfo<QMatrix> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMatrix)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMatrix"; } };


inline __declspec(dllimport) QPoint operator*(const QPoint &p, const QMatrix &m)
{ return m.map(p); }
inline __declspec(dllimport) QPointF operator*(const QPointF &p, const QMatrix &m)
{ return m.map(p); }
inline __declspec(dllimport) QLineF operator*(const QLineF &l, const QMatrix &m)
{ return m.map(l); }
inline __declspec(dllimport) QLine operator*(const QLine &l, const QMatrix &m)
{ return m.map(l); }
inline __declspec(dllimport) QPolygon operator *(const QPolygon &a, const QMatrix &m)
{ return m.map(a); }
inline __declspec(dllimport) QPolygonF operator *(const QPolygonF &a, const QMatrix &m)
{ return m.map(a); }
inline __declspec(dllimport) QRegion operator *(const QRegion &r, const QMatrix &m)
{ return m.map(r); }
__declspec(dllimport) QPainterPath operator *(const QPainterPath &p, const QMatrix &m);

inline bool QMatrix::isIdentity() const
{
    return qFuzzyCompare(_m11, 1) && qFuzzyCompare(_m22, 1) && qFuzzyCompare(_m12, 0)
           && qFuzzyCompare(_m21, 0) && qFuzzyCompare(_dx, 0) && qFuzzyCompare(_dy, 0);
}





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QMatrix &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QMatrix &);


__declspec(dllimport) QDebug operator<<(QDebug, const QMatrix &);











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

template <typename T> class QList;
struct QTextOptionPrivate;

class __declspec(dllimport) QTextOption
{
public:
    QTextOption();
    QTextOption(Qt::Alignment alignment);
    ~QTextOption();

    QTextOption(const QTextOption &o);
    QTextOption &operator=(const QTextOption &o);

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const { return Qt::Alignment(align); }

    inline void setTextDirection(Qt::LayoutDirection aDirection) { this->direction = aDirection; }
    inline Qt::LayoutDirection textDirection() const { return Qt::LayoutDirection(direction); }

    enum WrapMode {
        NoWrap,
        WordWrap,
        ManualWrap,
        WrapAnywhere,
        WrapAtWordBoundaryOrAnywhere
    };
    inline void setWrapMode(WrapMode wrap) { wordWrap = wrap; }
    inline WrapMode wrapMode() const { return static_cast<WrapMode>(wordWrap); }

    enum Flag {
        IncludeTrailingSpaces = 0x80000000
    };
    typedef QFlags<Flag> Flags;
    inline void setFlags(Flags flags);
    inline Flags flags() const { return Flags(f); }

    inline void setTabStop(qreal tabStop);
    inline qreal tabStop() const { return tab; }

    void setTabArray(QList<qreal> tabStops);
    QList<qreal> tabArray() const;

    void setUseDesignMetrics(bool b) { design = b; }
    bool useDesignMetrics() const { return design; }

private:
    uint align : 8;
    uint wordWrap : 4;
    uint design : 1;
    uint direction : 1;
    uint unused : 19;
    uint f;
    qreal tab;
    QTextOptionPrivate *d;
};

inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QTextOption::Flags::enum_type f2) { return QFlags<QTextOption::Flags::enum_type>(f1) | f2; } inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QFlags<QTextOption::Flags::enum_type> f2) { return f2 | f1; }

inline void QTextOption::setAlignment(Qt::Alignment aalignment)
{ align = aalignment; }

inline void QTextOption::setFlags(Flags aflags)
{ f = aflags; }

inline void QTextOption::setTabStop(qreal atabStop)
{ tab = atabStop; }




































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;
class QPenPrivate;
class QBrush;

class __declspec(dllimport) QPen
{
public:
    QPen();
    QPen(Qt::PenStyle);
    QPen(const QColor &color);
    QPen(const QBrush &brush, qreal width, Qt::PenStyle s = Qt::SolidLine,
         Qt::PenCapStyle c = Qt::SquareCap, Qt::PenJoinStyle j = Qt::BevelJoin);
    QPen(const QPen &pen);

    ~QPen();

    QPen &operator=(const QPen &pen);

    Qt::PenStyle style() const;
    void setStyle(Qt::PenStyle);

    qreal widthF() const;
    void setWidthF(qreal width);

    int width() const;
    void setWidth(int width);

    QColor color() const;
    void setColor(const QColor &color);

    QBrush brush() const;
    void setBrush(const QBrush &brush);

    bool isSolid() const;

    Qt::PenCapStyle capStyle() const;
    void setCapStyle(Qt::PenCapStyle pcs);

    Qt::PenJoinStyle joinStyle() const;
    void setJoinStyle(Qt::PenJoinStyle pcs);

    bool operator==(const QPen &p) const;
    inline bool operator!=(const QPen &p) const { return !(operator==(p)); }
    operator QVariant() const;

    bool isDetached();
private:
    friend class QPainter;
    void detach();
    class QPenPrivate *d;
};
template <> class QTypeInfo<QPen> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPen)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPen"; } };
template <> inline bool qIsDetached<QPen>(QPen &t) { return t.isDetached(); }





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPen &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPen &);

















































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QBrush;
class QFontInfo;
class QFontMetrics;
class QPaintDevice;
class QPainterPath;
class QPainterPrivate;
class QPen;
class QPolygon;
class QTextItem;
class QMatrix;

class __declspec(dllimport) QPainter
{
    inline QPainterPrivate* d_func() { return reinterpret_cast<QPainterPrivate *>(d_ptr); } inline const QPainterPrivate* d_func() const { return reinterpret_cast<const QPainterPrivate *>(d_ptr); } friend class QPainterPrivate;

public:
    enum RenderHint {
        Antialiasing = 0x01,
        TextAntialiasing = 0x02,
        SmoothPixmapTransform = 0x04
    };

    typedef QFlags<RenderHint> RenderHints;

    QPainter();
    explicit QPainter(QPaintDevice *);
    ~QPainter();

    QPaintDevice *device() const;

    bool begin(QPaintDevice *);
    bool end();
    bool isActive() const;

    void initFrom(const QWidget *widget);

    enum CompositionMode {
        CompositionMode_SourceOver,
        CompositionMode_DestinationOver,
        CompositionMode_Clear,
        CompositionMode_Source,
        CompositionMode_Destination,
        CompositionMode_SourceIn,
        CompositionMode_DestinationIn,
        CompositionMode_SourceOut,
        CompositionMode_DestinationOut,
        CompositionMode_SourceAtop,
        CompositionMode_DestinationAtop,
        CompositionMode_Xor
    };
    void setCompositionMode(CompositionMode mode);
    CompositionMode compositionMode() const;

    const QFont &font() const;
    void setFont(const QFont &f);

    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;

    void setPen(const QColor &color);
    void setPen(const QPen &pen);
    void setPen(Qt::PenStyle style);
    const QPen &pen() const;

    void setBrush(const QBrush &brush);
    void setBrush(Qt::BrushStyle style);
    const QBrush &brush() const;


    void setBackgroundMode(Qt::BGMode mode);
    Qt::BGMode backgroundMode() const;

    QPoint brushOrigin() const;
    inline void setBrushOrigin(int x, int y);
    inline void setBrushOrigin(const QPoint &);
    void setBrushOrigin(const QPointF &);

    void setBackground(const QBrush &bg);
    const QBrush &background() const;


    QRegion clipRegion() const;
    QPainterPath clipPath() const;

    void setClipRect(const QRectF &, Qt::ClipOperation op = Qt::ReplaceClip);
    inline void setClipRect(const QRect &, Qt::ClipOperation op = Qt::ReplaceClip);
    inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipRegion(const QRegion &, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipPath(const QPainterPath &path, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipping(bool enable);
    bool hasClipping() const;

    void save();
    void restore();


    void setMatrix(const QMatrix &matrix, bool combine = false);
    const QMatrix &matrix() const;
    const QMatrix &deviceMatrix() const;
    void resetMatrix();

    void setMatrixEnabled(bool enabled);
    bool matrixEnabled() const;

    void scale(qreal sx, qreal sy);
    void shear(qreal sh, qreal sv);
    void rotate(qreal a);

    void translate(const QPointF &offset);
    inline void translate(const QPoint &offset);
    inline void translate(qreal dx, qreal dy);

    QRect window() const;
    void setWindow(const QRect &window);
    inline void setWindow(int x, int y, int w, int h);

    QRect viewport() const;
    void setViewport(const QRect &viewport);
    inline void setViewport(int x, int y, int w, int h);

    void setViewTransformEnabled(bool enable);
    bool viewTransformEnabled() const;


    void strokePath(const QPainterPath &path, const QPen &pen);
    void fillPath(const QPainterPath &path, const QBrush &brush);
    void drawPath(const QPainterPath &path);

    inline void drawPoint(const QPointF &pt);
    inline void drawPoint(const QPoint &p);
    inline void drawPoint(int x, int y);

    void drawPoints(const QPointF *points, int pointCount);
    inline void drawPoints(const QPolygonF &points);
    void drawPoints(const QPoint *points, int pointCount);
    inline void drawPoints(const QPolygon &points);

    inline void drawLine(const QLineF &line);
    inline void drawLine(const QLine &line);
    inline void drawLine(int x1, int y1, int x2, int y2);
    inline void drawLine(const QPoint &p1, const QPoint &p2);
    inline void drawLine(const QPointF &p1, const QPointF &p2);

    void drawLines(const QLineF *lines, int lineCount);
    inline void drawLines(const QVector<QLineF> &lines);
    void drawLines(const QPointF *pointPairs, int lineCount);
    inline void drawLines(const QVector<QPointF> &pointPairs);
    void drawLines(const QLine *lines, int lineCount);
    inline void drawLines(const QVector<QLine> &lines);
    void drawLines(const QPoint *pointPairs, int lineCount);
    inline void drawLines(const QVector<QPoint> &pointPairs);

    inline void drawRect(const QRectF &rect);
    inline void drawRect(int x1, int y1, int w, int h);
    inline void drawRect(const QRect &rect);

    void drawRects(const QRectF *rects, int rectCount);
    inline void drawRects(const QVector<QRectF> &rectangles);
    void drawRects(const QRect *rects, int rectCount);
    inline void drawRects(const QVector<QRect> &rectangles);

    void drawEllipse(const QRectF &r);
    void drawEllipse(const QRect &r);
    inline void drawEllipse(int x, int y, int w, int h);

    void drawPolyline(const QPointF *points, int pointCount);
    inline void drawPolyline(const QPolygonF &polyline);
    void drawPolyline(const QPoint *points, int pointCount);
    inline void drawPolyline(const QPolygon &polygon);

    void drawPolygon(const QPointF *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
    inline void drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawPolygon(const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
    inline void drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);

    void drawConvexPolygon(const QPointF *points, int pointCount);
    inline void drawConvexPolygon(const QPolygonF &polygon);
    void drawConvexPolygon(const QPoint *points, int pointCount);
    inline void drawConvexPolygon(const QPolygon &polygon);

    void drawArc(const QRectF &rect, int a, int alen);
    inline void drawArc(const QRect &, int a, int alen);
    inline void drawArc(int x, int y, int w, int h, int a, int alen);

    void drawPie(const QRectF &rect, int a, int alen);
    inline void drawPie(int x, int y, int w, int h, int a, int alen);
    inline void drawPie(const QRect &, int a, int alen);

    void drawChord(const QRectF &rect, int a, int alen);
    inline void drawChord(int x, int y, int w, int h, int a, int alen);
    inline void drawChord(const QRect &, int a, int alen);

    void drawRoundRect(const QRectF &r, int xround = 25, int yround = 25);
    inline void drawRoundRect(int x, int y, int w, int h, int = 25, int = 25);
    inline void drawRoundRect(const QRect &r, int xround = 25, int yround = 25);

    void drawTiledPixmap(const QRectF &rect, const QPixmap &pm, const QPointF &offset = QPointF());
    inline void drawTiledPixmap(int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0);
    inline void drawTiledPixmap(const QRect &, const QPixmap &, const QPoint & = QPoint());

    void drawPicture(const QPointF &p, const QPicture &picture);
    inline void drawPicture(int x, int y, const QPicture &picture);
    inline void drawPicture(const QPoint &p, const QPicture &picture);


    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
    inline void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
    inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                           int sx, int sy, int sw, int sh);
    inline void drawPixmap(int x, int y, const QPixmap &pm,
                           int sx, int sy, int sw, int sh);
    inline void drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr);
    inline void drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr);
    inline void drawPixmap(const QPointF &p, const QPixmap &pm);
    inline void drawPixmap(const QPoint &p, const QPixmap &pm);
    inline void drawPixmap(int x, int y, const QPixmap &pm);
    inline void drawPixmap(const QRect &r, const QPixmap &pm);
    inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm);

    void drawImage(const QRectF &targetRect, const QImage &image, const QRectF &sourceRect,
                   Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QPoint &p, const QImage &image, const QRect &sr,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QRectF &r, const QImage &image);
    inline void drawImage(const QRect &r, const QImage &image);
    inline void drawImage(const QPointF &p, const QImage &image);
    inline void drawImage(const QPoint &p, const QImage &image);
    inline void drawImage(int x, int y, const QImage &image, int sx = 0, int sy = 0,
                          int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor);

    void setLayoutDirection(Qt::LayoutDirection direction);
    Qt::LayoutDirection layoutDirection() const;

    void drawText(const QPointF &p, const QString &s);
    inline void drawText(const QPoint &p, const QString &s);
    inline void drawText(int x, int y, const QString &s);

    void drawText(const QRectF &r, int flags, const QString &text, QRectF *br=0);
    void drawText(const QRect &r, int flags, const QString &text, QRect *br=0);
    inline void drawText(int x, int y, int w, int h, int flags, const QString &text, QRect *br=0);

    void drawText(const QRectF &r, const QString &text, const QTextOption &o = QTextOption());

    QRectF boundingRect(const QRectF &rect, int flags, const QString &text);
    QRect boundingRect(const QRect &rect, int flags, const QString &text);
    inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text);

    QRectF boundingRect(const QRectF &rect, const QString &text, const QTextOption &o = QTextOption());

    void drawTextItem(const QPointF &p, const QTextItem &ti);
    inline void drawTextItem(int x, int y, const QTextItem &ti);
    inline void drawTextItem(const QPoint &p, const QTextItem &ti);

    void fillRect(const QRectF &, const QBrush &);
    inline void fillRect(int x, int y, int w, int h, const QBrush &);
    void fillRect(const QRect &, const QBrush &);

    void eraseRect(const QRectF &);
    inline void eraseRect(int x, int y, int w, int h);
    inline void eraseRect(const QRect &);

    void setRenderHint(RenderHint hint, bool on = true);
    RenderHints renderHints() const;

    QPaintEngine *paintEngine() const;

    static void setRedirected(const QPaintDevice *device, QPaintDevice *replacement,
                              const QPoint& offset = QPoint());
    static QPaintDevice *redirected(const QPaintDevice *device, QPoint *offset = 0);
    static void restoreRedirected(const QPaintDevice *device);












































































private:
    friend class Q3Painter;
    friend void qt_format_text(const QFont &font, const QRectF &_r, int tf, const QString& str,
                               QRectF *brect, int tabstops, int* tabarray, int tabarraylen,
                               QPainter *painter);

    QPainterPrivate *d_ptr;

    friend class QFontEngine;
    friend class QFontEngineBox;
    friend class QFontEngineFT;
    friend class QFontEngineMac;
    friend class QFontEngineWin;
    friend class QFontEngineXLFD;
    friend class QWSManager;
    friend class QPaintEngine;
    friend class QX11PaintEngine;
    friend class QX11PaintEnginePrivate;
    friend class QWin32PaintEngine;
    friend class QWin32PaintEnginePrivate;
};

inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QPainter::RenderHints::enum_type f2) { return QFlags<QPainter::RenderHints::enum_type>(f1) | f2; } inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QFlags<QPainter::RenderHints::enum_type> f2) { return f2 | f1; }




inline void QPainter::drawLine(const QLineF &l)
{
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QLine &line)
{
    drawLines(&line, 1);
}

inline void QPainter::drawLine(int x1, int y1, int x2, int y2)
{
    QLine l(x1, y1, x2, y2);
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPoint &p1, const QPoint &p2)
{
    QLine l(p1, p2);
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPointF &p1, const QPointF &p2)
{
    drawLine(QLineF(p1, p2));
}

inline void QPainter::drawLines(const QVector<QLineF> &lines)
{
    drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QLine> &lines)
{
    drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QPointF> &pointPairs)
{
    drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawLines(const QVector<QPoint> &pointPairs)
{
    drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawPolyline(const QPolygonF &polyline)
{
    drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolyline(const QPolygon &polyline)
{
    drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule)
{
    drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule)
{
    drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawConvexPolygon(const QPolygonF &poly)
{
    drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawConvexPolygon(const QPolygon &poly)
{
    drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawRect(const QRectF &rect)
{
    drawRects(&rect, 1);
}

inline void QPainter::drawRect(int x, int y, int w, int h)
{
    QRect r(x, y, w, h);
    drawRects(&r, 1);
}

inline void QPainter::drawRect(const QRect &r)
{
    drawRects(&r, 1);
}

inline void QPainter::drawRects(const QVector<QRectF> &rects)
{
    drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawRects(const QVector<QRect> &rects)
{
    drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawPoint(const QPointF &p)
{
    drawPoints(&p, 1);
}

inline void QPainter::drawPoint(int x, int y)
{
    QPoint p(x, y);
    drawPoints(&p, 1);
}

inline void QPainter::drawPoint(const QPoint &p)
{
    drawPoints(&p, 1);
}

inline void QPainter::drawPoints(const QPolygonF &points)
{
    drawPoints(points.constData(), points.size());
}

inline void QPainter::drawPoints(const QPolygon &points)
{
    drawPoints(points.constData(), points.size());
}

inline void QPainter::drawRoundRect(int x, int y, int w, int h, int xRnd, int yRnd)
{
    drawRoundRect(QRectF(x, y, w, h), xRnd, yRnd);
}

inline void QPainter::drawRoundRect(const QRect &rect, int xRnd, int yRnd)
{
    drawRoundRect(QRectF(rect), xRnd, yRnd);
}

inline void QPainter::drawEllipse(int x, int y, int w, int h)
{
    drawEllipse(QRect(x, y, w, h));
}

inline void QPainter::drawArc(const QRect &r, int a, int alen)
{
    drawArc(QRectF(r), a, alen);
}

inline void QPainter::drawArc(int x, int y, int w, int h, int a, int alen)
{
    drawArc(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawPie(const QRect &rect, int a, int alen)
{
    drawPie(QRectF(rect), a, alen);
}

inline void QPainter::drawPie(int x, int y, int w, int h, int a, int alen)
{
    drawPie(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawChord(const QRect &rect, int a, int alen)
{
    drawChord(QRectF(rect), a, alen);
}

inline void QPainter::drawChord(int x, int y, int w, int h, int a, int alen)
{
    drawChord(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::setClipRect(int x, int y, int w, int h, Qt::ClipOperation op)
{
    setClipRect(QRectF(x, y, w, h), op);
}

inline void QPainter::setClipRect(const QRect &rect, Qt::ClipOperation op)
{
    setClipRect(QRectF(rect), op);
}

inline void QPainter::eraseRect(const QRect &rect)
{
    eraseRect(QRectF(rect));
}

inline void QPainter::eraseRect(int x, int y, int w, int h)
{
    eraseRect(QRectF(x, y, w, h));
}

inline void QPainter::fillRect(int x, int y, int w, int h, const QBrush &b)
{
    fillRect(QRect(x, y, w, h), b);
}

inline void QPainter::setBrushOrigin(int x, int y)
{
    setBrushOrigin(QPoint(x, y));
}

inline void QPainter::setBrushOrigin(const QPoint &p)
{
    setBrushOrigin(QPointF(p));
}

inline void QPainter::drawTiledPixmap(const QRect &rect, const QPixmap &pm, const QPoint &offset)
{
    drawTiledPixmap(QRectF(rect), pm, QPointF(offset));
}

inline void QPainter::drawTiledPixmap(int x, int y, int w, int h, const QPixmap &pm, int sx, int sy)
{
    drawTiledPixmap(QRectF(x, y, w, h), pm, QPointF(sx, sy));
}

inline void QPainter::drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect)
{
    drawPixmap(QRectF(targetRect), pixmap, QRectF(sourceRect));
}

inline void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, QRectF());
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, QRectF());
}

inline void QPainter::drawPixmap(const QRect &r, const QPixmap &pm)
{
    drawPixmap(QRectF(r), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm)
{
    drawPixmap(QRectF(x, y, -1, -1), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm)
{
    drawPixmap(QRectF(x, y, w, h), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                                 int sx, int sy, int sw, int sh)
{
    drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm,
                                 int sx, int sy, int sw, int sh)
{
    drawPixmap(QRectF(x, y, -1, -1), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawTextItem(int x, int y, const QTextItem &ti)
{
    drawTextItem(QPointF(x, y), ti);
}

inline void QPainter::drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRectF(targetRect), image, QRectF(sourceRect), flags);
}

inline void QPainter::drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRectF(p.x(), p.y(), -1, -1), image, sr, flags);
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image, const QRect &sr,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRect(p.x(), p.y(), -1, -1), image, sr, flags);
}


inline void QPainter::drawImage(const QRectF &r, const QImage &image)
{
    drawImage(r, image, QRect(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QRect &r, const QImage &image)
{
    drawImage(r, image, QRectF(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QPointF &p, const QImage &image)
{
    drawImage(QRectF(p.x(), p.y(), -1, -1), image, QRectF(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image)
{
    drawImage(QRectF(p.x(), p.y(), -1, -1), image, QRectF(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(int x, int y, const QImage &image, int sx, int sy, int sw, int sh,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRectF(x, y, -1, -1), image, QRectF(sx, sy, sw, sh), flags);
}

inline void QPainter::drawTextItem(const QPoint &p, const QTextItem &ti)
{
    drawTextItem(QPointF(p), ti);
}

inline void QPainter::drawText(const QPoint &p, const QString &s)
{
    drawText(QPointF(p), s);
}

inline void QPainter::drawText(int x, int y, int w, int h, int flags, const QString &str, QRect *br)
{
    drawText(QRect(x, y, w, h), flags, str, br);
}

inline void QPainter::drawText(int x, int y, const QString &s)
{
    drawText(QPointF(x, y), s);
}

inline QRect QPainter::boundingRect(int x, int y, int w, int h, int flags, const QString &text)
{
    return boundingRect(QRect(x, y, w, h), flags, text);
}

inline void QPainter::translate(qreal dx, qreal dy)
{
    translate(QPointF(dx, dy));
}

inline void QPainter::translate(const QPoint &offset)
{
    translate(offset.x(), offset.y());
}

inline void QPainter::setViewport(int x, int y, int w, int h)
{
    setViewport(QRect(x, y, w, h));
}

inline void QPainter::setWindow(int x, int y, int w, int h)
{
    setWindow(QRect(x, y, w, h));
}


inline void QPainter::drawPicture(int x, int y, const QPicture &p)
{
    drawPicture(QPoint(x, y), p);
}

inline void QPainter::drawPicture(const QPoint &pt, const QPicture &p)
{
    drawPicture(QPointF(pt), p);
}






typedef QtValidLicenseForGuiModule QtGuiModule;

class QFontEngine;
class QLineF;
class QPaintDevice;
class QPaintEnginePrivate;
class QPainterPath;
class QPointF;
class QPolygonF;
class QRectF;
struct QGlyphLayout;
class QTextItemInt;
class QPaintEngineState;

class __declspec(dllimport) QTextItem {
public:
    enum RenderFlag {
        RightToLeft = 0x1,
        Overline = 0x10,
        Underline = 0x20,
        StrikeOut = 0x40,

        Dummy = 0xffffffff
    };
    typedef QFlags<RenderFlag> RenderFlags;
    qreal descent() const;
    qreal ascent() const;
    qreal width() const;

    RenderFlags renderFlags() const;
    QString text() const;
    QFont font() const;
};
template <> class QTypeInfo<QTextItem> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextItem)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextItem"; } };


class __declspec(dllimport) QPaintEngine
{
    inline QPaintEnginePrivate* d_func() { return reinterpret_cast<QPaintEnginePrivate *>(d_ptr); } inline const QPaintEnginePrivate* d_func() const { return reinterpret_cast<const QPaintEnginePrivate *>(d_ptr); } friend class QPaintEnginePrivate;
public:
    enum PaintEngineFeature {
        PrimitiveTransform        = 0x00000001,
        PatternTransform          = 0x00000002,
        PixmapTransform           = 0x00000004,
        PatternBrush              = 0x00000008,
        LinearGradientFill   	  = 0x00000010,
        RadialGradientFill        = 0x00000020,
        ConicalGradientFill       = 0x00000040,
	AlphaBlend                = 0x00000080,
	PorterDuff                = 0x00000100,
        PainterPaths              = 0x00000200,
        Antialiasing              = 0x00000400,
        BrushStroke               = 0x00000800,
        PaintOutsidePaintEvent    = 0x20000000,
        AllFeatures               = 0xffffffff
    };
    typedef QFlags<PaintEngineFeature> PaintEngineFeatures;

    enum DirtyFlag {
        DirtyPen                = 0x0001,
        DirtyBrush              = 0x0002,
        DirtyBrushOrigin        = 0x0004,
        DirtyFont               = 0x0008,
        DirtyBackground         = 0x0010,
        DirtyBackgroundMode     = 0x0020,
        DirtyTransform          = 0x0040,
        DirtyClipRegion         = 0x0080,
        DirtyClipPath           = 0x0100,
        DirtyHints              = 0x0200,
        DirtyCompositionMode    = 0x0400,

        AllDirty                = 0xffff
    };
    typedef QFlags<DirtyFlag> DirtyFlags;

    enum PolygonDrawMode {
        OddEvenMode,
        WindingMode,
        ConvexMode,
        PolylineMode
    };

    explicit QPaintEngine(PaintEngineFeatures features=0);
    virtual ~QPaintEngine();

    bool isActive() const { return active; }
    void setActive(bool newState) { active = newState; }

    virtual bool begin(QPaintDevice *pdev) = 0;
    virtual bool end() = 0;

    virtual void updateState(const QPaintEngineState &state) = 0;

    virtual void drawRects(const QRect *rects, int rectCount);
    virtual void drawRects(const QRectF *rects, int rectCount);

    virtual void drawLines(const QLine *lines, int lineCount);
    virtual void drawLines(const QLineF *lines, int lineCount);

    virtual void drawEllipse(const QRectF &r);
    virtual void drawEllipse(const QRect &r);

    virtual void drawPath(const QPainterPath &path);

    virtual void drawPoints(const QPointF *points, int pointCount);
    virtual void drawPoints(const QPoint *points, int pointCount);

    virtual void drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode);
    virtual void drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode);

    virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr) = 0;
    virtual void drawTextItem(const QPointF &p, const QTextItem &textItem);
    virtual void drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s);
    virtual void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
                           Qt::ImageConversionFlags flags = Qt::AutoColor);

    void setPaintDevice(QPaintDevice *device);
    QPaintDevice *paintDevice() const;

    void setSystemClip(const QRegion &baseClip);
    QRegion systemClip() const;


    virtual HDC getDC() const;
    virtual void releaseDC(HDC hdc) const;


    virtual QPoint coordinateOffset() const;

    enum Type {
        X11,
        Windows,
        QuickDraw, CoreGraphics, MacPrinter,
        QWindowSystem,
        PostScript,
        OpenGL,
        Picture,
        SVG,
        Raster,

        User = 50,
        MaxUser = 100
    };
    virtual Type type() const = 0;

    inline void fix_neg_rect(int *x, int *y, int *w, int *h);

    inline bool testDirty(DirtyFlags df);
    inline void setDirty(DirtyFlags df);
    inline void clearDirty(DirtyFlags df);

    bool hasFeature(PaintEngineFeatures feature) const { return (gccaps & feature) != 0; }

    QPainter *painter() const;

    inline void syncState() { do {if(!(state))qt_assert("state","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpaintengine.h",176);} while (0); updateState(*state); }

protected:
    QPaintEngine(QPaintEnginePrivate &data, PaintEngineFeatures devcaps=0);

    QPaintEngineState *state;
    PaintEngineFeatures gccaps;

    uint active : 1;
    uint selfDestruct : 1;

    QPaintEnginePrivate *d_ptr;

private:
    void setAutoDestruct(bool autoDestr) { selfDestruct = autoDestr; }
    bool autoDestruct() const { return selfDestruct; }

    friend class QFontEngineBox;
    friend class QFontEngineMac;
    friend class QFontEngineWin;

    friend class QFontEngineFT;


    friend class QFontEngineQPF;

    friend class QPSPrintEngine;
    friend class QMacPrintEngine;
    friend class QMacPrintEnginePrivate;
    friend class QPainter;
    friend class QPainterPrivate;
    friend class QWidget;
    friend class QWin32PaintEngine;
    friend class QWin32PaintEnginePrivate;
    friend class QMacCGContext;
};


class __declspec(dllimport) QPaintEngineState
{
public:
    QPaintEngine::DirtyFlags state() const { return dirtyFlags; }

    QPen pen() const;

    QBrush brush() const;
    QPointF brushOrigin() const;

    QBrush backgroundBrush() const;
    Qt::BGMode backgroundMode() const;

    QFont font() const;

    QMatrix matrix() const;

    Qt::ClipOperation clipOperation() const;
    QRegion clipRegion() const;
    QPainterPath clipPath() const;

    QPainter::RenderHints renderHints() const;

    QPainter::CompositionMode compositionMode() const;

    QPainter *painter() const;

protected:
    friend class QPaintEngine;
    friend class QPainter;
    friend class QPainterPrivate;

    QPaintEngine::DirtyFlags dirtyFlags;
};





inline void QPaintEngine::fix_neg_rect(int *x, int *y, int *w, int *h)
{
    if (*w < 0) {
        *w = -*w;
        *x -= *w - 1;
    }
    if (*h < 0) {
        *h = -*h;
        *y -= *h - 1;
    }
}

inline bool QPaintEngine::testDirty(DirtyFlags df) {
    do {if(!(state))qt_assert("state","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpaintengine.h",266);} while (0);
    return ((state->dirtyFlags & df) != 0);
}

inline void QPaintEngine::setDirty(DirtyFlags df) {
    do {if(!(state))qt_assert("state","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpaintengine.h",271);} while (0);
    state->dirtyFlags |= df;
}

inline void QPaintEngine::clearDirty(DirtyFlags df)
{
    do {if(!(state))qt_assert("state","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpaintengine.h",277);} while (0);
    state->dirtyFlags &= ~static_cast<uint>(df);
}

inline QFlags<QTextItem::RenderFlags::enum_type> operator|(QTextItem::RenderFlags::enum_type f1, QTextItem::RenderFlags::enum_type f2) { return QFlags<QTextItem::RenderFlags::enum_type>(f1) | f2; } inline QFlags<QTextItem::RenderFlags::enum_type> operator|(QTextItem::RenderFlags::enum_type f1, QFlags<QTextItem::RenderFlags::enum_type> f2) { return f2 | f1; }
inline QFlags<QPaintEngine::PaintEngineFeatures::enum_type> operator|(QPaintEngine::PaintEngineFeatures::enum_type f1, QPaintEngine::PaintEngineFeatures::enum_type f2) { return QFlags<QPaintEngine::PaintEngineFeatures::enum_type>(f1) | f2; } inline QFlags<QPaintEngine::PaintEngineFeatures::enum_type> operator|(QPaintEngine::PaintEngineFeatures::enum_type f1, QFlags<QPaintEngine::PaintEngineFeatures::enum_type> f2) { return f2 | f1; }
inline QFlags<QPaintEngine::DirtyFlags::enum_type> operator|(QPaintEngine::DirtyFlags::enum_type f1, QPaintEngine::DirtyFlags::enum_type f2) { return QFlags<QPaintEngine::DirtyFlags::enum_type>(f1) | f2; } inline QFlags<QPaintEngine::DirtyFlags::enum_type> operator|(QPaintEngine::DirtyFlags::enum_type f1, QFlags<QPaintEngine::DirtyFlags::enum_type> f2) { return f2 | f1; }

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QFont;
class QPainterPathPrivate;
class QPainterPathData;
class QPainterPathStrokerPrivate;
class QPolygonF;
class QRegion;

class __declspec(dllimport) QPainterPath
{
public:
    enum ElementType {
        MoveToElement,
        LineToElement,
        CurveToElement,
        CurveToDataElement
    };

    class Element {
    public:
        qreal x;
        qreal y;
        ElementType type;

        bool isMoveTo() const { return type == MoveToElement; }
        bool isLineTo() const { return type == LineToElement; }
        bool isCurveTo() const { return type == CurveToElement; }

        operator QPointF () const { return QPointF(x, y); }

        bool operator==(const Element &e) const { return qFuzzyCompare(x, e.x)
            && qFuzzyCompare(y, e.y) && type == e.type; }
    };

    QPainterPath();
    explicit QPainterPath(const QPointF &startPoint);
    QPainterPath(const QPainterPath &other);
    QPainterPath &operator=(const QPainterPath &other);
    ~QPainterPath();

    void closeSubpath();

    void moveTo(const QPointF &p);
    inline void moveTo(qreal x, qreal y);

    void lineTo(const QPointF &p);
    inline void lineTo(qreal x, qreal y);

    void arcTo(const QRectF &rect, qreal startAngle, qreal arcLength);
    inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength);

    void cubicTo(const QPointF &ctrlPt1, const QPointF &ctrlPt2, const QPointF &endPt);
    inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
                        qreal endPtx, qreal endPty);
    void quadTo(const QPointF &ctrlPt, const QPointF &endPt);
    inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty);

    QPointF currentPosition() const;

    void addRect(const QRectF &rect);
    inline void addRect(qreal x, qreal y, qreal w, qreal h);
    void addEllipse(const QRectF &rect);
    inline void addEllipse(qreal x, qreal y, qreal w, qreal h);
    void addPolygon(const QPolygonF &polygon);
    void addText(const QPointF &point, const QFont &f, const QString &text);
    inline void addText(qreal x, qreal y, const QFont &f, const QString &text);
    void addPath(const QPainterPath &path);
    void addRegion(const QRegion &region);

    void connectPath(const QPainterPath &path);

    bool contains(const QPointF &pt) const;
    bool contains(const QRectF &rect) const;
    bool intersects(const QRectF &rect) const;

    QRectF boundingRect() const;
    QRectF controlPointRect() const;

    Qt::FillRule fillRule() const;
    void setFillRule(Qt::FillRule fillRule);

    inline bool isEmpty() const;

    QPainterPath toReversed() const;
    QList<QPolygonF> toSubpathPolygons(const QMatrix &matrix = QMatrix()) const;
    QList<QPolygonF> toFillPolygons(const QMatrix &matrix = QMatrix()) const;
    QPolygonF toFillPolygon(const QMatrix &matrix = QMatrix()) const;

    inline int elementCount() const;
    inline const QPainterPath::Element &elementAt(int i) const;

    bool operator==(const QPainterPath &other) const;
    bool operator!=(const QPainterPath &other) const;

private:
    QPainterPathPrivate *d_ptr;

    inline void ensureData() { if (!d_ptr) ensureData_helper(); }
    void ensureData_helper();
    inline void detach();
    void detach_helper();

    QPainterPathData *d_func() const { return reinterpret_cast<QPainterPathData *>(d_ptr); }

    friend class QPainterPathData;
    friend class QPainterPathStroker;
    friend class QPainterPathStrokerPrivate;
    friend class QMatrix;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPainterPath &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPainterPath &);

};

class QPainterPathPrivate
{
    friend class QPainterPath;
    friend class QPainterPathData;
    friend class QPainterPathStroker;
    friend class QPainterPathStrokerPrivate;
    friend class QMatrix;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPainterPath &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPainterPath &);

private:
    QAtomic ref;
    QVector<QPainterPath::Element> elements;
};

template <> class QTypeInfo<QPainterPath::Element> { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPainterPath::Element)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPainterPath::Element"; } };


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPainterPath &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPainterPath &);


class __declspec(dllimport) QPainterPathStroker
{
    inline QPainterPathStrokerPrivate* d_func() { return reinterpret_cast<QPainterPathStrokerPrivate *>(d_ptr); } inline const QPainterPathStrokerPrivate* d_func() const { return reinterpret_cast<const QPainterPathStrokerPrivate *>(d_ptr); } friend class QPainterPathStrokerPrivate;
public:
    QPainterPathStroker();
    ~QPainterPathStroker();

    void setWidth(qreal width);
    qreal width() const;

    void setCapStyle(Qt::PenCapStyle style);
    Qt::PenCapStyle capStyle() const;

    void setJoinStyle(Qt::PenJoinStyle style);
    Qt::PenJoinStyle joinStyle() const;

    void setMiterLimit(qreal length);
    qreal miterLimit() const;

    void setCurveThreshold(qreal threshold);
    qreal curveThreshold() const;

    void setDashPattern(Qt::PenStyle);
    void setDashPattern(const QVector<qreal> &dashPattern);
    QVector<qreal> dashPattern() const;

    QPainterPath createStroke(const QPainterPath &path) const;

private:
    QPainterPathStrokerPrivate *d_ptr;
};

inline void QPainterPath::moveTo(qreal x, qreal y)
{
    moveTo(QPointF(x, y));
}

inline void QPainterPath::lineTo(qreal x, qreal y)
{
    lineTo(QPointF(x, y));
}

inline void QPainterPath::arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLenght)
{
    arcTo(QRectF(x, y, w, h), startAngle, arcLenght);
}

inline void QPainterPath::cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
                                   qreal endPtx, qreal endPty)
{
    cubicTo(QPointF(ctrlPt1x, ctrlPt1y), QPointF(ctrlPt2x, ctrlPt2y),
            QPointF(endPtx, endPty));
}

inline void QPainterPath::quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty)
{
    quadTo(QPointF(ctrlPtx, ctrlPty), QPointF(endPtx, endPty));
}

inline void QPainterPath::addEllipse(qreal x, qreal y, qreal w, qreal h)
{
    addEllipse(QRectF(x, y, w, h));
}

inline void QPainterPath::addRect(qreal x, qreal y, qreal w, qreal h)
{
    addRect(QRectF(x, y, w, h));
}

inline void QPainterPath::addText(qreal x, qreal y, const QFont &f, const QString &text)
{
    addText(QPointF(x, y), f, text);
}

inline bool QPainterPath::isEmpty() const
{
    return !d_ptr || (d_ptr->elements.size() == 1 && d_ptr->elements.first().type == MoveToElement);
}

inline int QPainterPath::elementCount() const
{
    return d_ptr ? d_ptr->elements.size() : 0;
}

inline const QPainterPath::Element &QPainterPath::elementAt(int i) const
{
    do {if(!(d_ptr))qt_assert("d_ptr","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpainterpath.h",248);} while (0);
    do {if(!(i >= 0 && i < elementCount()))qt_assert("i >= 0 && i < elementCount()","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qpainterpath.h",249);} while (0);
    return d_ptr->elements.at(i);
}

inline void QPainterPath::detach()
{
    if (d_ptr->ref != 1)
        detach_helper();
}











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;







class QPrinterPrivate;
class QPaintEngine;

class __declspec(dllimport) QPrinter : public QPaintDevice
{
    inline QPrinterPrivate* d_func() { return reinterpret_cast<QPrinterPrivate *>(d_ptr); } inline const QPrinterPrivate* d_func() const { return reinterpret_cast<const QPrinterPrivate *>(d_ptr); } friend class QPrinterPrivate;
public:
    enum PrinterMode { ScreenResolution, PrinterResolution, HighResolution };

    explicit QPrinter(PrinterMode mode = ScreenResolution);
   ~QPrinter();

    int devType() const;

    enum Orientation { Portrait, Landscape };

    enum PageSize    { A4, B5, Letter, Legal, Executive,
		       A0, A1, A2, A3, A5, A6, A7, A8, A9, B0, B1,
		       B10, B2, B3, B4, B6, B7, B8, B9, C5E, Comm10E,
		       DLE, Folio, Ledger, Tabloid, Custom, NPageSize = Custom };

    enum PageOrder   { FirstPageFirst,
		       LastPageFirst };

    enum ColorMode   { GrayScale,
		       Color };

    enum PaperSource { OnlyOne,
		       Lower,
		       Middle,
		       Manual,
		       Envelope,
                       EnvelopeManual,
		       Auto,
		       Tractor,
		       SmallFormat,
                       LargeFormat,
		       LargeCapacity,
		       Cassette,
		       FormSource };

    enum PrinterState { Idle,
                        Active,
                        Aborted,
                        Error };





    void setPrinterName(const QString &);
    QString printerName() const;

    void setOutputFileName(const QString &);
    QString outputFileName()const;

    void setPrintProgram(const QString &);
    QString printProgram() const;

    void setDocName(const QString &);
    QString docName() const;

    void setCreator(const QString &);
    QString creator() const;

    void setOrientation(Orientation);
    Orientation orientation() const;

    void setPageSize(PageSize);
    PageSize pageSize() const;

    void setPageOrder(PageOrder);
    PageOrder pageOrder() const;

    void setResolution(int);
    int resolution() const;

    void setColorMode(ColorMode);
    ColorMode colorMode() const;

    void setCollateCopies(bool collate);
    bool collateCopies() const;

    void setFullPage(bool);
    bool fullPage() const;

    void setNumCopies(int);
    int numCopies() const;

    void setPaperSource(PaperSource);
    PaperSource paperSource() const;

    QList<int> supportedResolutions() const;


    void setWinPageSize(int winPageSize);
    int winPageSize() const;


    QRect paperRect() const;
    QRect pageRect() const;






    bool newPage();
    bool abort();

    PrinterState printerState() const;

    QPaintEngine *paintEngine() const;


    HDC getDC() const;
    void releaseDC(HDC hdc) const;




































protected:
    int         metric(PaintDeviceMetric) const;

private:
    QPrinter(const QPrinter &); QPrinter &operator=(const QPrinter &);

    QPrinterPrivate *d_ptr;

    friend class QPrintDialogWin;
};































typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QPrintEngine
{
public:
    virtual ~QPrintEngine() {}
    enum PrintEnginePropertyKey {
        PPK_CollateCopies,
        PPK_ColorMode,
        PPK_Creator,
        PPK_DocumentName,
        PPK_FullPage,
        PPK_NumberOfCopies,
        PPK_Orientation,
        PPK_OutputFileName,
        PPK_PageOrder,
        PPK_PageRect,
        PPK_PageSize,
        PPK_PaperRect,
        PPK_PaperSource,
        PPK_PrinterName,
        PPK_PrinterProgram,
        PPK_Resolution,
        PPK_SelectionOption,
        PPK_SupportedResolutions,

        PPK_WindowsPageSize,

        PPK_CustomBase = 0xff00
    };

    virtual void setProperty(PrintEnginePropertyKey key, const QVariant &value) = 0;
    virtual QVariant property(PrintEnginePropertyKey key) const = 0;

    virtual bool newPage() = 0;
    virtual bool abort() = 0;

    virtual int metric(QPaintDevice::PaintDeviceMetric) const = 0;

    virtual QPrinter::PrinterState printerState() const = 0;


    virtual HDC getPrinterDC() const { return 0; }
    virtual void releasePrinterDC(HDC) const { }


};






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QStylePainter : public QPainter
{
public:
    inline QStylePainter() : QPainter(), widget(0), wstyle(0) {}
    inline explicit QStylePainter(QWidget *w) { begin(w, w); }
    inline QStylePainter(QPaintDevice *pd, QWidget *w) { begin(pd, w); }
    inline bool begin(QWidget *w) { return begin(w, w); }
    inline bool begin(QPaintDevice *pd, QWidget *w) {
        do {if(!(w))qt_assert_x("QStylePainter::QStylePainter", "Widget must be non-zero","d:\\depot\\qt\\include\\qtgui\\../../src/gui/painting/qstylepainter.h",31);} while (0);
        widget = w;
        wstyle = w->style();
        return QPainter::begin(pd);
    };
    inline void drawPrimitive(QStyle::PrimitiveElement pe, const QStyleOption &opt);
    inline void drawControl(QStyle::ControlElement ce, const QStyleOption &opt);
    inline void drawComplexControl(QStyle::ComplexControl cc, const QStyleOptionComplex &opt);
    inline void drawItemText(const QRect &r, int flags, const QPalette &pal, bool enabled,
                             const QString &text, QPalette::ColorRole textRole = QPalette::NoRole);
    inline void drawItemPixmap(const QRect &r, int flags, const QPixmap &pixmap);
    inline QStyle *style() const { return wstyle; }

private:
    QWidget *widget;
    QStyle *wstyle;
};

void QStylePainter::drawPrimitive(QStyle::PrimitiveElement pe, const QStyleOption &opt)
{
    wstyle->drawPrimitive(pe, &opt, this, widget);
}

void QStylePainter::drawControl(QStyle::ControlElement ce, const QStyleOption &opt)
{
    wstyle->drawControl(ce, &opt, this, widget);
}

void QStylePainter::drawComplexControl(QStyle::ComplexControl cc, const QStyleOptionComplex &opt)
{
    wstyle->drawComplexControl(cc, &opt, this, widget);
}

void QStylePainter::drawItemText(const QRect &r, int flags, const QPalette &pal, bool enabled,
                                 const QString &text, QPalette::ColorRole textRole)
{
    wstyle->drawItemText(this, r, flags, pal, enabled, text, textRole);
}

void QStylePainter::drawItemPixmap(const QRect &r, int flags, const QPixmap &pixmap)
{
    wstyle->drawItemPixmap(this, r, flags, pixmap);
}

































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;









































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class __declspec(dllimport) QCommonStyle: public QStyle
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    QCommonStyle();
    ~QCommonStyle();

    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
                       const QWidget *w = 0) const;
    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
                     const QWidget *w = 0) const;
    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
    void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
                            const QWidget *w = 0) const;
    SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
                                     const QPoint &pt, const QWidget *w = 0) const;
    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt, SubControl sc,
                         const QWidget *w = 0) const;
    QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
                           const QSize &contentsSize, const QWidget *widget = 0) const;

    int pixelMetric(PixelMetric m, const QStyleOption *opt = 0, const QWidget *widget = 0) const;

    int styleHint(StyleHint sh, const QStyleOption *opt = 0, const QWidget *w = 0,
                  QStyleHintReturn *shret = 0) const;

    QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *opt = 0,
                           const QWidget *widget = 0) const;

    QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
                                const QStyleOption *opt) const;

private:
    QCommonStyle(const QCommonStyle &); QCommonStyle &operator=(const QCommonStyle &);
};









































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QPalette;
class QFocusFrame;

class QMotifStylePrivate;
class __declspec(dllimport) QMotifStyle : public QCommonStyle
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QMotifStyle(bool useHighlightCols=false);
    virtual ~QMotifStyle();

    void setUseHighlightColors(bool);
    bool useHighlightColors() const;

    void polish(QPalette&);
    void polish(QWidget*);
    void polish(QApplication*);

    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
                        const QWidget *w = 0) const;

    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
                      const QWidget *w = 0) const;

    void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
                            const QWidget *w = 0) const;

    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
                         SubControl sc, const QWidget *widget = 0) const;

    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
                     const QWidget *widget = 0) const;

    QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
                           const QSize &contentsSize, const QWidget *widget = 0) const;

    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;

    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
                           const QWidget *widget = 0) const;

    int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
                  QStyleHintReturn *returnData = 0) const;

    bool event(QEvent *);

    QPalette standardPalette() const;
protected:
    QPointer<QFocusFrame> focus;
private:
    QMotifStyle(const QMotifStyle &); QMotifStyle &operator=(const QMotifStyle &);

    bool highlightCols;
};







typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QCDEStyle : public QMotifStyle
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:

    explicit QCDEStyle(bool useHighlightCols = false);
    virtual ~QCDEStyle();

    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
                    const QWidget *widget = 0) const;

    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
                             const QWidget *w = 0) const;

    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
                        const QWidget *w = 0) const;

    QPalette standardPalette() const;

};






























































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class __declspec(dllimport) QWindowsStyle : public QCommonStyle
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QWindowsStyle();
    ~QWindowsStyle();

    void polish(QApplication*);
    void unpolish(QApplication*);

    void polish(QWidget*);
    void unpolish(QWidget*);

    void polish(QPalette &);

    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
                       const QWidget *w = 0) const;
    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
                     const QWidget *w = 0) const;
    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
    void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
                            const QWidget *w = 0) const;
    QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
                           const QSize &contentsSize, const QWidget *widget = 0) const;

    int pixelMetric(PixelMetric pm, const QStyleOption *option = 0, const QWidget *widget = 0) const;

    int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
                  QStyleHintReturn *returnData = 0) const;

    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
                           const QWidget *widget = 0) const;

private:
    QWindowsStyle(const QWindowsStyle &); QWindowsStyle &operator=(const QWindowsStyle &);

    class Private;
    Private *d;
};







typedef QtValidLicenseForGuiModule QtGuiModule;



class QPlastiqueStylePrivate;
class __declspec(dllimport) QPlastiqueStyle : public QWindowsStyle
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QPlastiqueStyle();
    ~QPlastiqueStyle();

    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                       QPainter *painter, const QWidget *widget = 0) const;
    void drawControl(ControlElement element, const QStyleOption *option,
                     QPainter *painter, const QWidget *widget) const;
    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
                            QPainter *painter, const QWidget *widget) const;
    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
                           const QSize &size, const QWidget *widget) const;

    QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
                         SubControl sc, const QWidget *widget) const;

    int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
		  QStyleHintReturn *returnData = 0) const;
    SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
				     const QPoint &pos, const QWidget *widget = 0) const;

    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;

    void polish(QWidget *widget);
    void polish(QApplication *app);
    void polish(QPalette &pal);
    void unpolish(QWidget *widget);
    void unpolish(QApplication *app);

    QPalette standardPalette() const;

private:
    QPlastiqueStylePrivate *d;
};
















































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyle;

class __declspec(dllimport) QStyleFactory
{
public:
    static QStringList keys();
    static QStyle *create(const QString&);
};


















































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyle;

struct __declspec(dllimport) QStyleFactoryInterface : public QFactoryInterface
{
    virtual QStyle *create(const QString &key) = 0;
};


template <> inline QStyleFactoryInterface *qobject_cast<QStyleFactoryInterface *>(QObject *object) { return reinterpret_cast<QStyleFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QStyleFactoryInterface") : 0)); } template <> inline QStyleFactoryInterface *qobject_cast<QStyleFactoryInterface *>(const QObject *object) { return reinterpret_cast<QStyleFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QStyleFactoryInterface") : 0)); }

class __declspec(dllimport) QStylePlugin : public QObject, public QStyleFactoryInterface
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QStylePlugin(QObject *parent = 0);
    ~QStylePlugin();

    virtual QStringList keys() const = 0;
    virtual QStyle *create(const QString &key) = 0;
};

































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QString;
class QVariant;
class QFont;

class QTextFormatCollection;
class QTextFormatPrivate;
class QTextBlockFormat;
class QTextCharFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextFormat;
class QTextObject;
class QTextCursor;
class QTextDocument;
class QTextLength;

__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextLength &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextLength &);

class __declspec(dllimport) QTextLength
{
public:
    enum Type { VariableLength = 0, FixedLength, PercentageLength };

    inline QTextLength() : lengthType(VariableLength), fixedValueOrPercentage(0) {}

    inline explicit QTextLength(Type type, qreal value);

    inline Type type() const { return lengthType; }
    inline qreal value(qreal maximumLength) const
    {
        switch (lengthType) {
            case FixedLength: return fixedValueOrPercentage;
            case VariableLength: return maximumLength;
            case PercentageLength: return fixedValueOrPercentage * maximumLength / qreal(100);
        }
        return -1;
    }

    inline qreal rawValue() const { return fixedValueOrPercentage; }

    inline bool operator==(const QTextLength &other) const
    { return lengthType == other.lengthType
             && qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
    inline bool operator!=(const QTextLength &other) const
    { return lengthType != other.lengthType
             || !qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
    operator QVariant() const;

private:
    Type lengthType;
    qreal fixedValueOrPercentage;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextLength &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextLength &);
};

inline QTextLength::QTextLength(Type atype, qreal avalue)
    : lengthType(atype), fixedValueOrPercentage(avalue) {}

__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextFormat &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextFormat &);

class __declspec(dllimport) QTextFormat
{
    public: static const QMetaObject staticMetaObject; private:

public:
    enum FormatType {
        InvalidFormat = -1,
        BlockFormat = 1,
        CharFormat = 2,
        ListFormat = 3,
        TableFormat = 4,
        FrameFormat = 5,

        UserFormat = 100
    };

    enum Property {
        ObjectIndex = 0x0,


        CssFloat = 0x0800,
        LayoutDirection = 0x0801,

        OutlinePen = 0x810,
        BackgroundBrush = 0x820,
        ForegroundBrush = 0x821,


        BlockAlignment = 0x1010,
        BlockTopMargin = 0x1030,
        BlockBottomMargin = 0x1031,
        BlockLeftMargin = 0x1032,
        BlockRightMargin = 0x1033,
        TextIndent = 0x1034,
        BlockIndent = 0x1040,
        BlockNonBreakableLines = 0x1050,
        BlockTrailingHorizontalRulerWidth = 0x1060,


        FontFamily = 0x2000,
        FontPointSize = 0x2001,
        FontSizeAdjustment = 0x2002,
        FontSizeIncrement = FontSizeAdjustment,
        FontWeight = 0x2003,
        FontItalic = 0x2004,
        FontUnderline = 0x2005,
        FontOverline = 0x2006,
        FontStrikeOut = 0x2007,
        FontFixedPitch = 0x2008,
        FontPixelSize = 0x2009,

        TextUnderlineColor = 0x2010,

        TextVerticalAlignment = 0x2021,

        IsAnchor = 0x2030,
        AnchorHref = 0x2031,
        AnchorName = 0x2032,

        ObjectType = 0x2f00,


        ListStyle = 0x3000,
        ListIndent = 0x3001,


        FrameBorder = 0x4000,
        FrameMargin = 0x4001,
        FramePadding = 0x4002,
        FrameWidth = 0x4003,
        FrameHeight = 0x4004,
        TableColumns = 0x4100,
        TableColumnWidthConstraints = 0x4101,
        TableCellSpacing = 0x4102,
        TableCellPadding = 0x4103,


        TableCellRowSpan = 0x4810,
        TableCellColumnSpan = 0x4811,


        ImageName = 0x5000,
        ImageWidth = 0x5010,
        ImageHeight = 0x5011,


        UserProperty = 0x100000
    };

    enum ObjectTypes {
        NoObject,
        ImageObject,
        TableObject
    };

    QTextFormat();

    explicit QTextFormat(int type);

    QTextFormat(const QTextFormat &rhs);
    QTextFormat &operator=(const QTextFormat &rhs);
    ~QTextFormat();

    void merge(const QTextFormat &other);

    inline bool isValid() const { return type() != InvalidFormat; }

    int type() const;

    int objectIndex() const;
    void setObjectIndex(int object);

    QVariant property(int propertyId) const;
    void setProperty(int propertyId, const QVariant &value);
    void clearProperty(int propertyId);
    bool hasProperty(int propertyId) const;

    bool boolProperty(int propertyId) const;
    int intProperty(int propertyId) const;
    qreal doubleProperty(int propertyId) const;
    QString stringProperty(int propertyId) const;
    QColor colorProperty(int propertyId) const;
    QPen penProperty(int propertyId) const;
    QBrush brushProperty(int propertyId) const;
    QTextLength lengthProperty(int propertyId) const;
    QVector<QTextLength> lengthVectorProperty(int propertyId) const;

    void setProperty(int propertyId, const QVector<QTextLength> &lengths);


    QMap<int, QVariant> properties() const;

    inline void setObjectType(int type);
    inline int objectType() const
    { return intProperty(ObjectType); }

    inline bool isCharFormat() const { return type() == CharFormat; }
    inline bool isBlockFormat() const { return type() == BlockFormat; }
    inline bool isListFormat() const { return type() == ListFormat; }
    inline bool isFrameFormat() const { return type() == FrameFormat; }
    inline bool isImageFormat() const { return type() == CharFormat && objectType() == ImageObject; }
    inline bool isTableFormat() const { return type() == FrameFormat && objectType() == TableObject; }

    QTextBlockFormat toBlockFormat() const;
    QTextCharFormat toCharFormat() const;
    QTextListFormat toListFormat() const;
    QTextTableFormat toTableFormat() const;
    QTextFrameFormat toFrameFormat() const;
    QTextImageFormat toImageFormat() const;

    bool operator==(const QTextFormat &rhs) const;
    inline bool operator!=(const QTextFormat &rhs) const { return !operator==(rhs); }
    operator QVariant() const;

    inline void setLayoutDirection(Qt::LayoutDirection direction)
        { setProperty(QTextFormat::LayoutDirection, direction); }
    inline Qt::LayoutDirection layoutDirection() const
        { return Qt::LayoutDirection(intProperty(QTextFormat::LayoutDirection)); }

    inline void setBackground(const QBrush &brush)
    { setProperty(BackgroundBrush, brush); }
    inline QBrush background() const
    { return brushProperty(BackgroundBrush); }
    inline void clearBackground()
    { clearProperty(BackgroundBrush); }

    inline void setForeground(const QBrush &brush)
    { setProperty(ForegroundBrush, brush); }
    inline QBrush foreground() const
    { return brushProperty(ForegroundBrush); }
    inline void clearForeground()
    { clearProperty(ForegroundBrush); }

private:
    QSharedDataPointer<QTextFormatPrivate> d;
    qint32 format_type;

    friend class QTextFormatCollection;
    friend class QTextCharFormat;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextFormat &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextFormat &);
};

inline void QTextFormat::setObjectType(int atype)
{ setProperty(ObjectType, atype); }

class __declspec(dllimport) QTextCharFormat : public QTextFormat
{
public:
    enum VerticalAlignment { AlignNormal = 0, AlignSuperScript, AlignSubScript };

    QTextCharFormat();

    bool isValid() const { return isCharFormat(); }
    void setFont(const QFont &font);
    QFont font() const;

    inline void setFontFamily(const QString &family)
    { setProperty(FontFamily, family); }
    inline QString fontFamily() const
    { return stringProperty(FontFamily); }

    inline void setFontPointSize(qreal size)
    { setProperty(FontPointSize, size); }
    inline qreal fontPointSize() const
    { return doubleProperty(FontPointSize); }

    inline void setFontWeight(int weight)
    { if (weight == QFont::Normal) weight = 0; setProperty(FontWeight, weight); }
    inline int fontWeight() const
    { int weight = intProperty(FontWeight); if (weight == 0) weight = QFont::Normal; return weight; }
    inline void setFontItalic(bool italic)
    { setProperty(FontItalic, italic); }
    inline bool fontItalic() const
    { return boolProperty(FontItalic); }

    inline void setFontUnderline(bool underline)
    { setProperty(FontUnderline, underline); }
    inline bool fontUnderline() const
    { return boolProperty(FontUnderline); }

    inline void setFontOverline(bool overline)
    { setProperty(FontOverline, overline); }
    inline bool fontOverline() const
    { return boolProperty(FontOverline); }

    inline void setFontStrikeOut(bool strikeOut)
    { setProperty(FontStrikeOut, strikeOut); }
    inline bool fontStrikeOut() const
    { return boolProperty(FontStrikeOut); }

    inline void setUnderlineColor(const QColor &color)
    { setProperty(TextUnderlineColor, color); }
    inline QColor underlineColor() const
    { return colorProperty(TextUnderlineColor); }

    inline void setFontFixedPitch(bool fixedPitch)
    { setProperty(FontFixedPitch, fixedPitch); }
    inline bool fontFixedPitch() const
    { return boolProperty(FontFixedPitch); }

    inline void setVerticalAlignment(VerticalAlignment alignment)
    { setProperty(TextVerticalAlignment, alignment); }
    inline VerticalAlignment verticalAlignment() const
    { return static_cast<VerticalAlignment>(intProperty(TextVerticalAlignment)); }

    inline void setAnchor(bool anchor)
    { setProperty(IsAnchor, anchor); }
    inline bool isAnchor() const
    { return boolProperty(IsAnchor); }

    inline void setAnchorHref(const QString &value)
    { setProperty(AnchorHref, value); }
    inline QString anchorHref() const
    { return stringProperty(AnchorHref); }

    inline void setAnchorName(const QString &name)
    { setProperty(AnchorName, name); }
    inline QString anchorName() const
    { return stringProperty(AnchorName); }

    inline void setTableCellRowSpan(int tableCellRowSpan);
    inline int tableCellRowSpan() const
    { int s = intProperty(TableCellRowSpan); if (s == 0) s = 1; return s; }
    inline void setTableCellColumnSpan(int tableCellColumnSpan);
    inline int tableCellColumnSpan() const
    { int s = intProperty(TableCellColumnSpan); if (s == 0) s = 1; return s; }
};

inline void QTextCharFormat::setTableCellRowSpan(int atableCellRowSpan)
{
    if (atableCellRowSpan == 1)
	atableCellRowSpan = 0;
    setProperty(TableCellRowSpan, atableCellRowSpan);
}

inline void QTextCharFormat::setTableCellColumnSpan(int atableCellColumnSpan)
{
    if (atableCellColumnSpan == 1)
	atableCellColumnSpan = 0;
    setProperty(TableCellColumnSpan, atableCellColumnSpan);
}

class __declspec(dllimport) QTextBlockFormat : public QTextFormat
{
public:
    QTextBlockFormat();

    bool isValid() const { return isBlockFormat(); }

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const
    { return QFlag(intProperty(BlockAlignment)); }

    inline void setTopMargin(qreal margin)
    { setProperty(BlockTopMargin, margin); }
    inline qreal topMargin() const
    { return doubleProperty(BlockTopMargin); }

    inline void setBottomMargin(qreal margin)
    { setProperty(BlockBottomMargin, margin); }
    inline qreal bottomMargin() const
    { return doubleProperty(BlockBottomMargin); }

    inline void setLeftMargin(qreal margin)
    { setProperty(BlockLeftMargin, margin); }
    inline qreal leftMargin() const
    { return doubleProperty(BlockLeftMargin); }

    inline void setRightMargin(qreal margin)
    { setProperty(BlockRightMargin, margin); }
    inline qreal rightMargin() const
    { return doubleProperty(BlockRightMargin); }

    inline void setTextIndent(qreal margin)
    { setProperty(TextIndent, margin); }
    inline qreal textIndent() const
    { return doubleProperty(TextIndent); }

    inline void setIndent(int indent);
    inline int indent() const
    { return intProperty(BlockIndent); }

    inline void setNonBreakableLines(bool b)
    { setProperty(BlockNonBreakableLines, b); }
    inline bool nonBreakableLines() const
    { return boolProperty(BlockNonBreakableLines); }
};

inline void QTextBlockFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }

inline void QTextBlockFormat::setIndent(int aindent)
{ setProperty(BlockIndent, aindent); }

class __declspec(dllimport) QTextListFormat : public QTextFormat
{
public:
    QTextListFormat();

    bool isValid() const { return isListFormat(); }

    enum Style {
        ListDisc = -1,
        ListCircle = -2,
        ListSquare = -3,
        ListDecimal = -4,
        ListLowerAlpha = -5,
        ListUpperAlpha = -6,
        ListStyleUndefined = 0
    };

    inline void setStyle(Style style);
    inline Style style() const
    { return static_cast<Style>(intProperty(ListStyle)); }

    inline void setIndent(int indent);
    inline int indent() const
    { return intProperty(ListIndent); }

};

inline void QTextListFormat::setStyle(Style astyle)
{ setProperty(ListStyle, astyle); }

inline void QTextListFormat::setIndent(int aindent)
{ setProperty(ListIndent, aindent); }

class __declspec(dllimport) QTextImageFormat : public QTextCharFormat
{
public:
    QTextImageFormat();

    bool isValid() const { return isImageFormat(); }

    inline void setName(const QString &name);
    inline QString name() const
    { return stringProperty(ImageName); }

    inline void setWidth(qreal width);
    inline qreal width() const
    { return doubleProperty(ImageWidth); }

    inline void setHeight(qreal height);
    inline qreal height() const
    { return doubleProperty(ImageHeight); }
};

inline void QTextImageFormat::setName(const QString &aname)
{ setProperty(ImageName, aname); }

inline void QTextImageFormat::setWidth(qreal awidth)
{ setProperty(ImageWidth, awidth); }

inline void QTextImageFormat::setHeight(qreal aheight)
{ setProperty(ImageHeight, aheight); }

class __declspec(dllimport) QTextFrameFormat : public QTextFormat
{
public:
    QTextFrameFormat();

    bool isValid() const { return isFrameFormat(); }

    enum Position {
        InFlow,
        FloatLeft,
        FloatRight


    };

    inline void setPosition(Position f)
    { setProperty(CssFloat, f); }
    inline Position position() const
    { return static_cast<Position>(intProperty(CssFloat)); }

    inline void setBorder(qreal border);
    inline qreal border() const
    { return doubleProperty(FrameBorder); }

    inline void setMargin(qreal margin);
    inline qreal margin() const
    { return doubleProperty(FrameMargin); }

    inline void setPadding(qreal padding);
    inline qreal padding() const
    { return doubleProperty(FramePadding); }

    inline void setWidth(qreal width);
    inline void setWidth(const QTextLength &length)
    { setProperty(FrameWidth, length); }
    inline QTextLength width() const
    { return lengthProperty(FrameWidth); }

    inline void setHeight(qreal height);
    inline void setHeight(const QTextLength &height);
    inline QTextLength height() const
    { return lengthProperty(FrameHeight); }
};

inline void QTextFrameFormat::setBorder(qreal aborder)
{ setProperty(FrameBorder, aborder); }

inline void QTextFrameFormat::setMargin(qreal amargin)
{ setProperty(FrameMargin, amargin); }

inline void QTextFrameFormat::setPadding(qreal apadding)
{ setProperty(FramePadding, apadding); }

inline void QTextFrameFormat::setWidth(qreal awidth)
{ setProperty(FrameWidth, QTextLength(QTextLength::FixedLength, awidth)); }

inline void QTextFrameFormat::setHeight(qreal aheight)
{ setProperty(FrameHeight, QTextLength(QTextLength::FixedLength, aheight)); }
inline void QTextFrameFormat::setHeight(const QTextLength &aheight)
{ setProperty(FrameHeight, aheight); }

class __declspec(dllimport) QTextTableFormat : public QTextFrameFormat
{
public:
    QTextTableFormat();

    inline bool isValid() const { return isTableFormat(); }

    inline int columns() const
    { int cols = intProperty(TableColumns); if (cols == 0) cols = 1; return cols; }
    inline void setColumns(int columns);

    inline void setColumnWidthConstraints(const QVector<QTextLength> &constraints)
    { setProperty(TableColumnWidthConstraints, constraints); }

    inline QVector<QTextLength> columnWidthConstraints() const
    { return lengthVectorProperty(TableColumnWidthConstraints); }

    inline void clearColumnWidthConstraints()
    { clearProperty(TableColumnWidthConstraints); }

    inline qreal cellSpacing() const
    { return doubleProperty(TableCellSpacing); }
    inline void setCellSpacing(qreal spacing)
    { setProperty(TableCellSpacing, spacing); }

    inline qreal cellPadding() const
    { return doubleProperty(TableCellPadding); }
    inline void setCellPadding(qreal padding);

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const
    { return QFlag(intProperty(BlockAlignment)); }
};

inline void QTextTableFormat::setColumns(int acolumns)
{
    if (acolumns == 1)
        acolumns = 0;
    setProperty(TableColumns, acolumns);
}

inline void QTextTableFormat::setCellPadding(qreal apadding)
{ setProperty(TableCellPadding, apadding); }

inline void QTextTableFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }





typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextEngine;
class QFont;
class QRect;
class QRegion;
class QTextFormat;
class QPalette;
class QPainter;

class __declspec(dllimport) QTextInlineObject
{
public:
    QTextInlineObject(int i, QTextEngine *e) : itm(i), eng(e) {}
    inline QTextInlineObject() : itm(0), eng(0) {}
    inline bool isValid() const { return eng; }

    QRectF rect() const;
    qreal width() const;
    qreal ascent() const;
    qreal descent() const;
    qreal height() const;

    Qt::LayoutDirection textDirection() const;

    void setWidth(qreal w);
    void setAscent(qreal a);
    void setDescent(qreal d);

    int textPosition() const;

    int formatIndex() const;
    QTextFormat format() const;

private:
    friend class QTextLayout;
    int itm;
    QTextEngine *eng;
};

class QPaintDevice;
class QTextFormat;
class QTextLine;
class QTextBlock;
class QTextOption;

class __declspec(dllimport) QTextLayout
{
public:

    QTextLayout();
    QTextLayout(const QString& text);
    QTextLayout(const QString& text, const QFont &font, QPaintDevice *paintdevice = 0);
    QTextLayout(const QTextBlock &b);
    ~QTextLayout();

    void setFont(const QFont &f);
    QFont font() const;

    void setText(const QString& string);
    QString text() const;

    void setTextOption(const QTextOption &option);
    QTextOption textOption() const;

    void setPreeditArea(int position, const QString &text);
    int preeditAreaPosition() const;
    QString preeditAreaText() const;

    struct FormatRange {
        int start;
        int length;
        QTextCharFormat format;
    };
    void setAdditionalFormats(const QList<FormatRange> &overrides);
    QList<FormatRange> additionalFormats() const;
    void clearAdditionalFormats();

    void setCacheEnabled(bool enable);
    bool cacheEnabled() const;

    void beginLayout();
    void endLayout();

    QTextLine createLine();

    int lineCount() const;
    QTextLine lineAt(int i) const;
    QTextLine lineForTextPosition(int pos) const;

    enum CursorMode {
        SkipCharacters,
        SkipWords
    };
    bool isValidCursorPosition(int pos) const;
    int nextCursorPosition(int oldPos, CursorMode mode = SkipCharacters) const;
    int previousCursorPosition(int oldPos, CursorMode mode = SkipCharacters) const;

    void draw(QPainter *p, const QPointF &pos, const QVector<FormatRange> &selections = QVector<FormatRange>(),
              const QRectF &clip = QRectF()) const;
    void drawCursor(QPainter *p, const QPointF &pos, int cursorPosition) const;

    QPointF position() const;
    void setPosition(const QPointF &p);

    QRectF boundingRect() const;

    qreal minimumWidth() const;
    qreal maximumWidth() const;

    QTextEngine *engine() const { return d; }
private:
    QTextLayout(QTextEngine *e) : d(e) {}
    QTextLayout(const QTextLayout &); QTextLayout &operator=(const QTextLayout &);

    friend class QPainter;
    friend class QPSPrinter;
    QTextEngine *d;
};


class __declspec(dllimport) QTextLine
{
public:
    inline QTextLine() : i(0), eng(0) {}
    inline bool isValid() const { return eng; }

    QRectF rect() const;
    qreal x() const;
    qreal y() const;
    qreal width() const;
    qreal ascent() const;
    qreal descent() const;
    qreal height() const;

    qreal naturalTextWidth() const;
    QRectF naturalTextRect() const;

    enum Edge {
        Leading,
        Trailing
    };
    enum CursorPosition {
        CursorBetweenCharacters,
        CursorOnCharacter
    };


    qreal cursorToX(int *cursorPos, Edge edge = Leading) const;
    inline qreal cursorToX(int cursorPos, Edge edge = Leading) const { return cursorToX(&cursorPos, edge); }
    int xToCursor(qreal x, CursorPosition = CursorBetweenCharacters) const;

    void setLineWidth(qreal width);
    void setNumColumns(int columns);

    void setPosition(const QPointF &pos);

    int textStart() const;
    int textLength() const;

    int lineNumber() const { return i; }

    void draw(QPainter *p, const QPointF &point, const QTextLayout::FormatRange *selection = 0) const;

private:
    QTextLine(int line, QTextEngine *e) : i(line), eng(e) {}
    void layout_helper(int numGlyphs);
    friend class QTextLayout;
    int i;
    QTextEngine *eng;
};

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextFormatCollection;
class QTextListFormat;
class QRect;
class QPainter;
class QPrinter;
class QAbstractTextDocumentLayout;
class QPoint;
class QTextCursor;
class QTextObject;
class QTextFormat;
class QTextFrame;
class QTextBlock;
class QTextCodec;
class QUrl;
class QVariant;

template<typename T> class QVector;

namespace Qt
{
    enum HitTestAccuracy { ExactHit, FuzzyHit };
    enum WhiteSpaceMode {
        WhiteSpaceNormal,
        WhiteSpacePre,
        WhiteSpaceNoWrap,
        WhiteSpaceModeUndefined = -1
    };

    __declspec(dllimport) bool mightBeRichText(const QString&);
    __declspec(dllimport) QString escape(const QString& plain);
    __declspec(dllimport) QString convertFromPlainText(const QString &plain, WhiteSpaceMode mode = WhiteSpacePre);


    __declspec(dllimport) QTextCodec *codecForHtml(const QByteArray &ba);

}

class __declspec(dllimport) QAbstractUndoItem
{
public:
    virtual ~QAbstractUndoItem() = 0;
    virtual void undo() = 0;
    virtual void redo() = 0;
};

inline QAbstractUndoItem::~QAbstractUndoItem()
{
}

class QTextDocumentPrivate;

class __declspec(dllimport) QTextDocument : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    explicit QTextDocument(QObject *parent = 0);
    explicit QTextDocument(const QString &text, QObject *parent = 0);
    ~QTextDocument();

    QTextDocument *clone(QObject *parent = 0) const;

    bool isEmpty() const;
    virtual void clear();

    void setUndoRedoEnabled(bool enable);
    bool isUndoRedoEnabled() const;

    bool isUndoAvailable() const;
    bool isRedoAvailable() const;

    void setDocumentLayout(QAbstractTextDocumentLayout *layout);
    QAbstractTextDocumentLayout *documentLayout() const;

    enum MetaInformation {
        DocumentTitle
    };
    void setMetaInformation(MetaInformation info, const QString &);
    QString metaInformation(MetaInformation info) const;

    QString toHtml(const QByteArray &encoding = QByteArray()) const;
    void setHtml(const QString &html);

    QString toPlainText() const;
    void setPlainText(const QString &text);

    enum FindFlag
    {
        FindBackward        = 0x00001,
        FindCaseSensitively = 0x00002,
        FindWholeWords      = 0x00004
    };
    typedef QFlags<FindFlag> FindFlags;

    QTextCursor find(const QString &expr, int from = 0, FindFlags options = 0) const;
    QTextCursor find(const QString &expr, const QTextCursor &from, FindFlags options = 0) const;

    QTextFrame *frameAt(int pos) const;
    QTextFrame *rootFrame() const;

    QTextObject *object(int objectIndex) const;
    QTextObject *objectForFormat(const QTextFormat &) const;

    QTextBlock findBlock(int pos) const;
    QTextBlock begin() const;
    QTextBlock end() const;

    void setPageSize(const QSizeF &size);
    QSizeF pageSize() const;

    void setDefaultFont(const QFont &font);
    QFont defaultFont() const;

    int pageCount() const;

    bool isModified() const;


    void print(QPrinter *printer) const;


    enum ResourceType {
        HtmlResource  = 1,
        ImageResource = 2,

        UserResource  = 100
    };

    QVariant resource(int type, const QUrl &name) const;
    void addResource(int type, const QUrl &name, const QVariant &resource);

    QVector<QTextFormat> allFormats() const;

    void markContentsDirty(int from, int length);

protected:
    void contentsChange(int from, int charsRemoves, int charsAdded);
    void contentsChanged();
    void undoAvailable(bool);
    void redoAvailable(bool);
    void modificationChanged(bool m);
    void cursorPositionChanged(const QTextCursor &cursor);

public :
    void undo();
    void redo();
    void appendUndoItem(QAbstractUndoItem *);
    void setModified(bool m = true);

protected:
    virtual QTextObject *createObject(const QTextFormat &f);
    virtual QVariant loadResource(int type, const QUrl &name);

public:
    QTextDocumentPrivate *docHandle() const;
private:
    QTextDocument(const QTextDocument &); QTextDocument &operator=(const QTextDocument &);
    inline QTextDocumentPrivate* d_func() { return reinterpret_cast<QTextDocumentPrivate *>(d_ptr); } inline const QTextDocumentPrivate* d_func() const { return reinterpret_cast<const QTextDocumentPrivate *>(d_ptr); } friend class QTextDocumentPrivate;
};

inline QFlags<QTextDocument::FindFlags::enum_type> operator|(QTextDocument::FindFlags::enum_type f1, QTextDocument::FindFlags::enum_type f2) { return QFlags<QTextDocument::FindFlags::enum_type>(f1) | f2; } inline QFlags<QTextDocument::FindFlags::enum_type> operator|(QTextDocument::FindFlags::enum_type f1, QFlags<QTextDocument::FindFlags::enum_type> f2) { return f2 | f1; }


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextDocument;
class QTextCursorPrivate;
class QTextDocumentFragment;
class QTextCharFormat;
class QTextBlockFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextDocumentPrivate;
class QTextList;
class QTextTable;
class QTextFrame;
class QTextBlock;

class __declspec(dllimport) QTextCursor
{
public:
    QTextCursor();
    explicit QTextCursor(QTextDocument *document);
    QTextCursor(QTextDocumentPrivate *p, int pos);
    explicit QTextCursor(QTextFrame *frame);
    explicit QTextCursor(const QTextBlock &block);
    explicit QTextCursor(QTextCursorPrivate *d);
    QTextCursor(const QTextCursor &cursor);
    QTextCursor &operator=(const QTextCursor &other);
    ~QTextCursor();

    bool isNull() const;

    enum MoveMode {
        MoveAnchor,
        KeepAnchor
    };

    void setPosition(int pos, MoveMode mode = MoveAnchor);
    int position() const;

    int anchor() const;

    void insertText(const QString &text);
    void insertText(const QString &text, const QTextCharFormat &format);

    enum MoveOperation {
        NoMove,

        Start,
        Up,
        StartOfLine,
        StartOfBlock,
        StartOfWord,
        PreviousBlock,
        PreviousCharacter,
        PreviousWord,
        Left,
        WordLeft,

        End,
        Down,
        EndOfLine,
        EndOfWord,
        EndOfBlock,
        NextBlock,
        NextCharacter,
        NextWord,
        Right,
        WordRight
    };

    bool movePosition(MoveOperation op, MoveMode = MoveAnchor, int n = 1);

    void deleteChar();
    void deletePreviousChar();

    enum SelectionType {
        WordUnderCursor,
        LineUnderCursor,
        BlockUnderCursor
    };
    void select(SelectionType selection);

    bool hasSelection() const;
    bool hasComplexSelection() const;
    void removeSelectedText();
    void clearSelection();
    int selectionStart() const;
    int selectionEnd() const;

    QString selectedText() const;
    QTextDocumentFragment selection() const;
    void selectedTableCells(int *firstRow, int *numRows, int *firstColumn, int *numColumns) const;

    QTextBlock block() const;

    QTextCharFormat charFormat() const;
    void setCharFormat(const QTextCharFormat &format);
    void mergeCharFormat(const QTextCharFormat &modifier);

    QTextBlockFormat blockFormat() const;
    void setBlockFormat(const QTextBlockFormat &format);
    void mergeBlockFormat(const QTextBlockFormat &modifier);

    QTextCharFormat blockCharFormat() const;
    void setBlockCharFormat(const QTextCharFormat &format);
    void mergeBlockCharFormat(const QTextCharFormat &modifier);

    bool atBlockStart() const;
    bool atBlockEnd() const;
    bool atStart() const;
    bool atEnd() const;

    void insertBlock();
    void insertBlock(const QTextBlockFormat &format);
    void insertBlock(const QTextBlockFormat &format, const QTextCharFormat &charFormat);

    QTextList *insertList(const QTextListFormat &format);
    QTextList *insertList(QTextListFormat::Style style);

    QTextList *createList(const QTextListFormat &format);
    QTextList *createList(QTextListFormat::Style style);
    QTextList *currentList() const;

    QTextTable *insertTable(int rows, int cols, const QTextTableFormat &format);
    QTextTable *insertTable(int rows, int cols);
    QTextTable *currentTable() const;

    QTextFrame *insertFrame(const QTextFrameFormat &format);
    QTextFrame *currentFrame() const;

    void insertFragment(const QTextDocumentFragment &fragment);

    void insertImage(const QTextImageFormat &format);
    void insertImage(const QString &name);

    void beginEditBlock();
    void joinPreviousEditBlock();
    void endEditBlock();

    bool operator!=(const QTextCursor &rhs) const;
    bool operator<(const QTextCursor &rhs) const;
    bool operator<=(const QTextCursor &rhs) const;
    bool operator==(const QTextCursor &rhs) const;
    bool operator>=(const QTextCursor &rhs) const;
    bool operator>(const QTextCursor &rhs) const;

    bool isCopyOf(const QTextCursor &other) const;

private:
    QSharedDataPointer<QTextCursorPrivate> d;
    friend class QTextDocumentFragmentPrivate;
    friend class QTextCopyHelper;
};
























































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractTextDocumentLayoutPrivate;
class QTextBlock;
class QTextObjectInterface;
class QTextFrame;

class __declspec(dllimport) QAbstractTextDocumentLayout : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QAbstractTextDocumentLayoutPrivate* d_func() { return reinterpret_cast<QAbstractTextDocumentLayoutPrivate *>(d_ptr); } inline const QAbstractTextDocumentLayoutPrivate* d_func() const { return reinterpret_cast<const QAbstractTextDocumentLayoutPrivate *>(d_ptr); } friend class QAbstractTextDocumentLayoutPrivate;

public:
    explicit QAbstractTextDocumentLayout(QTextDocument *doc);
    ~QAbstractTextDocumentLayout();

    struct Selection
    {
        QTextCursor cursor;
        QTextCharFormat format;
    };

    struct PaintContext
    {
        PaintContext()
            : cursorPosition(-1)
            {}
        int cursorPosition;
        QPalette palette;
        QRectF clip;
        QVector<Selection> selections;
    };

    virtual void draw(QPainter *painter, const PaintContext &context) = 0;
    virtual int hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const = 0;
    QString anchorAt(const QPointF& pos) const;

    virtual int pageCount() const = 0;
    virtual QSizeF documentSize() const = 0;

    virtual QRectF frameBoundingRect(QTextFrame *frame) const = 0;
    virtual QRectF blockBoundingRect(const QTextBlock &block) const = 0;

    void setPaintDevice(QPaintDevice *device);
    QPaintDevice *paintDevice() const;

    QTextDocument *document() const;

    void registerHandler(int objectType, QObject *component);
    QTextObjectInterface *handlerForObject(int objectType) const;

protected:
    void update(const QRectF & = QRectF(0., 0., 1000000000., 1000000000.));
    void documentSizeChanged(const QSizeF &newSize);
    void pageCountChanged(int newPages);

protected:
    QAbstractTextDocumentLayout(QAbstractTextDocumentLayoutPrivate &, QTextDocument *);

    virtual void documentChanged(int from, int charsRemoved, int charsAdded) = 0;

    virtual void resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format);
    virtual void positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format);
    virtual void drawInlineObject(QPainter *painter, const QRectF &rect, QTextInlineObject object, int posInDocument, const QTextFormat &format);

    int formatIndex(int pos);
    QTextCharFormat format(int pos);

private:
    friend class QTextDocument;
    friend class QTextDocumentPrivate;
    friend class QTextEngine;
    friend class QTextLayout;
    friend class QTextLine;

};

class QTextObjectInterface
{
public:
    virtual ~QTextObjectInterface() {}
    virtual QSizeF intrinsicSize(QTextDocument *doc, int posInDocument, const QTextFormat &format) = 0;
    virtual void drawObject(QPainter *painter, const QRectF &rect, QTextDocument *doc, int posInDocument, const QTextFormat &format) = 0;
};
template <> inline QTextObjectInterface *qobject_cast<QTextObjectInterface *>(QObject *object) { return reinterpret_cast<QTextObjectInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QTextObjectInterface") : 0)); } template <> inline QTextObjectInterface *qobject_cast<QTextObjectInterface *>(const QObject *object) { return reinterpret_cast<QTextObjectInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QTextObjectInterface") : 0)); }






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QStringList;
template <class T> class QList;
struct QFontDef;
class QFontEngine;

class QFontDatabasePrivate;

class __declspec(dllimport) QFontDatabase
{
public:
    enum WritingSystem {
        Any,

        Latin,
        Greek,
        Cyrillic,
        Armenian,
        Hebrew,
        Arabic,
        Syriac,
        Thaana,
        Devanagari,
        Bengali,
        Gurmukhi,
        Gujarati,
        Oriya,
        Tamil,
        Telugu,
        Kannada,
        Malayalam,
        Sinhala,
        Thai,
        Lao,
        Tibetan,
        Myanmar,
        Georgian,
        Khmer,
        SimplifiedChinese,
        TraditionalChinese,
        Japanese,
        Korean,
        Vietnamese,

        Other,

        WritingSystemsCount
    };

    static QList<int> standardSizes();

    QFontDatabase();

    QList<WritingSystem> writingSystems() const;
    QStringList families(WritingSystem writingSystem = Any) const;
    QStringList styles(const QString &family) const;
    QList<int> pointSizes(const QString &family, const QString &style = QString());
    QList<int> smoothSizes(const QString &family, const QString &style);
    QString styleString(const QFont &font);

    QFont font(const QString &family, const QString &style, int pointSize) const;

    bool isBitmapScalable(const QString &family, const QString &style = QString()) const;
    bool isSmoothlyScalable(const QString &family, const QString &style = QString()) const;
    bool isScalable(const QString &family, const QString &style = QString()) const;
    bool isFixedPitch(const QString &family, const QString &style = QString()) const;

    bool italic(const QString &family, const QString &style) const;
    bool bold(const QString &family, const QString &style) const;
    int weight(const QString &family, const QString &style) const;

    static QString writingSystemName(WritingSystem writingSystem);
    static QString writingSystemSample(WritingSystem writingSystem);

private:
    static void createDatabase();
    static void parseFontName(const QString &name, QString &foundry, QString &family);
    static QFontEngine *findFont(int script, const QFontPrivate *fp,
                                 const QFontDef &request, int force_encoding_id = -1);

    friend struct QFontDef;
    friend class QFontPrivate;
    friend class QFontDialog;
    friend class QFontEngineMultiXLFD;

    QFontDatabasePrivate *d;
};














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextObjectPrivate;
class QTextDocument;
class QTextDocumentPrivate;
class QTextCursor;
class QTextBlock;
class QTextFragment;
class QTextLayout;
class QTextList;

class __declspec(dllimport) QTextObject : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

protected:
    explicit QTextObject(QTextDocument *doc);
    ~QTextObject();

    void setFormat(const QTextFormat &format);

public:
    int formatType() const;
    QTextFormat format() const;
    int formatIndex() const;

    QTextDocument *document() const;

    int objectIndex() const;

    QTextDocumentPrivate *docHandle() const;

protected:
    QTextObject(QTextObjectPrivate &p, QTextDocument *doc);

private:
    inline QTextObjectPrivate* d_func() { return reinterpret_cast<QTextObjectPrivate *>(d_ptr); } inline const QTextObjectPrivate* d_func() const { return reinterpret_cast<const QTextObjectPrivate *>(d_ptr); } friend class QTextObjectPrivate;
    QTextObject(const QTextObject &); QTextObject &operator=(const QTextObject &);
    friend class QTextDocumentPrivate;
};

class QTextBlockGroupPrivate;
class __declspec(dllimport) QTextBlockGroup : public QTextObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

protected:
    explicit QTextBlockGroup(QTextDocument *doc);
    ~QTextBlockGroup();

    virtual void blockInserted(const QTextBlock &block);
    virtual void blockRemoved(const QTextBlock &block);
    virtual void blockFormatChanged(const QTextBlock &block);

    QList<QTextBlock> blockList() const;

protected:
    QTextBlockGroup(QTextBlockGroupPrivate &p, QTextDocument *doc);
private:
    inline QTextBlockGroupPrivate* d_func() { return reinterpret_cast<QTextBlockGroupPrivate *>(d_ptr); } inline const QTextBlockGroupPrivate* d_func() const { return reinterpret_cast<const QTextBlockGroupPrivate *>(d_ptr); } friend class QTextBlockGroupPrivate;
    QTextBlockGroup(const QTextBlockGroup &); QTextBlockGroup &operator=(const QTextBlockGroup &);
    friend class QTextDocumentPrivate;
};

class __declspec(dllimport) QTextFrameLayoutData {
public:
    virtual ~QTextFrameLayoutData();
};

class QTextFramePrivate;
class __declspec(dllimport) QTextFrame : public QTextObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QTextFrame(QTextDocument *doc);
    ~QTextFrame();

    inline void setFrameFormat(const QTextFrameFormat &format);
    QTextFrameFormat frameFormat() const { return QTextObject::format().toFrameFormat(); }

    QTextCursor firstCursorPosition() const;
    QTextCursor lastCursorPosition() const;
    int firstPosition() const;
    int lastPosition() const;

    QTextFrameLayoutData *layoutData() const;
    void setLayoutData(QTextFrameLayoutData *data);

    QList<QTextFrame *> childFrames() const;
    QTextFrame *parentFrame() const;

    class __declspec(dllimport) iterator {
        QTextFrame *f;
        int b;
        int e;
        QTextFrame *cf;
        int cb;

        friend class QTextFrame;
        friend class QTextTableCell;
        friend class QTextDocumentLayoutPrivate;
        iterator(QTextFrame *frame, int block, int begin, int end);
    public:
        iterator();
        iterator(const iterator &o);
        iterator &operator=(const iterator &o);

        QTextFrame *parentFrame() const { return f; }

        QTextFrame *currentFrame() const;
        QTextBlock currentBlock() const;

        bool atEnd() const { return !cf && cb == e; }

        inline bool operator==(const iterator &o) const { return f == o.f && cf == o.cf && cb == o.cb; }
        inline bool operator!=(const iterator &o) const { return f != o.f || cf != o.cf || cb != o.cb; }
        iterator &operator++();
        inline iterator operator++(int) { iterator tmp = *this; operator++(); return tmp; }
        iterator &operator--();
        inline iterator operator--(int) { iterator tmp = *this; operator--(); return tmp; }
    };


    typedef iterator Iterator;

    iterator begin() const;
    iterator end() const;

protected:
    QTextFrame(QTextFramePrivate &p, QTextDocument *doc);
private:
    friend class QTextDocumentPrivate;
    inline QTextFramePrivate* d_func() { return reinterpret_cast<QTextFramePrivate *>(d_ptr); } inline const QTextFramePrivate* d_func() const { return reinterpret_cast<const QTextFramePrivate *>(d_ptr); } friend class QTextFramePrivate;
    QTextFrame(const QTextFrame &); QTextFrame &operator=(const QTextFrame &);
};
template <> class QTypeInfo<QTextFrame::iterator> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFrame::iterator)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextFrame::iterator"; } };

inline void QTextFrame::setFrameFormat(const QTextFrameFormat &aformat)
{ QTextObject::setFormat(aformat); }

class __declspec(dllimport) QTextBlockUserData {
public:
    virtual ~QTextBlockUserData();
};

class __declspec(dllimport) QTextBlock
{
    friend class QSyntaxHighlighter;
public:
    inline QTextBlock(QTextDocumentPrivate *priv, int b) : p(priv), n(b) {}
    inline QTextBlock() : p(0), n(0) {}
    inline QTextBlock(const QTextBlock &o) : p(o.p), n(o.n) {}
    inline QTextBlock &operator=(const QTextBlock &o) { p = o.p; n = o.n; return *this; }

    inline bool isValid() const { return p != 0 && n != 0; }

    inline bool operator==(const QTextBlock &o) const { return p == o.p && n == o.n; }
    inline bool operator!=(const QTextBlock &o) const { return p != o.p || n != o.n; }
    inline bool operator<(const QTextBlock &o) const { return position() < o.position(); }

    int position() const;
    int length() const;
    bool contains(int position) const;

    QTextLayout *layout() const;
    QTextBlockFormat blockFormat() const;
    int blockFormatIndex() const;
    QTextCharFormat charFormat() const;
    int charFormatIndex() const;

    QString text() const;

    const QTextDocument *document() const;

    QTextList *textList() const;

    QTextBlockUserData *userData() const;
    void setUserData(QTextBlockUserData *data);

    int userState() const;
    void setUserState(int state);

    class __declspec(dllimport) iterator {
        const QTextDocumentPrivate *p;
        int b;
        int e;
        int n;
        friend class QTextBlock;
        iterator(const QTextDocumentPrivate *priv, int begin, int end, int f) : p(priv), b(begin), e(end), n(f) {}
    public:
        iterator() : p(0), b(0), e(0), n(0) {}
        iterator(const iterator &o) : p(o.p), b(o.b), e(o.e), n(o.n) {}

        QTextFragment fragment() const;

        bool atEnd() const { return n == e; }

        inline bool operator==(const iterator &o) const { return p == o.p && n == o.n; }
        inline bool operator!=(const iterator &o) const { return p != o.p || n != o.n; }
        iterator &operator++();
        inline iterator operator++(int) { iterator tmp = *this; operator++(); return tmp; }
        iterator &operator--();
        inline iterator operator--(int) { iterator tmp = *this; operator--(); return tmp; }
    };


    typedef iterator Iterator;

    iterator begin() const;
    iterator end() const;

    QTextBlock next() const;
    QTextBlock previous() const;

    inline QTextDocumentPrivate *docHandle() const { return p; }

private:
    QTextDocumentPrivate *p;
    int n;
    friend class QTextDocumentPrivate;
    friend class QTextLayout;
};

template <> class QTypeInfo<QTextBlock> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextBlock)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextBlock"; } };
template <> class QTypeInfo<QTextBlock::iterator> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextBlock::iterator)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextBlock::iterator"; } };


class __declspec(dllimport) QTextFragment
{
public:
    inline QTextFragment(const QTextDocumentPrivate *priv, int f, int fe) : p(priv), n(f), ne(fe) {}
    inline QTextFragment() : p(0), n(0), ne(0) {}
    inline QTextFragment(const QTextFragment &o) : p(o.p), n(o.n), ne(o.ne) {}
    inline QTextFragment &operator=(const QTextFragment &o) { p = o.p; n = o.n; ne = o.ne; return *this; }

    inline bool isValid() const { return p && n; }

    inline bool operator==(const QTextFragment &o) const { return p == o.p && n == o.n; }
    inline bool operator!=(const QTextFragment &o) const { return p != o.p || n != o.n; }
    inline bool operator<(const QTextFragment &o) const { return position() < o.position(); }

    int position() const;
    int length() const;
    bool contains(int position) const;

    QTextCharFormat charFormat() const;
    int charFormatIndex() const;
    QString text() const;

private:
    const QTextDocumentPrivate *p;
    int n;
    int ne;
};

template <> class QTypeInfo<QTextFragment> { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFragment)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextFragment"; } };





class QTextDocument;
class QSyntaxHighlighterPrivate;
class QTextCharFormat;
class QFont;
class QColor;
class QTextBlockUserData;
class QTextEdit;

class __declspec(dllimport) QSyntaxHighlighter : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QSyntaxHighlighterPrivate* d_func() { return reinterpret_cast<QSyntaxHighlighterPrivate *>(d_ptr); } inline const QSyntaxHighlighterPrivate* d_func() const { return reinterpret_cast<const QSyntaxHighlighterPrivate *>(d_ptr); } friend class QSyntaxHighlighterPrivate;
public:
    QSyntaxHighlighter(QObject *parent);
    QSyntaxHighlighter(QTextDocument *parent);
    QSyntaxHighlighter(QTextEdit *parent);
    virtual ~QSyntaxHighlighter();

    void setDocument(QTextDocument *doc);
    QTextDocument *document() const;

protected:
    virtual void highlightBlock(const QString &text) = 0;

    void setFormat(int start, int count, const QTextCharFormat &format);
    void setFormat(int start, int count, const QColor &color);
    void setFormat(int start, int count, const QFont &font);
    QTextCharFormat format(int pos) const;

    int previousBlockState() const;
    int currentBlockState() const;
    void setCurrentBlockState(int newState);

    void setCurrentBlockUserData(QTextBlockUserData *data);
    QTextBlockUserData *currentBlockUserData() const;

private:
    QSyntaxHighlighter(const QSyntaxHighlighter &); QSyntaxHighlighter &operator=(const QSyntaxHighlighter &);

};






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextStream;
class QTextDocument;
class QTextDocumentFragmentPrivate;
class QTextCursor;

class __declspec(dllimport) QTextDocumentFragment
{
public:
    QTextDocumentFragment();
    explicit QTextDocumentFragment(const QTextDocument *document);
    explicit QTextDocumentFragment(const QTextCursor &range);
    QTextDocumentFragment(const QTextDocumentFragment &rhs);
    QTextDocumentFragment &operator=(const QTextDocumentFragment &rhs);
    ~QTextDocumentFragment();

    bool isEmpty() const;

    QString toPlainText() const;
    QString toHtml() const;

    static QTextDocumentFragment fromPlainText(const QString &plainText);
    static QTextDocumentFragment fromHtml(const QString &html);

private:
    QTextDocumentFragmentPrivate *d;
    friend class QTextCursor;
};




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextListPrivate;
class QTextCursor;

class __declspec(dllimport) QTextList : public QTextBlockGroup
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QTextList(QTextDocument *doc);
    ~QTextList();

    int count() const;

    inline bool isEmpty() const
    { return count() == 0; }

    QTextBlock item(int i) const;

    int itemNumber(const QTextBlock &) const;
    QString itemText(const QTextBlock &) const;

    void removeItem(int i);
    void remove(const QTextBlock &);

    void add(const QTextBlock &block);

    inline void setFormat(const QTextListFormat &format);
    QTextListFormat format() const { return QTextObject::format().toListFormat(); }

private:
    QTextList(const QTextList &); QTextList &operator=(const QTextList &);
    inline QTextListPrivate* d_func() { return reinterpret_cast<QTextListPrivate *>(d_ptr); } inline const QTextListPrivate* d_func() const { return reinterpret_cast<const QTextListPrivate *>(d_ptr); } friend class QTextListPrivate;
};

inline void QTextList::setFormat(const QTextListFormat &aformat)
{ QTextObject::setFormat(aformat); }

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextCursor;
class QTextTable;
class QTextTablePrivate;

class __declspec(dllimport) QTextTableCell
{
public:
    QTextTableCell() : table(0) {}
    ~QTextTableCell() {}
    QTextTableCell(const QTextTableCell &o) : table(o.table), fragment(o.fragment) {}
    QTextTableCell &operator=(const QTextTableCell &o)
    { table = o.table; fragment = o.fragment; return *this; }

    QTextCharFormat format() const;

    int row() const;
    int column() const;

    int rowSpan() const;
    int columnSpan() const;

    inline bool isValid() const { return table != 0; }

    QTextCursor firstCursorPosition() const;
    QTextCursor lastCursorPosition() const;
    int firstPosition() const;
    int lastPosition() const;

    inline bool operator==(const QTextTableCell &other) const
    { return table == other.table && fragment == other.fragment; }
    inline bool operator!=(const QTextTableCell &other) const
    { return !operator==(other); }

    QTextFrame::iterator begin() const;
    QTextFrame::iterator end() const;

private:
    friend class QTextTable;
    QTextTableCell(const QTextTable *t, int f)
        : table(t), fragment(f) {}

    const QTextTable *table;
    int fragment;
};

class __declspec(dllimport) QTextTable : public QTextFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QTextTable(QTextDocument *doc);
    ~QTextTable();

    void resize(int rows, int cols);
    void insertRows(int pos, int num);
    void insertColumns(int pos, int num);
    void removeRows(int pos, int num);
    void removeColumns(int pos, int num);

    void mergeCells(int row, int col, int numRows, int numCols);
    void mergeCells(const QTextCursor &cursor);
    void splitCell(int row, int col, int numRows, int numCols);

    int rows() const;
    int columns() const;

    QTextTableCell cellAt(int row, int col) const;
    QTextTableCell cellAt(int position) const;
    QTextTableCell cellAt(const QTextCursor &c) const;

    QTextCursor rowStart(const QTextCursor &c) const;
    QTextCursor rowEnd(const QTextCursor &c) const;

    inline void setFormat(const QTextTableFormat &format);
    QTextTableFormat format() const { return QTextObject::format().toTableFormat(); }

private:
    QTextTable(const QTextTable &); QTextTable &operator=(const QTextTable &);
    inline QTextTablePrivate* d_func() { return reinterpret_cast<QTextTablePrivate *>(d_ptr); } inline const QTextTablePrivate* d_func() const { return reinterpret_cast<const QTextTablePrivate *>(d_ptr); } friend class QTextTablePrivate;
    friend class QTextTableCell;
};

inline void QTextTable::setFormat(const QTextTableFormat &aformat)
{ QTextObject::setFormat(aformat); }










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QButtonGroup;
class QAbstractButtonPrivate;

class __declspec(dllimport) QAbstractButton : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:











public:
    explicit QAbstractButton(QWidget* parent=0);
    ~QAbstractButton();

    void setText(const QString &text);
    QString text() const;

    void setIcon(const QIcon &icon);
    QIcon icon() const;

    QSize iconSize() const;

    void setShortcut(const QKeySequence &key);
    QKeySequence shortcut() const;

    void setCheckable(bool);
    bool isCheckable() const;

    bool isChecked() const;

    void setDown(bool);
    bool isDown() const;

    void setAutoRepeat(bool);
    bool autoRepeat() const;

    void setAutoExclusive(bool);
    bool autoExclusive() const;


    QButtonGroup *group() const;


public :
    void setIconSize(const QSize &size);
    void animateClick(int msec = 100);
    void click();
    void toggle();
    void setChecked(bool);

protected:
    void pressed();
    void released();
    void clicked(bool checked = false);
    void toggled(bool checked);

protected:
    virtual void paintEvent(QPaintEvent *e) = 0;
    virtual bool hitButton(const QPoint &pos) const;
    virtual void checkStateSet();
    virtual void nextCheckState();

    bool event(QEvent *e);
    void keyPressEvent(QKeyEvent *e);
    void keyReleaseEvent(QKeyEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void mouseMoveEvent(QMouseEvent *e);
    void focusInEvent(QFocusEvent *e);
    void focusOutEvent(QFocusEvent *e);
    void changeEvent(QEvent *e);
    void timerEvent(QTimerEvent *e);


















protected:
    QAbstractButton(QAbstractButtonPrivate &dd, QWidget* parent = 0);

private:
    inline QAbstractButtonPrivate* d_func() { return reinterpret_cast<QAbstractButtonPrivate *>(d_ptr); } inline const QAbstractButtonPrivate* d_func() const { return reinterpret_cast<const QAbstractButtonPrivate *>(d_ptr); } friend class QAbstractButtonPrivate;
    QAbstractButton(const QAbstractButton &); QAbstractButton &operator=(const QAbstractButton &);
    friend class QButtonGroup;
};


























































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAbstractButton;
class QAbstractButtonPrivate;
class QButtonGroupPrivate;

class __declspec(dllimport) QButtonGroup : public QObject
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:


public:
    explicit QButtonGroup(QObject *parent = 0);
    ~QButtonGroup();

    void setExclusive(bool);
    bool exclusive() const;

    void addButton(QAbstractButton *);
    void addButton(QAbstractButton *, int id);
    void removeButton(QAbstractButton *);

    QList<QAbstractButton*> buttons() const;

    QAbstractButton * checkedButton() const;


    QAbstractButton *button(int id) const;
    void setId(QAbstractButton *button, int id);
    int id(QAbstractButton *button) const;
    int checkedId() const;

protected:
    void buttonClicked(QAbstractButton *);
    void buttonClicked(int);







private:
    QButtonGroup(const QButtonGroup &); QButtonGroup &operator=(const QButtonGroup &);
    inline QButtonGroupPrivate* d_func() { return reinterpret_cast<QButtonGroupPrivate *>(d_ptr); } inline const QButtonGroupPrivate* d_func() const { return reinterpret_cast<const QButtonGroupPrivate *>(d_ptr); } friend class QButtonGroupPrivate;
    friend class QAbstractButton;
    friend class QAbstractButtonPrivate;
};





























































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QCheckBoxPrivate;

class __declspec(dllimport) QCheckBox : public QAbstractButton
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QCheckBox(QWidget *parent=0);
    explicit QCheckBox(const QString &text, QWidget *parent=0);


    QSize sizeHint() const;

    void setTristate(bool y = true);
    bool isTristate() const;

    Qt::CheckState checkState() const;
    void setCheckState(Qt::CheckState state);

protected:
    void stateChanged(int);

protected:
    bool hitButton(const QPoint &pos) const;
    void checkStateSet();
    void nextCheckState();
    void paintEvent(QPaintEvent *);


















private:
    inline QCheckBoxPrivate* d_func() { return reinterpret_cast<QCheckBoxPrivate *>(d_ptr); } inline const QCheckBoxPrivate* d_func() const { return reinterpret_cast<const QCheckBoxPrivate *>(d_ptr); } friend class QCheckBoxPrivate;
    QCheckBox(const QCheckBox &); QCheckBox &operator=(const QCheckBox &);
};


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAbstractItemView;
class QLineEdit;
class QComboBoxPrivate;

class __declspec(dllimport) QComboBox : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:


















public:
    explicit QComboBox(QWidget *parent = 0);
    ~QComboBox();

    int maxVisibleItems() const;
    void setMaxVisibleItems(int maxItems);

    int count() const;
    void setMaxCount(int max);
    int maxCount() const;

    bool autoCompletion() const;
    void setAutoCompletion(bool enable);

    bool duplicatesEnabled() const;
    void setDuplicatesEnabled(bool enable);

    void setFrame(bool);
    bool hasFrame() const;

    inline int findText(const QString &text,
                        Qt::MatchFlags flags = Qt::MatchExactly|Qt::MatchCaseSensitive) const
        { return findData(text, Qt::EditRole, flags); }
    int findData(const QVariant &data, int role = Qt::UserRole,
                 Qt::MatchFlags flags = Qt::MatchExactly|Qt::MatchCaseSensitive) const;

    enum InsertPolicy {
        NoInsert,
        InsertAtTop,
        InsertAtCurrent,
        InsertAtBottom,
        InsertAfterCurrent,
        InsertBeforeCurrent









    };




    InsertPolicy insertPolicy() const;
    void setInsertPolicy(InsertPolicy policy);

    enum SizeAdjustPolicy {
        AdjustToContents,
        AdjustToContentsOnFirstShow,
        AdjustToMinimumContentsLength
    };

    SizeAdjustPolicy sizeAdjustPolicy() const;
    void setSizeAdjustPolicy(SizeAdjustPolicy policy);
    int minimumContentsLength() const;
    void setMinimumContentsLength(int characters);
    QSize iconSize() const;
    void setIconSize(const QSize &size);

    bool isEditable() const;
    void setEditable(bool editable);
    void setLineEdit(QLineEdit *edit);
    QLineEdit *lineEdit() const;

    void setValidator(const QValidator *v);
    const QValidator *validator() const;


    QAbstractItemDelegate *itemDelegate() const;
    void setItemDelegate(QAbstractItemDelegate *delegate);

    QAbstractItemModel *model() const;
    void setModel(QAbstractItemModel *model);

    QModelIndex rootModelIndex() const;
    void setRootModelIndex(const QModelIndex &index);

    int modelColumn() const;
    void setModelColumn(int visibleColumn);

    int currentIndex() const;
    void setCurrentIndex(int index);

    QString currentText() const;

    QString itemText(int index) const;
    QIcon itemIcon(int index) const;
    QVariant itemData(int index, int role = Qt::UserRole) const;

    inline void addItem(const QString &text, const QVariant &userData = QVariant());
    inline void addItem(const QIcon &icon, const QString &text,
                        const QVariant &userData = QVariant());
    inline void addItems(const QStringList &texts)
        { insertItems(count(), texts); }

    inline void insertItem(int index, const QString &text, const QVariant &userData = QVariant());
    void insertItem(int index, const QIcon &icon, const QString &text,
                    const QVariant &userData = QVariant());
    void insertItems(int index, const QStringList &texts);

    void removeItem(int index);

    void setItemText(int index, const QString &text);
    void setItemIcon(int index, const QIcon &icon);
    void setItemData(int index, const QVariant &value, int role = Qt::UserRole);

    QAbstractItemView *view() const;
    void setView(QAbstractItemView *itemView);

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    virtual void showPopup();
    virtual void hidePopup();

    bool event(QEvent *event);

public :
    void clear();
    void clearEditText();
    void setEditText(const QString &text);

protected:
    void editTextChanged(const QString &);
    void activated(int index);
    void activated(const QString &);
    void highlighted(int index);
    void highlighted(const QString &);

protected:
    void focusInEvent(QFocusEvent *e);
    void focusOutEvent(QFocusEvent *e);
    void changeEvent(QEvent *e);
    void resizeEvent(QResizeEvent *e);
    void paintEvent(QPaintEvent *e);
    void showEvent(QShowEvent *e);
    void hideEvent(QHideEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void keyPressEvent(QKeyEvent *e);
    void keyReleaseEvent(QKeyEvent *e);
    void wheelEvent(QWheelEvent *e);
    void inputMethodEvent(QInputMethodEvent *);
    QVariant inputMethodQuery(Qt::InputMethodQuery) const;











































private:
    inline QComboBoxPrivate* d_func() { return reinterpret_cast<QComboBoxPrivate *>(d_ptr); } inline const QComboBoxPrivate* d_func() const { return reinterpret_cast<const QComboBoxPrivate *>(d_ptr); } friend class QComboBoxPrivate;
    QComboBox(const QComboBox &); QComboBox &operator=(const QComboBox &);









};

inline void QComboBox::addItem(const QString &atext, const QVariant &auserData)
{ insertItem(count(), atext, auserData); }
inline void QComboBox::addItem(const QIcon &aicon, const QString &atext,
                               const QVariant &auserData)
{ insertItem(count(), aicon, atext, auserData); }

inline void QComboBox::insertItem(int aindex, const QString &atext,
                                  const QVariant &auserData)
{ insertItem(aindex, QIcon(), atext, auserData); }







































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QDateTimeEditPrivate;
class __declspec(dllimport) QDateTimeEdit : public QAbstractSpinBox
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:














public:
    enum Section {
        NoSection = 0x0000,
        AmPmSection = 0x0001,
        MSecSection = 0x0002,
        SecondSection = 0x0004,
        MinuteSection = 0x0008,
        HourSection   = 0x0010,
        DaySection    = 0x0100,
        MonthSection  = 0x0200,
        YearSection   = 0x0400,
        TimeSections_Mask = AmPmSection|MSecSection|SecondSection|MinuteSection|HourSection,
        DateSections_Mask = DaySection|MonthSection|YearSection
    };

    typedef QFlags<Section> Sections;

    explicit QDateTimeEdit(QWidget *parent = 0);
    explicit QDateTimeEdit(const QDateTime &dt, QWidget *parent = 0);
    explicit QDateTimeEdit(const QDate &d, QWidget *parent = 0);
    explicit QDateTimeEdit(const QTime &t, QWidget *parent = 0);

    QDateTime dateTime() const;
    QDate date() const;
    QTime time() const;

    QDate minimumDate() const;
    void setMinimumDate(const QDate &min);
    void clearMinimumDate();

    QDate maximumDate() const;
    void setMaximumDate(const QDate &max);
    void clearMaximumDate();

    void setDateRange(const QDate &min, const QDate &max);

    QTime minimumTime() const;
    void setMinimumTime(const QTime &min);
    void clearMinimumTime();

    QTime maximumTime() const;
    void setMaximumTime(const QTime &max);
    void clearMaximumTime();

    void setTimeRange(const QTime &min, const QTime &max);

    Sections displayedSections() const;
    Section currentSection() const;
    void setCurrentSection(Section section);

    QString sectionText(Section s) const;

    QString displayFormat() const;
    void setDisplayFormat(const QString &format);

    QSize sizeHint() const;

    virtual void clear();
    virtual void stepBy(int steps);

    bool event(QEvent *e);
protected:
    void dateTimeChanged(const QDateTime &date);
    void timeChanged(const QTime &date);
    void dateChanged(const QDate &date);

public :
    void setDateTime(const QDateTime &dateTime);
    void setDate(const QDate &date);
    void setTime(const QTime &time);

protected:
    virtual void keyPressEvent(QKeyEvent *e);

    virtual void wheelEvent(QWheelEvent *e);

    virtual void focusInEvent(QFocusEvent *e);
    virtual bool focusNextPrevChild(bool next);
    virtual QValidator::State validate(QString &input, int &pos) const;
    virtual void fixup(QString &input) const;

    virtual QDateTime dateTimeFromText(const QString &text) const;
    virtual QString textFromDateTime(const QDateTime &dt) const;
    virtual StepEnabled stepEnabled() const;

private:
    inline QDateTimeEditPrivate* d_func() { return reinterpret_cast<QDateTimeEditPrivate *>(d_ptr); } inline const QDateTimeEditPrivate* d_func() const { return reinterpret_cast<const QDateTimeEditPrivate *>(d_ptr); } friend class QDateTimeEditPrivate;
    QDateTimeEdit(const QDateTimeEdit &); QDateTimeEdit &operator=(const QDateTimeEdit &);
};

class __declspec(dllimport) QTimeEdit : public QDateTimeEdit
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QTimeEdit(QWidget *parent = 0);
    QTimeEdit(const QTime &t, QWidget *parent = 0);
};

class __declspec(dllimport) QDateEdit : public QDateTimeEdit
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QDateEdit(QWidget *parent = 0);
    QDateEdit(const QDate &t, QWidget *parent = 0);
};

inline QFlags<QDateTimeEdit::Sections::enum_type> operator|(QDateTimeEdit::Sections::enum_type f1, QDateTimeEdit::Sections::enum_type f2) { return QFlags<QDateTimeEdit::Sections::enum_type>(f1) | f2; } inline QFlags<QDateTimeEdit::Sections::enum_type> operator|(QDateTimeEdit::Sections::enum_type f1, QFlags<QDateTimeEdit::Sections::enum_type> f2) { return f2 | f1; }
















































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QDialPrivate;

class __declspec(dllimport) QDial: public QAbstractSlider
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:





public:
    explicit QDial(QWidget *parent = 0);

    ~QDial();

    bool wrapping() const;

    int notchSize() const;

    void setNotchTarget(double target);
    qreal notchTarget() const;
    bool notchesVisible() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

public :
    void setNotchesVisible(bool visible);
    void setWrapping(bool on);

protected:
    void resizeEvent(QResizeEvent *re);
    void paintEvent(QPaintEvent *pe);

    void mousePressEvent(QMouseEvent *me);
    void mouseReleaseEvent(QMouseEvent *me);
    void mouseMoveEvent(QMouseEvent *me);

    void sliderChange(SliderChange change);













private:
    inline QDialPrivate* d_func() { return reinterpret_cast<QDialPrivate *>(d_ptr); } inline const QDialPrivate* d_func() const { return reinterpret_cast<const QDialPrivate *>(d_ptr); } friend class QDialPrivate;
    QDial(const QDial &); QDial &operator=(const QDial &);
};






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QDockWidgetLayout;
class QDockWidgetPrivate;
class QMainWindow;

class __declspec(dllimport) QDockWidget : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    explicit QDockWidget(const QString &title, QWidget *parent = 0, Qt::WFlags flags = 0);
    explicit QDockWidget(QWidget *parent = 0, Qt::WFlags flags = 0);
    ~QDockWidget();

    QWidget *widget() const;
    void setWidget(QWidget *widget);

    enum DockWidgetFeature {
        DockWidgetClosable    = 0x01,
        DockWidgetMovable     = 0x02,
        DockWidgetFloatable   = 0x04,

        DockWidgetFeatureMask = 0x07,
        AllDockWidgetFeatures = DockWidgetFeatureMask,
        NoDockWidgetFeatures  = 0x00,

        Reserved              = 0xff
    };
    typedef QFlags<DockWidgetFeature> DockWidgetFeatures;

    void setFeatures(DockWidgetFeatures features);
    DockWidgetFeatures features() const;

    void setFloating(bool floating);
    inline bool isFloating() const { return isWindow(); }

    void setAllowedAreas(Qt::DockWidgetAreas areas);
    Qt::DockWidgetAreas allowedAreas() const;

    inline bool isAreaAllowed(Qt::DockWidgetArea area) const
    { return (allowedAreas() & area) == area; }


    QAction *toggleViewAction() const;


protected:
    void featuresChanged(QDockWidget::DockWidgetFeatures features);
    void topLevelChanged(bool topLevel);
    void allowedAreasChanged(Qt::DockWidgetAreas allowedAreas);

protected:
    void changeEvent(QEvent *event);
    void closeEvent(QCloseEvent *event);
    void paintEvent(QPaintEvent *event);
    bool event(QEvent *event);

private:
    inline QDockWidgetPrivate* d_func() { return reinterpret_cast<QDockWidgetPrivate *>(d_ptr); } inline const QDockWidgetPrivate* d_func() const { return reinterpret_cast<const QDockWidgetPrivate *>(d_ptr); } friend class QDockWidgetPrivate;
    QDockWidget(const QDockWidget &); QDockWidget &operator=(const QDockWidget &);


    friend class QDockWidgetLayout;
};

inline QFlags<QDockWidget::DockWidgetFeatures::enum_type> operator|(QDockWidget::DockWidgetFeatures::enum_type f1, QDockWidget::DockWidgetFeatures::enum_type f2) { return QFlags<QDockWidget::DockWidgetFeatures::enum_type>(f1) | f2; } inline QFlags<QDockWidget::DockWidgetFeatures::enum_type> operator|(QDockWidget::DockWidgetFeatures::enum_type f1, QFlags<QDockWidget::DockWidgetFeatures::enum_type> f2) { return f2 | f1; }




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QFocusFramePrivate;
class __declspec(dllimport) QFocusFrame : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QFocusFrame(QWidget *parent=0);
    ~QFocusFrame();

    void setWidget(QWidget *widget);
    QWidget *widget() const;

protected:
    bool eventFilter(QObject *, QEvent *);
    void paintEvent(QPaintEvent *);

private:
    inline QFocusFramePrivate* d_func() { return reinterpret_cast<QFocusFramePrivate *>(d_ptr); } inline const QFocusFramePrivate* d_func() const { return reinterpret_cast<const QFocusFramePrivate *>(d_ptr); } friend class QFocusFramePrivate;
    QFocusFrame(const QFocusFrame &); QFocusFrame &operator=(const QFocusFrame &);
};






























































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QGroupBoxPrivate;
class __declspec(dllimport) QGroupBox : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    explicit QGroupBox(QWidget* parent=0);
    explicit QGroupBox(const QString &title, QWidget* parent=0);
    ~QGroupBox();

    QString title() const;
    void setTitle(const QString &);

    Qt::Alignment alignment() const;
    void setAlignment(int);

    QSize minimumSizeHint() const;

    bool isFlat() const;
    void setFlat(bool b);
    bool isCheckable() const;
    void setCheckable(bool b);
    bool isChecked() const;

public :
    void setChecked(bool b);

protected:
    void toggled(bool);

protected:
    bool event(QEvent *);
    void childEvent(QChildEvent *);
    void resizeEvent(QResizeEvent *);
    void paintEvent(QPaintEvent *);
    void focusInEvent(QFocusEvent *);
    void changeEvent(QEvent *);







private:
    QGroupBox(const QGroupBox &); QGroupBox &operator=(const QGroupBox &);
    inline QGroupBoxPrivate* d_func() { return reinterpret_cast<QGroupBoxPrivate *>(d_ptr); } inline const QGroupBoxPrivate* d_func() const { return reinterpret_cast<const QGroupBoxPrivate *>(d_ptr); } friend class QGroupBoxPrivate;


};












































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QLabelPrivate;

class __declspec(dllimport) QLabel : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:









public:
    explicit QLabel(QWidget *parent=0, Qt::WFlags f=0);
    explicit QLabel(const QString &text, QWidget *parent=0, Qt::WFlags f=0);
    ~QLabel();

    QString text() const;
    const QPixmap *pixmap() const;

    const QPicture *picture() const;


    QMovie *movie() const;


    Qt::TextFormat textFormat() const;
    void setTextFormat(Qt::TextFormat);

    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment);

    void setWordWrap(bool on);
    bool wordWrap() const;

    int indent() const;
    void setIndent(int);

    int margin() const;
    void setMargin(int);

    bool hasScaledContents() const;
    void setScaledContents(bool);
    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setBuddy(QWidget *);
    QWidget *buddy() const;

    int heightForWidth(int) const;

public :
    void setText(const QString &);
    void setPixmap(const QPixmap &);

    void setPicture(const QPicture &);


    void setMovie(QMovie *movie);

    void setNum(int);
    void setNum(double);
    void clear();

protected:
    bool event(QEvent *e);
    void paintEvent(QPaintEvent *);
    void changeEvent(QEvent *);














private:
    QLabel(const QLabel &); QLabel &operator=(const QLabel &);
    inline QLabelPrivate* d_func() { return reinterpret_cast<QLabelPrivate *>(d_ptr); } inline const QLabelPrivate* d_func() const { return reinterpret_cast<const QLabelPrivate *>(d_ptr); } friend class QLabelPrivate;





    friend class QTipLabel;
};


















































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;




class QLCDNumberPrivate;
class __declspec(dllimport) QLCDNumber : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:








public:
    explicit QLCDNumber(QWidget* parent = 0);
    explicit QLCDNumber(uint numDigits, QWidget* parent = 0);
    ~QLCDNumber();

    enum Mode {
        Hex, Dec, Oct, Bin



    };
    enum SegmentStyle {
        Outline, Filled, Flat
    };

    bool smallDecimalPoint() const;

    int numDigits() const;
    void setNumDigits(int nDigits);

    bool checkOverflow(double num) const;
    bool checkOverflow(int num) const;

    Mode mode() const;
    void setMode(Mode);

    SegmentStyle segmentStyle() const;
    void setSegmentStyle(SegmentStyle);

    double value() const;
    int intValue() const;

    QSize sizeHint() const;

public :
    void display(const QString &str);
    void display(int num);
    void display(double num);
    void setHexMode();
    void setDecMode();
    void setOctMode();
    void setBinMode();
    void setSmallDecimalPoint(bool);

protected:
    void overflow();

protected:
    void paintEvent(QPaintEvent *);

public:





private:
    QLCDNumber(const QLCDNumber &); QLCDNumber &operator=(const QLCDNumber &);
    inline QLCDNumberPrivate* d_func() { return reinterpret_cast<QLCDNumberPrivate *>(d_ptr); } inline const QLCDNumberPrivate* d_func() const { return reinterpret_cast<const QLCDNumberPrivate *>(d_ptr); } friend class QLCDNumberPrivate;
};















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QDockWidget;
class QMainWindowPrivate;
class QMenuBar;
class QStatusBar;
class QToolBar;
class QMenu;

class __declspec(dllimport) QMainWindow : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:




public:
    explicit QMainWindow(QWidget *parent = 0, Qt::WFlags flags = 0);
    ~QMainWindow();

    QSize iconSize() const;
    void setIconSize(const QSize &iconSize);

    Qt::ToolButtonStyle toolButtonStyle() const;
    void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);


    QMenuBar *menuBar() const;
    void setMenuBar(QMenuBar *menubar);



    QStatusBar *statusBar() const;
    void setStatusBar(QStatusBar *statusbar);


    QWidget *centralWidget() const;
    void setCentralWidget(QWidget *widget);

    void setCorner(Qt::Corner corner, Qt::DockWidgetArea area);
    Qt::DockWidgetArea corner(Qt::Corner corner) const;


    void addToolBarBreak(Qt::ToolBarArea area = Qt::TopToolBarArea);
    void insertToolBarBreak(QToolBar *before);

    void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar);
    void addToolBar(QToolBar *toolbar);
    QToolBar *addToolBar(const QString &title);
    void insertToolBar(QToolBar *before, QToolBar *toolbar);
    void removeToolBar(QToolBar *toolbar);

    Qt::ToolBarArea toolBarArea(QToolBar *toolbar) const;


    void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget);
    void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget,
                       Qt::Orientation orientation);
    void splitDockWidget(QDockWidget *after, QDockWidget *dockwidget,
                         Qt::Orientation orientation);
    void removeDockWidget(QDockWidget *dockwidget);

    Qt::DockWidgetArea dockWidgetArea(QDockWidget *dockwidget) const;


    QByteArray saveState(int version = 0) const;
    bool restoreState(const QByteArray &state, int version = 0);


    virtual QMenu *createPopupMenu();






protected:
    void iconSizeChanged(const QSize &iconSize);
    void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);

protected:
    void contextMenuEvent(QContextMenuEvent *event);
    bool event(QEvent *event);

private:
    inline QMainWindowPrivate* d_func() { return reinterpret_cast<QMainWindowPrivate *>(d_ptr); } inline const QMainWindowPrivate* d_func() const { return reinterpret_cast<const QMainWindowPrivate *>(d_ptr); } friend class QMainWindowPrivate;
    QMainWindow(const QMainWindow &); QMainWindow &operator=(const QMainWindow &);
};

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QMenuPrivate;





class __declspec(dllimport) QMenu : public QWidget
{
private:
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QMenuPrivate* d_func() { return reinterpret_cast<QMenuPrivate *>(d_ptr); } inline const QMenuPrivate* d_func() const { return reinterpret_cast<const QMenuPrivate *>(d_ptr); } friend class QMenuPrivate;





public:
    explicit QMenu(QWidget *parent = 0);
    explicit QMenu(const QString &title, QWidget *parent = 0);
    ~QMenu();




    using QWidget::addAction;

    QAction *addAction(const QString &text);
    QAction *addAction(const QIcon &icon, const QString &text);
    QAction *addAction(const QString &text, const QObject *receiver, const char* member, const QKeySequence &shortcut = 0);
    QAction *addAction(const QIcon &icon, const QString &text, const QObject *receiver, const char* member, const QKeySequence &shortcut = 0);

    QAction *addMenu(QMenu *menu);
    QMenu *addMenu(const QString &title);
    QMenu *addMenu(const QIcon &icon, const QString &title);

    QAction *addSeparator();

    QAction *insertMenu(QAction *before, QMenu *menu);
    QAction *insertSeparator(QAction *before);

    void clear();

    void setTearOffEnabled(bool);
    bool isTearOffEnabled() const;

    bool isTearOffMenuVisible() const;
    void hideTearOffMenu();

    void setDefaultAction(QAction *);
    QAction *defaultAction() const;

    void setActiveAction(QAction *act);
    QAction *activeAction() const;

    void popup(const QPoint &pos, QAction *at=0);
    QAction *exec();
    QAction *exec(const QPoint &pos, QAction *at=0);
    static QAction *exec(QList<QAction*> actions, const QPoint &pos, QAction *at=0);

    QSize sizeHint() const;

    QRect actionGeometry(QAction *) const;
    QAction *actionAt(const QPoint &) const;

    QAction *menuAction() const;

    QString title() const;
    void setTitle(const QString &title);

    QIcon icon() const;
    void setIcon(const QIcon &icon);

    void setNoReplayFor(QWidget *widget);




protected:
    void aboutToShow();
    void triggered(QAction *action);
    void hovered(QAction *action);

protected:
    int columnCount() const;

    void changeEvent(QEvent *);
    void keyPressEvent(QKeyEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void wheelEvent(QWheelEvent *);
    void enterEvent(QEvent *);
    void leaveEvent(QEvent *);
    void hideEvent(QHideEvent *);
    void paintEvent(QPaintEvent *);
    void actionEvent(QActionEvent *);
    void timerEvent(QTimerEvent *);
    bool event(QEvent *);

private :
    void internalSetSloppyAction();
    void internalDelayedPopup();

private:
















































































































































































































private:
    QMenu(const QMenu &); QMenu &operator=(const QMenu &);

    friend class QMenuBar;
    friend class QMenuBarPrivate;
    friend class QTornOffMenu;
    friend class Q3PopupMenu;
    friend class QComboBox;






};































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QMenuBarPrivate;




class __declspec(dllimport) QMenuBar : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QMenuBar(QWidget *parent = 0);
    ~QMenuBar();




    using QWidget::addAction;

    QAction *addAction(const QString &text);
    QAction *addAction(const QString &text, const QObject *receiver, const char* member);

    QAction *addMenu(QMenu *menu);
    QMenu *addMenu(const QString &title);
    QMenu *addMenu(const QIcon &icon, const QString &title);


    QAction *addSeparator();

    QAction *insertMenu(QAction *before, QMenu *menu);

    void clear();

    QAction *activeAction() const;

    void setDefaultUp(bool);
    bool isDefaultUp() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;
    int heightForWidth(int) const;

    QRect actionGeometry(QAction *) const;
    QAction *actionAt(const QPoint &) const;

    void setCornerWidget(QWidget *w, Qt::Corner corner = Qt::TopRightCorner);
    QWidget *cornerWidget(Qt::Corner corner = Qt::TopRightCorner) const;





protected:
    void triggered(QAction *action);
    void hovered(QAction *action);

protected:
    void changeEvent(QEvent *);
    void keyPressEvent(QKeyEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void leaveEvent(QEvent *);
    void paintEvent(QPaintEvent *);
    void resizeEvent(QResizeEvent *);
    void actionEvent(QActionEvent *);
    void focusOutEvent(QFocusEvent *);
    void focusInEvent(QFocusEvent *);
    bool eventFilter(QObject *, QEvent *);
    bool event(QEvent *);












































































































































































private:
    inline QMenuBarPrivate* d_func() { return reinterpret_cast<QMenuBarPrivate *>(d_ptr); } inline const QMenuBarPrivate* d_func() const { return reinterpret_cast<const QMenuBarPrivate *>(d_ptr); } friend class QMenuBarPrivate;
    QMenuBar(const QMenuBar &); QMenuBar &operator=(const QMenuBar &);





    friend class QMenu;
    friend class QMenuPrivate;






};





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;




class QProgressBarPrivate;

class __declspec(dllimport) QProgressBar : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:











public:
    enum Direction { TopToBottom, BottomToTop };

    explicit QProgressBar(QWidget *parent = 0);

    int minimum() const;
    int maximum() const;

    void setRange(int minimum, int maximum);
    int value() const;

    virtual QString text() const;
    void setTextVisible(bool visible);
    bool isTextVisible() const;

    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment alignment);

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    Qt::Orientation orientation() const;

    void setInvertedAppearance(bool invert);
    bool invertedAppearance();
    void setTextDirection(QProgressBar::Direction textDirection);
    QProgressBar::Direction textDirection();

public :
    void reset();
    void setMinimum(int minimum);
    void setMaximum(int maximum);
    void setValue(int value);
    void setOrientation(Qt::Orientation);

protected:
    void valueChanged(int value);

protected:
    void paintEvent(QPaintEvent *);

private:
    inline QProgressBarPrivate* d_func() { return reinterpret_cast<QProgressBarPrivate *>(d_ptr); } inline const QProgressBarPrivate* d_func() const { return reinterpret_cast<const QProgressBarPrivate *>(d_ptr); } friend class QProgressBarPrivate;
    QProgressBar(const QProgressBar &); QProgressBar &operator=(const QProgressBar &);
};






























































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QPushButtonPrivate;
class QMenu;

class __declspec(dllimport) QPushButton : public QAbstractButton
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:





public:
    explicit QPushButton(QWidget *parent=0);
    explicit QPushButton(const QString &text, QWidget *parent=0);
    QPushButton(const QIcon& icon, const QString &text, QWidget *parent=0);
    ~QPushButton();

    QSize sizeHint() const;

    bool autoDefault() const;
    void setAutoDefault(bool);
    bool isDefault() const;
    void setDefault(bool);


    void setMenu(QMenu* menu);
    QMenu* menu() const;


    void setFlat(bool);
    bool isFlat() const;

public :

    void showMenu();


protected:
    void paintEvent(QPaintEvent *);
    void keyPressEvent(QKeyEvent *);
    void focusInEvent(QFocusEvent *);
    void focusOutEvent(QFocusEvent *);

public:










private:
    QPushButton(const QPushButton &); QPushButton &operator=(const QPushButton &);
    inline QPushButtonPrivate* d_func() { return reinterpret_cast<QPushButtonPrivate *>(d_ptr); } inline const QPushButtonPrivate* d_func() const { return reinterpret_cast<const QPushButtonPrivate *>(d_ptr); } friend class QPushButtonPrivate;



};




























































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class __declspec(dllimport) QRadioButton : public QAbstractButton
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QRadioButton(QWidget *parent=0);
    explicit QRadioButton(const QString &text, QWidget *parent=0);

    QSize sizeHint() const;

protected:
    bool hitButton(const QPoint &) const;
    void paintEvent(QPaintEvent *);







private:
    QRadioButton(const QRadioButton &); QRadioButton &operator=(const QRadioButton &);
};


























































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QScrollAreaPrivate;

class __declspec(dllimport) QScrollArea : public QAbstractScrollArea
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:

public:
    explicit QScrollArea(QWidget* parent=0);
    ~QScrollArea();

    QWidget *widget() const;
    void setWidget(QWidget *w);
    QWidget *takeWidget();

    bool widgetResizable() const;
    void setWidgetResizable(bool resizable);

    QSize sizeHint() const;
    bool focusNextPrevChild(bool next);

protected:
    bool event(QEvent *);
    bool eventFilter(QObject *, QEvent *);
    void resizeEvent(QResizeEvent *);
    void scrollContentsBy(int dx, int dy);

private:
    inline QScrollAreaPrivate* d_func() { return reinterpret_cast<QScrollAreaPrivate *>(d_ptr); } inline const QScrollAreaPrivate* d_func() const { return reinterpret_cast<const QScrollAreaPrivate *>(d_ptr); } friend class QScrollAreaPrivate;
    QScrollArea(const QScrollArea &); QScrollArea &operator=(const QScrollArea &);
};



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QScrollBarPrivate;

class __declspec(dllimport) QScrollBar : public QAbstractSlider
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QScrollBar(QWidget *parent=0);
    explicit QScrollBar(Qt::Orientation, QWidget *parent=0);
    ~QScrollBar();

    QSize sizeHint() const;
    bool event(QEvent *event);

protected:
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void hideEvent(QHideEvent*);
    void sliderChange(SliderChange change);
    void contextMenuEvent(QContextMenuEvent *);










private:
    QScrollBar(const QScrollBar &); QScrollBar &operator=(const QScrollBar &);
    inline QScrollBarPrivate* d_func() { return reinterpret_cast<QScrollBarPrivate *>(d_ptr); } inline const QScrollBarPrivate* d_func() const { return reinterpret_cast<const QScrollBarPrivate *>(d_ptr); } friend class QScrollBarPrivate;
};





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QSizeGripPrivate;
class __declspec(dllimport) QSizeGrip : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QSizeGrip(QWidget *parent);
    ~QSizeGrip();

    QSize sizeHint() const;

    void setVisible(bool);
protected:
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);

    bool eventFilter(QObject *, QEvent *);
    bool event(QEvent *);

public:



private:
    inline QSizeGripPrivate* d_func() { return reinterpret_cast<QSizeGripPrivate *>(d_ptr); } inline const QSizeGripPrivate* d_func() const { return reinterpret_cast<const QSizeGripPrivate *>(d_ptr); } friend class QSizeGripPrivate;
    QSizeGrip(const QSizeGrip &); QSizeGrip &operator=(const QSizeGrip &);
};


























































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QSpinBoxPrivate;
class __declspec(dllimport) QSpinBox : public QAbstractSpinBox
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:









public:
    explicit QSpinBox(QWidget *parent = 0);






    int value() const;

    QString prefix() const;
    void setPrefix(const QString &p);

    QString suffix() const;
    void setSuffix(const QString &s);

    QString cleanText() const;

    int singleStep() const;
    void setSingleStep(int val);

    int minimum() const;
    void setMinimum(int min);

    int maximum() const;
    void setMaximum(int max);

    void setRange(int min, int max);









protected:
    virtual QValidator::State validate(QString &input, int &pos) const;
    virtual int valueFromText(const QString &text) const;
    virtual QString textFromValue(int v) const;
    virtual void fixup(QString &str) const;


public :
    void setValue(int val);

protected:
    void valueChanged(int);
    void valueChanged(const QString &);

private:
    QSpinBox(const QSpinBox &); QSpinBox &operator=(const QSpinBox &);
    inline QSpinBoxPrivate* d_func() { return reinterpret_cast<QSpinBoxPrivate *>(d_ptr); } inline const QSpinBoxPrivate* d_func() const { return reinterpret_cast<const QSpinBoxPrivate *>(d_ptr); } friend class QSpinBoxPrivate;
};

class QDoubleSpinBoxPrivate;
class __declspec(dllimport) QDoubleSpinBox : public QAbstractSpinBox
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:









public:
    explicit QDoubleSpinBox(QWidget *parent = 0);

    double value() const;

    QString prefix() const;
    void setPrefix(const QString &p);

    QString suffix() const;
    void setSuffix(const QString &s);

    QString cleanText() const;

    double singleStep() const;
    void setSingleStep(double val);

    double minimum() const;
    void setMinimum(double min);

    double maximum() const;
    void setMaximum(double max);

    void setRange(double min, double max);

    int decimals() const;
    void setDecimals(int prec);

    virtual QValidator::State validate(QString &input, int &pos) const;
    virtual double valueFromText(const QString &text) const;
    virtual QString textFromValue(double v) const;
    virtual void fixup(QString &str) const;

public :
    void setValue(double val);

protected:
    void valueChanged(double);
    void valueChanged(const QString &);

private:
    QDoubleSpinBox(const QDoubleSpinBox &); QDoubleSpinBox &operator=(const QDoubleSpinBox &);
    inline QDoubleSpinBoxPrivate* d_func() { return reinterpret_cast<QDoubleSpinBoxPrivate *>(d_ptr); } inline const QDoubleSpinBoxPrivate* d_func() const { return reinterpret_cast<const QDoubleSpinBoxPrivate *>(d_ptr); } friend class QDoubleSpinBoxPrivate;
};













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;


class QSplashScreenPrivate;

class __declspec(dllimport) QSplashScreen : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    explicit QSplashScreen(const QPixmap &pixmap = QPixmap(), Qt::WFlags f = 0);
    QSplashScreen(QWidget *parent, const QPixmap &pixmap = QPixmap(), Qt::WFlags f = 0);
    virtual ~QSplashScreen();

    void setPixmap(const QPixmap &pixmap);
    const QPixmap pixmap() const;
    void finish(QWidget *w);
    void repaint();

public :
    void showMessage(const QString &message, int alignment = Qt::AlignLeft,
                  const QColor &color = Qt::black);
    void clearMessage();






protected:
    void messageChanged(const QString &message);

protected:
    virtual void drawContents(QPainter *painter);
    void mousePressEvent(QMouseEvent *);

private:
    QSplashScreen(const QSplashScreen &); QSplashScreen &operator=(const QSplashScreen &);
    inline QSplashScreenPrivate* d_func() { return reinterpret_cast<QSplashScreenPrivate *>(d_ptr); } inline const QSplashScreenPrivate* d_func() const { return reinterpret_cast<const QSplashScreenPrivate *>(d_ptr); } friend class QSplashScreenPrivate;
};




































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QSplitterPrivate;
class QTextStream;
template <typename T> class QList;

class QSplitterHandle;

class __declspec(dllimport) QSplitter : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:






public:
    explicit QSplitter(QWidget* parent = 0);
    explicit QSplitter(Qt::Orientation, QWidget* parent = 0);
    ~QSplitter();

    void addWidget(QWidget *widget);
    void insertWidget(int index, QWidget *widget);

    void setOrientation(Qt::Orientation);
    Qt::Orientation orientation() const;

    void setChildrenCollapsible(bool);
    bool childrenCollapsible() const;

    void setCollapsible(int index, bool);
    bool isCollapsible(int index) const;
    void setOpaqueResize(bool opaque = true);
    bool opaqueResize() const;
    void refresh();

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    QList<int> sizes() const;
    void setSizes(const QList<int> &list);

    QByteArray saveState() const;
    bool restoreState(const QByteArray &state);

    int handleWidth() const;
    void setHandleWidth(int);

    int indexOf(QWidget *w) const;
    QWidget *widget(int index) const;
    int count() const;

    void getRange(int index, int *, int *) const;
    QSplitterHandle *handle(int index) const;

    void setStretchFactor(int index, int stretch);

protected:
    void splitterMoved(int pos, int index);

protected:
    virtual QSplitterHandle *createHandle();

    void childEvent(QChildEvent *);

    bool event(QEvent *);
    void resizeEvent(QResizeEvent *);

    void changeEvent(QEvent *);
    void moveSplitter(int pos, int index);
    void setRubberBand(int position);
    int closestLegalPosition(int, int);













private:
    QSplitter(const QSplitter &); QSplitter &operator=(const QSplitter &);
    inline QSplitterPrivate* d_func() { return reinterpret_cast<QSplitterPrivate *>(d_ptr); } inline const QSplitterPrivate* d_func() const { return reinterpret_cast<const QSplitterPrivate *>(d_ptr); } friend class QSplitterPrivate;
private:
    friend class QSplitterHandle;
};



__declspec(dllimport) QTextStream& operator<<(QTextStream&, const QSplitter&);
__declspec(dllimport) QTextStream& operator>>(QTextStream&, QSplitter&);



class QSplitterHandlePrivate;
class __declspec(dllimport) QSplitterHandle : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
public:
    QSplitterHandle(Qt::Orientation o, QSplitter *parent);
    void setOrientation(Qt::Orientation o);
    Qt::Orientation orientation() const;
    bool opaqueResize() const;
    QSplitter *splitter() const;

    QSize sizeHint() const;

protected:
    void paintEvent(QPaintEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    bool event(QEvent *);

    void moveSplitter(int p);
    int closestLegalPosition(int p);

private:
    QSplitterHandle(const QSplitterHandle &); QSplitterHandle &operator=(const QSplitterHandle &);
    inline QSplitterHandlePrivate* d_func() { return reinterpret_cast<QSplitterHandlePrivate *>(d_ptr); } inline const QSplitterHandlePrivate* d_func() const { return reinterpret_cast<const QSplitterHandlePrivate *>(d_ptr); } friend class QSplitterHandlePrivate;
};












































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QStackedWidgetPrivate;

class __declspec(dllimport) QStackedWidget : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QStackedWidget(QWidget *parent=0);
    ~QStackedWidget();

    int addWidget(QWidget *w);
    int insertWidget(int index, QWidget *w);
    void removeWidget(QWidget *w);

    QWidget *currentWidget() const;
    int currentIndex() const;

    int indexOf(QWidget *) const;
    QWidget *widget(int) const;
    int count() const;

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *w);

protected:
    void currentChanged(int);
    void widgetRemoved(int index);


private:
    QStackedWidget(const QStackedWidget &); QStackedWidget &operator=(const QStackedWidget &);
    inline QStackedWidgetPrivate* d_func() { return reinterpret_cast<QStackedWidgetPrivate *>(d_ptr); } inline const QStackedWidgetPrivate* d_func() const { return reinterpret_cast<const QStackedWidgetPrivate *>(d_ptr); } friend class QStackedWidgetPrivate;
};





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QStatusBarPrivate;

class __declspec(dllimport) QStatusBar: public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QStatusBar(QWidget* parent=0);
    virtual ~QStatusBar();

    void addWidget(QWidget *widget, int stretch = 0);
    void addPermanentWidget(QWidget *widget, int stretch = 0);
    void removeWidget(QWidget *widget);

    void setSizeGripEnabled(bool);
    bool isSizeGripEnabled() const;

    QString currentMessage() const;

public :
    void showMessage(const QString &text, int timeout = 0);
    void clearMessage();











protected:
    void messageChanged(const QString &text);

protected:
    void paintEvent(QPaintEvent *);
    void resizeEvent(QResizeEvent *);

    void reformat();
    void hideOrShow();
    bool event(QEvent *);

private:
    QStatusBar(const QStatusBar &); QStatusBar &operator=(const QStatusBar &);
    inline QStatusBarPrivate* d_func() { return reinterpret_cast<QStatusBarPrivate *>(d_ptr); } inline const QStatusBarPrivate* d_func() const { return reinterpret_cast<const QStatusBarPrivate *>(d_ptr); } friend class QStatusBarPrivate;
};













































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextCharFormat;
class QStyleSheet;
class QTextDocument;
class QTextCursor;
class QTextBlockFormat;
class QMenu;
class QTextEditPrivate;
class QMimeData;

class __declspec(dllimport) QTextEdit : public QAbstractScrollArea
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:
    inline QTextEditPrivate* d_func() { return reinterpret_cast<QTextEditPrivate *>(d_ptr); } inline const QTextEditPrivate* d_func() const { return reinterpret_cast<const QTextEditPrivate *>(d_ptr); } friend class QTextEditPrivate;













public:
    enum LineWrapMode {
        NoWrap,
        WidgetWidth,
        FixedPixelWidth,
        FixedColumnWidth
    };

    enum AutoFormattingFlag {
        AutoNone = 0,
        AutoBulletList = 0x00000001,
        AutoAll = 0xffffffff
    };

    typedef QFlags<AutoFormattingFlag> AutoFormatting;

    enum CursorAction {
        MoveBackward,
        MoveForward,
        MoveWordBackward,
        MoveWordForward,
        MoveUp,
        MoveDown,
        MoveLineStart,
        MoveLineEnd,
        MoveHome,
        MoveEnd,
        MovePageUp,
        MovePageDown





    };

    explicit QTextEdit(QWidget *parent = 0);
    explicit QTextEdit(const QString &text, QWidget *parent = 0);
    virtual ~QTextEdit();

    void setDocument(QTextDocument *document);
    QTextDocument *document() const;

    void setTextCursor(const QTextCursor &cursor);
    QTextCursor textCursor() const;

    bool isReadOnly() const;
    void setReadOnly(bool ro);

    qreal fontPointSize() const;
    QString fontFamily() const;
    int fontWeight() const;
    bool fontUnderline() const;
    bool fontItalic() const;
    QColor textColor() const;
    QFont currentFont() const;
    Qt::Alignment alignment() const;

    void mergeCurrentCharFormat(const QTextCharFormat &modifier);

    void setCurrentCharFormat(const QTextCharFormat &format);
    QTextCharFormat currentCharFormat() const;

    AutoFormatting autoFormatting() const;
    void setAutoFormatting(AutoFormatting features);

    bool tabChangesFocus() const;
    void setTabChangesFocus(bool b);

    inline void setDocumentTitle(const QString &title)
    { document()->setMetaInformation(QTextDocument::DocumentTitle, title); }
    inline QString documentTitle() const
    { return document()->metaInformation(QTextDocument::DocumentTitle); }

    inline bool isUndoRedoEnabled() const
    { return document()->isUndoRedoEnabled(); }
    inline void setUndoRedoEnabled(bool enable)
    { document()->setUndoRedoEnabled(enable); }

    LineWrapMode lineWrapMode() const;
    void setLineWrapMode(LineWrapMode mode);

    int lineWrapColumnOrWidth() const;
    void setLineWrapColumnOrWidth(int w);

    QTextOption::WrapMode wordWrapMode() const;
    void setWordWrapMode(QTextOption::WrapMode policy);

    bool find(const QString &exp, QTextDocument::FindFlags options = 0);

    inline QString toPlainText() const
    { return document()->toPlainText(); }
    inline QString toHtml() const
    { return document()->toHtml(); }

    void append(const QString &text);

    void ensureCursorVisible();

    virtual QVariant loadResource(int type, const QUrl &name);

    QMenu *createStandardContextMenu();


    QTextCursor cursorForPosition(const QPoint &pos) const;
    QRect cursorRect(const QTextCursor &cursor) const;
    QRect cursorRect() const;

    QString anchorAt(const QPoint& pos) const;

    bool overwriteMode() const;
    void setOverwriteMode(bool overwrite);

    int tabStopWidth() const;
    void setTabStopWidth(int width);

public :
    void setFontPointSize(qreal s);
    void setFontFamily(const QString &fontFamily);
    void setFontWeight(int w);
    void setFontUnderline(bool b);
    void setFontItalic(bool b);
    void setTextColor(const QColor &c);
    void setCurrentFont(const QFont &f);
    void setAlignment(Qt::Alignment a);

    void setPlainText(const QString &text);
    void setHtml(const QString &text);


    void cut();
    void copy();
    void paste();


    void clear();
    void selectAll();

    void insertPlainText(const QString &text);
    void insertHtml(const QString &text);

    void scrollToAnchor(const QString &name);

    void zoomIn(int range = 1);
    void zoomOut(int range = 1);

protected:
    void textChanged();
    void undoAvailable(bool b);
    void redoAvailable(bool b);
    void currentCharFormatChanged(const QTextCharFormat &format);
    void copyAvailable(bool b);
    void selectionChanged();
    void cursorPositionChanged();

protected:
    virtual void timerEvent(QTimerEvent *e);
    virtual void keyPressEvent(QKeyEvent *e);



    virtual void resizeEvent(QResizeEvent *);
    virtual void paintEvent(QPaintEvent *e);
    virtual void mousePressEvent(QMouseEvent *e);
    virtual void mouseMoveEvent(QMouseEvent *e);
    virtual void mouseReleaseEvent(QMouseEvent *e);
    virtual void mouseDoubleClickEvent(QMouseEvent *e);
    virtual bool focusNextPrevChild(bool next);
    virtual void contextMenuEvent(QContextMenuEvent *e);

    virtual void dragEnterEvent(QDragEnterEvent *e);
    virtual void dragLeaveEvent(QDragLeaveEvent *e);
    virtual void dragMoveEvent(QDragMoveEvent *e);
    virtual void dropEvent(QDropEvent *e);

    virtual void focusInEvent(QFocusEvent *e);
    virtual void focusOutEvent(QFocusEvent *e);
    virtual void showEvent(QShowEvent *);
    virtual void changeEvent(QEvent *e);

    virtual void wheelEvent(QWheelEvent *e);


    virtual QMimeData *createMimeDataFromSelection() const;
    virtual bool canInsertFromMimeData(const QMimeData *source) const;
    virtual void insertFromMimeData(const QMimeData *source);

    virtual void inputMethodEvent(QInputMethodEvent *);
    QVariant inputMethodQuery(Qt::InputMethodQuery property) const;

    QTextEdit(QTextEditPrivate &dd, QWidget *parent);


















































































private:
    QTextEdit(const QTextEdit &); QTextEdit &operator=(const QTextEdit &);




};



















































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QTextBrowserPrivate;

class __declspec(dllimport) QTextBrowser : public QTextEdit
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:







public:
    explicit QTextBrowser(QWidget* parent = 0);
    virtual ~QTextBrowser();

    QUrl source() const;

    QStringList searchPaths() const;
    void setSearchPaths(const QStringList &paths);

    virtual QVariant loadResource(int type, const QUrl &name);

public :
    virtual void setSource(const QUrl &name);
    virtual void backward();
    virtual void forward();
    virtual void home();
    virtual void reload();

protected:
    void backwardAvailable(bool);
    void forwardAvailable(bool);
    void sourceChanged(const QUrl &);
    void highlighted(const QUrl &);
    void highlighted(const QString &);
    void anchorClicked(const QUrl &);

protected:
    virtual void keyPressEvent(QKeyEvent *ev);
    virtual void mouseMoveEvent(QMouseEvent *ev);
    virtual void mousePressEvent(QMouseEvent *ev);
    virtual void mouseReleaseEvent(QMouseEvent *ev);
    virtual void focusOutEvent(QFocusEvent *ev);
    virtual bool focusNextPrevChild(bool next);
    virtual void paintEvent(QPaintEvent *e);






private:
    QTextBrowser(const QTextBrowser &); QTextBrowser &operator=(const QTextBrowser &);
    inline QTextBrowserPrivate* d_func() { return reinterpret_cast<QTextBrowserPrivate *>(d_ptr); } inline const QTextBrowserPrivate* d_func() const { return reinterpret_cast<const QTextBrowserPrivate *>(d_ptr); } friend class QTextBrowserPrivate;

};





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QToolBarPrivate;

class QAction;
class QIcon;
class QMainWindow;

class __declspec(dllimport) QToolBar : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:







public:
    explicit QToolBar(const QString &title, QWidget *parent = 0);
    explicit QToolBar(QWidget *parent = 0);
    ~QToolBar();

    void setMovable(bool movable);
    bool isMovable() const;

    void setAllowedAreas(Qt::ToolBarAreas areas);
    Qt::ToolBarAreas allowedAreas() const;

    inline bool isAreaAllowed(Qt::ToolBarArea area) const
    { return (allowedAreas() & area) == area; }

    void setOrientation(Qt::Orientation orientation);
    Qt::Orientation orientation() const;

    void clear();





    using QWidget::addAction;


    QAction *addAction(const QString &text);
    QAction *addAction(const QIcon &icon, const QString &text);
    QAction *addAction(const QString &text, const QObject *receiver, const char* member);
    QAction *addAction(const QIcon &icon, const QString &text,
		       const QObject *receiver, const char* member);

    QAction *addSeparator();
    QAction *insertSeparator(QAction *before);

    QAction *addWidget(QWidget *widget);
    QAction *insertWidget(QAction *before, QWidget *widget);

    QRect actionGeometry(QAction *action) const;
    QAction *actionAt(const QPoint &p) const;
    inline QAction *actionAt(int x, int y) const;

    QAction *toggleViewAction() const;

    QSize iconSize() const;
    Qt::ToolButtonStyle toolButtonStyle() const;

public :
    void setIconSize(const QSize &iconSize);
    void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);

protected:
    void actionTriggered(QAction *action);
    void movableChanged(bool movable);
    void allowedAreasChanged(Qt::ToolBarAreas allowedAreas);
    void orientationChanged(Qt::Orientation orientation);
    void iconSizeChanged(const QSize &iconSize);
    void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);

protected:
    void actionEvent(QActionEvent *event);
    void changeEvent(QEvent *event);
    void childEvent(QChildEvent *event);
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *event);
    bool event(QEvent *event);










private:
    inline QToolBarPrivate* d_func() { return reinterpret_cast<QToolBarPrivate *>(d_ptr); } inline const QToolBarPrivate* d_func() const { return reinterpret_cast<const QToolBarPrivate *>(d_ptr); } friend class QToolBarPrivate;
    QToolBar(const QToolBar &); QToolBar &operator=(const QToolBar &);




    friend class QMainWindow;
};

inline QAction *QToolBar::actionAt(int ax, int ay) const
{ return actionAt(QPoint(ax, ay)); }








































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QToolBoxPrivate;

class __declspec(dllimport) QToolBox : public QFrame
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QToolBox(QWidget *parent = 0, Qt::WFlags f = 0);
    ~QToolBox();

    int addItem(QWidget *widget, const QString &text);
    int addItem(QWidget *widget, const QIcon &icon, const QString &text);
    int insertItem(int index, QWidget *widget, const QString &text);
    int insertItem(int index, QWidget *widget, const QIcon &icon, const QString &text);

    void removeItem(int index);

    void setItemEnabled(int index, bool enabled);
    bool isItemEnabled(int index) const;

    void setItemText(int index, const QString &text);
    QString itemText(int index) const;

    void setItemIcon(int index, const QIcon &icon);
    QIcon itemIcon(int index) const;

    void setItemToolTip(int index, const QString &toolTip);
    QString itemToolTip(int index) const;

    int currentIndex() const;
    QWidget *currentWidget() const;
    QWidget *widget(int index) const;
    int indexOf(QWidget *widget) const;
    int count() const;

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *widget);

protected:
    void currentChanged(int index);

protected:
    virtual void itemInserted(int index);
    virtual void itemRemoved(int index);
    void showEvent(QShowEvent *e);
    void changeEvent(QEvent *);















private:
    inline QToolBoxPrivate* d_func() { return reinterpret_cast<QToolBoxPrivate *>(d_ptr); } inline const QToolBoxPrivate* d_func() const { return reinterpret_cast<const QToolBoxPrivate *>(d_ptr); } friend class QToolBoxPrivate;
    QToolBox(const QToolBox &); QToolBox &operator=(const QToolBox &);


};


inline int QToolBox::addItem(QWidget *item, const QString &text)
{ return insertItem(-1, item, QIcon(), text); }
inline int QToolBox::addItem(QWidget *item, const QIcon &iconSet,
                              const QString &text)
{ return insertItem(-1, item, iconSet, text); }
inline int QToolBox::insertItem(int index, QWidget *item, const QString &text)
{ return insertItem(index, item, QIcon(), text); }






























































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QToolButtonPrivate;
class QMenu;

class __declspec(dllimport) QToolButton : public QAbstractButton
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:








public:
    enum ToolButtonPopupMode {
        DelayedPopup,
        MenuButtonPopup,
        InstantPopup
    };

    explicit QToolButton(QWidget * parent=0);
    ~QToolButton();

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    Qt::ToolButtonStyle toolButtonStyle() const;

    Qt::ArrowType arrowType() const;
    void setArrowType(Qt::ArrowType type);


    void setMenu(QMenu* menu);
    QMenu* menu() const;

    void setPopupMode(ToolButtonPopupMode mode);
    ToolButtonPopupMode popupMode() const;


    QAction *defaultAction() const;

    void setAutoRaise(bool enable);
    bool autoRaise() const;

public :

    void showMenu();

    void setToolButtonStyle(Qt::ToolButtonStyle style);
    void setDefaultAction(QAction *);

protected:
    void triggered(QAction *);

protected:
    QToolButton(QToolButtonPrivate &, QWidget* parent);
    void mousePressEvent(QMouseEvent *);
    void paintEvent(QPaintEvent *);
    void actionEvent(QActionEvent *);

    void enterEvent(QEvent *);
    void leaveEvent(QEvent *);
    void timerEvent(QTimerEvent *);
    void changeEvent(QEvent *);

    void nextCheckState();

private:
    QToolButton(const QToolButton &); QToolButton &operator=(const QToolButton &);
    inline QToolButtonPrivate* d_func() { return reinterpret_cast<QToolButtonPrivate *>(d_ptr); } inline const QToolButtonPrivate* d_func() const { return reinterpret_cast<const QToolButtonPrivate *>(d_ptr); } friend class QToolButtonPrivate;


















































};































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef QtValidLicenseForGuiModule QtGuiModule;



class QAction;
class QWorkspaceChild;
class QShowEvent;
class QWorkspacePrivate;

class __declspec(dllimport) QWorkspace : public QWidget
{
    public: static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0) { return staticMetaObject.tr(s, c); } static inline QString trUtf8(const char *s, const char *c = 0) { return staticMetaObject.trUtf8(s, c); } virtual int qt_metacall(QMetaObject::Call, int, void **); private:



public:
    explicit QWorkspace(QWidget* parent=0);
    ~QWorkspace();

    enum WindowOrder { CreationOrder, StackingOrder };

    QWidget* activeWindow() const;
    QWidgetList windowList(WindowOrder order = CreationOrder) const;

    QWidget * addWindow(QWidget *w, Qt::WFlags flags = 0);

    QSize sizeHint() const;

    bool scrollBarsEnabled() const;
    void setScrollBarsEnabled(bool enable);







    void setBackground(const QBrush &background);
    QBrush background() const;

protected:
    void windowActivated(QWidget* w);

public :
    void setActiveWindow(QWidget *w);
    void cascade();
    void tile();
    void closeActiveWindow();
    void closeAllWindows();
    void activateNextWindow();
    void activatePreviousWindow();

protected:
    bool event(QEvent *e);
    void paintEvent(QPaintEvent *e);
    void changeEvent(QEvent *);
    void childEvent(QChildEvent *);
    void resizeEvent(QResizeEvent *);
    bool eventFilter(QObject *, QEvent *);
    void showEvent(QShowEvent *e);
    void hideEvent(QHideEvent *e);

    void wheelEvent(QWheelEvent *e);


private:
    inline QWorkspacePrivate* d_func() { return reinterpret_cast<QWorkspacePrivate *>(d_ptr); } inline const QWorkspacePrivate* d_func() const { return reinterpret_cast<const QWorkspacePrivate *>(d_ptr); } friend class QWorkspacePrivate;
    QWorkspace(const QWorkspace &); QWorkspace &operator=(const QWorkspace &);








    friend class QWorkspaceChild;
};







