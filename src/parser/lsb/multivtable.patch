==== //depot/research/main/cppparser/lsb/lsbdb.cpp#10 - /home/harald/troll/research/cppparser/lsb/lsbdb.cpp ====
--- /tmp/tmp.10732.0	2006-01-17 17:59:40.000000000 +0100
+++ /home/harald/troll/research/cppparser/lsb/lsbdb.cpp	2006-01-17 17:35:58.000000000 +0100
@@ -223,7 +223,8 @@ static QList<ClassInfo> getClassInfos(co
 }
 
 int LsbDb::addClass(const QString &type, const QString &className, const QList<int> &baseTypeIds,
-              int vTableId, const QStringList &vTable, int typeInfoId, const QString &baseVType,
+              QList<int> vTableId, const QStringList &vTable,
+              int typeInfoId, const QString &baseVType,
               const QString &header, const QString &headerGroupName)
 {
     static int vmiTypeId = interfaceId("_ZTVN10__cxxabiv121__vmi_class_type_infoE");
@@ -255,9 +256,9 @@ int LsbDb::addClass(const QString &type,
     else
         q.addBindValue("_Z" + QString::number(className.length()) + className);
     q.addBindValue(classId);
-    q.addBindValue(vTableId);
+    q.addBindValue(vTableId.value(0));
     q.addBindValue(vTable.count());
-    q.addBindValue(vTableId ? 1 : 0);
+    q.addBindValue(vTableId.count());
     q.addBindValue(typeInfoId); // CIrtti
     q.addBindValue(vmi ? 0 : baseTypeIds.count());
     q.addBindValue(baseClassInfo.value(0).rtti); // CIbase
@@ -269,11 +270,14 @@ int LsbDb::addClass(const QString &type,
     int classInfoId = q.lastInsertId().toInt();
 
     // TODO - multiple inheritance, platform specific vtables
-    q.prepare("insert into ArchClass(ACcid, ACaid) values (?, ?)");
+    q.prepare("insert into ArchClass(ACcid, ACaid, ACpos) values (?, ?, ?)");
+    for (int i = 0; i < vTableId.count(); ++i) {
     q.addBindValue(classInfoId);
     q.addBindValue(1);
+        q.addBindValue(i);
     if (!q.exec())
         qWarning() << "unable to add ArchClass" << q.lastError();
+    }
 
     if (vmi) {
         q.prepare("insert into VMIBaseTypes(VBTcid, VBTpos, VBTbasetype, VBTaid) "
@@ -298,22 +302,24 @@ int LsbDb::addClass(const QString &type,
     }
 
     // dump the vtable if we have one
-    if (vTableId) {
+    if (vTableId.count()) {
         q.prepare("insert into ClassVtab (CVcid, CVclass, CVpos, CVrtti, CVnumvtfuncs) "
                   "values (?, ?, ?, ?, ?)");
+        for (int i = 0; i < vTableId.count(); ++i) {
         q.addBindValue(classInfoId);
         q.addBindValue(1);
-        q.addBindValue(0);
+            q.addBindValue(i);
         q.addBindValue(typeInfoId);
-        q.addBindValue(vTable.count());
+            q.addBindValue(vTable.count()); // will be overwritten in addVtable
         if (!q.exec())
             qWarning() << "Unable to dump ClassVTab" << q.lastError();
     }
+    }
 
     return classInfoId;
 }
 
-bool LsbDb::addVtable(int classInfoId, const QStringList &vTable)
+bool LsbDb::addVtable(int classInfoId, const QStringList &vTable, int pos)
 {
     QSqlQuery q;
     q.prepare("select Iid from Interface where Iname = ?");
@@ -339,7 +345,7 @@ bool LsbDb::addVtable(int classInfoId, c
 
     for (i = 0; i < typeIds.count(); ++i) {
         q.addBindValue(classInfoId);
-        q.addBindValue(0);
+        q.addBindValue(pos);
         q.addBindValue(i);
         q.addBindValue(typeIds.at(i));
         q.addBindValue(1);
==== //depot/research/main/cppparser/lsb/lsbdb.h#7 - /home/harald/troll/research/cppparser/lsb/lsbdb.h ====
--- /tmp/tmp.10732.1	2006-01-17 17:59:40.000000000 +0100
+++ /home/harald/troll/research/cppparser/lsb/lsbdb.h	2006-01-17 16:50:51.000000000 +0100
@@ -55,10 +55,10 @@ public:
     inline void setCurrentModuleId(int mid) { modId = mid; }
 
     int addClass(const QString &type, const QString &className, const QList<int> &baseTypeIds,
-                 int vTableId, const QStringList &vTable, int typeInfoId,
+                 QList<int> vTableId, const QStringList &vTable, int typeInfoId,
                  const QString &baseVType,
                  const QString &header, const QString &headerGroupName = QString());
-    bool addVtable(int classInfoId, const QStringList &vTable);
+    bool addVtable(int classInfoId, const QStringList &vTable, int pos);
     int addMember(const QString &memberName, int typeId, int position, int memberOf);
     int addReadOnlyData(const QString &name, const QString &header);
     int addFunction(const QString &name, const QString &returnType, const QString &header,
==== //depot/research/main/cppparser/lsb/main.cpp#30 - /home/harald/troll/research/cppparser/lsb/main.cpp ====
--- /tmp/tmp.10732.2	2006-01-17 17:59:40.000000000 +0100
+++ /home/harald/troll/research/cppparser/lsb/main.cpp	2006-01-17 17:33:58.000000000 +0100
@@ -60,13 +60,16 @@ struct VTableInfo
 {
     QStringList lines;
     QStringList functions() const;
+    QStringList vTable(int pos) const;
+    int numVTables;
     int numEntries;
+    int classId;
+    mutable QStringList funcs;
+    mutable QList<int> vTables;
 };
 
 QHash<QString, VTableInfo> vTables;
 
-QList<QPair<int, QStringList> > classVTables;
-
 FileModelItem dom;
 
 static QStringList extractSyms(const QString &out, bool mangled)
@@ -476,12 +479,19 @@ static int qDumpClass(const QString &man
     int typeInfoId = lsbDb.interfaceId("_ZTI" + symName);
     int vTableId = lsbDb.interfaceId("_ZTV" + symName);
 
+    QList<int> vTableIds;
+
     QStringList vTable;
     if (vTableId) {
         VTableInfo info = vTables.value(citem->qualifiedName().join("::"));
         if (info.lines.isEmpty())
             qWarning() << "Unable to find Vtable for " + citem->qualifiedName().join("::");
         vTable = info.functions();
+
+        // don't have virtual inheritance, so simplify
+        for (int i = 0; i < info.numVTables; ++i) {
+            vTableIds += vTableId;
+        }
     }
 
     QList<int> baseIds;
@@ -495,11 +505,11 @@ static int qDumpClass(const QString &man
     }
 
     int cId = lsbDb.addClass(classTypeName(citem->classType()), mangledName, baseIds,
-                         vTableId, vTable, typeInfoId,
+                         vTableIds, vTable, typeInfoId,
                          baseVTables.value(citem->qualifiedName().join("::")), header(citem));
 
     if (cId && !vTable.isEmpty())
-        classVTables += QPair<int, QStringList>(cId, vTable);
+        vTables[citem->qualifiedName().join("::")].classId = cId;
 
     return cId;
 }
@@ -608,7 +618,7 @@ static int handleQFlag(const TypeAliasMo
 
     getQFlagName(titem, mangledName, unmangledName);
 
-    int tid = lsbDb.addClass("Class", mangledName, QList<int>(), 0, QStringList(),
+    int tid = lsbDb.addClass("Class", mangledName, QList<int>(), QList<int>(), QStringList(),
                              0, false, header(titem));
     flagTypeCache[titem->type().qualifiedName().at(0)] = unmangledName;
     return tid;
@@ -1088,6 +1098,8 @@ void getVTables()
                 qFatal("cannot parse vtable entry: %s", qPrintable(lines.join("\n")));
 
             info.numEntries = re.cap(1).toInt();
+            info.numVTables = lines.filter("(int (*)(...))(& ").count();
+            info.classId = 0;
             info.lines = lines;
             vTables[lines.at(0).mid(11)] = info;
         }
@@ -1148,9 +1160,24 @@ static QString mangledDestructor(const Q
     return QString();
 }
 
-QStringList VTableInfo::functions() const
+
+QStringList VTableInfo::vTable(int pos) const
 {
+    int startIdx = vTables.value(pos - 1, 0);
+    int endIdx = vTables.value(pos, vTables.count());
+
     QStringList res;
+    for (int i = startIdx; i < endIdx; ++i)
+        res += funcs.value(i);
+
+    return res;
+}
+
+QStringList VTableInfo::functions() const
+{
+    if (!funcs.isEmpty())
+        return funcs;
+
     QRegExp funcRx("\\d+\\s+(.*)");
     int i;
     for (i = 2; i < lines.count(); ++i) {
@@ -1158,79 +1185,95 @@ QStringList VTableInfo::functions() cons
             qFatal("cannot parse vtable entry at %d: %s", i, qPrintable(lines.join("\n")));
         QString match = funcRx.cap(1).trimmed();
         if (!match.startsWith("(int (*)(...))"))
-            res += match;
+            funcs += match;
+        if (match.startsWith("(int (*)(...))(&"))
+            vTables += funcs.count() + 1;
     }
     int vDestructorIdx = 0;
-    for (i = 0; i < res.count(); ++i) {
-
-        QStringList qualName = res.at(i).left(res.at(i).indexOf('(')).split("::");
+    for (i = 0; i < funcs.count(); ++i) {
+        QStringList qualName = funcs.at(i).left(funcs.at(i).indexOf('(')).split("::");
         QString funcName = qualName.takeLast();
-        QString normalizedSym = normalizedVTableEntry(res.at(i));
+        QString normalizedSym = normalizedVTableEntry(funcs.at(i));
         if (funcName == "__cxa_pure_virtual") {
-            res[i] = "__cxa_pure_virtual";
+            funcs[i] = "__cxa_pure_virtual";
             continue;
         } else if (funcName.startsWith("_ZThn")) {
-            res[i] = funcName;
+            funcs[i] = funcName;
             continue;
         } else if (funcName.startsWith("~")) {
             QString destr = mangledDestructor(normalizedSym, vDestructorIdx);
             if (!destr.isEmpty()) {
-                res[i] = destr;
+                funcs[i] = destr;
                 ++vDestructorIdx;
                 continue;
             }
             // else fall through and add it later
         } else if (symbols.contains(normalizedSym)) {
-            res[i] = symbols.value(normalizedSym);
+            funcs[i] = symbols.value(normalizedSym);
             continue;
         }
 
         ScopeModelItem scope = model_dynamic_cast<ScopeModelItem>(
                 dom->model()->findItem(qualName, model_static_cast<CodeModelItem>(dom)));
         if (!scope) {
-            qWarning() << "unable to find scope for" << res.at(i);
+            qWarning() << "unable to find scope for" << funcs.at(i);
             continue;
         }
 
-        QList<FunctionModelItem> funcs = scope->functionMap().values(funcName.left(
+        QList<FunctionModelItem> functions = scope->functionMap().values(funcName.left(
                     funcName.indexOf('(')));
  //       stripNonVirtual(funcs);
 
-        if (funcs.isEmpty()) {
+        if (functions.isEmpty()) {
             if (funcName.startsWith('~')) {
                 // add the implicit destructors
-                res[i] = addDestructor(funcName.left(funcName.indexOf('(')).mid(1), scope);
+                funcs[i] = addDestructor(funcName.left(funcName.indexOf('(')).mid(1), scope);
                 ++vDestructorIdx;
             } else {
-                qWarning() << "unable to find function in vtable" << res.at(i) << funcName.left(funcName.indexOf('('));
+                qWarning() << "unable to find function in vtable" << funcs.at(i) << funcName.left(funcName.indexOf('('));
             }
             continue;
         }
 
-        if (funcs.count() > 1) {
-            qWarning() << "overloaded virtual found for" << res.at(i);
+        if (functions.count() > 1) {
+            qWarning() << "overloaded virtual found for" << funcs.at(i);
             // TODO - handle overloaded virtuals
         }
-        QString func = functionWithSignature(funcs.at(0));
+        QString func = functionWithSignature(functions.at(0));
         if (!symbols.contains(func)) {
-            qWarning() << "Unable to find vtable function" << res.at(i) << func;
-            res[i] = QString();
-        } else if (funcs.at(0)->name().startsWith('~')) {
-            res[i] = mangledDestructor(func, vDestructorIdx++);
+            qWarning() << "Unable to find vtable function" << funcs.at(i) << func;
+            funcs[i] = QString();
+        } else if (functions.at(0)->name().startsWith('~')) {
+            funcs[i] = mangledDestructor(func, vDestructorIdx++);
         } else {
-            res[i] = symbols.value(func);
+            funcs[i] = symbols.value(func);
         }
     }
 
-    return res;
+    return funcs;
 }
 
 static void dumpVTables()
 {
+    for (QHash<QString, VTableInfo>::const_iterator it = vTables.constBegin();
+         it != vTables.constEnd(); ++it) {
+        if (!it.value().classId) {
+//            qWarning() << "Class" << it.key() << "has virtual table, but wasn't dumped";
+            continue;
+        }
+
+//        qDebug() << "dumping" << it.key() << it.value().numVTables << it.value().functions();
+
+        for (int i = 0; i < it.value().numVTables; ++i) {
+            lsbDb.addVtable(it.value().classId, it.value().vTable(i), i);
+        }
+    }
+    /*
     for (int i = 0; i < classVTables.count(); ++i) {
         QPair<int, QStringList> entry = classVTables.at(i);
         lsbDb.addVtable(entry.first, entry.second);
     }
+    */
 }
 
 static void getVTT()
